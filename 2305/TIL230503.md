1일1커밋 무사고: 166일차

00:00

# todo

- [x] 모노레포 특강 듣기
  - 19:00 ~ 22:00
  - [자료 링크](https://lean-mahogany-686.notion.site/5-d759234b0bf14936bcf4981d3505f86d)
- [ ] 리팩토링 읽기
  - [x] 1.8 다형성을 활용해 계산 코드 재구성하기
  - [ ] 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기
  - [ ] 1.10 마치며
- [x] 1일3제
- [x] 면접 질문 복습
- [x] 화상 면접(빅웨이브로보틱스)
  - 면접 시간: 16:00~ 16:30

# want todo

- [ ] 블로그
  - [ ] 사이드바
  - [ ] Nav
  - [ ] logo
  - [ ] config

# 강의

모노 레포란 무엇인가?

단단한 하나의 git 저장소

글이 많으면 노잼입니다.

nvm은 실무할 때 은근히 유용합니다. node의 다양한 버전에 따라 동작 여부가 달라질 수 있습니다. 시작은 NVM입니다. 사실 실습에는 문제는 없습니다.

yarn berry 실무에 유용합니다.

오늘 기준으로 yarn 버전은 1.22.19 나오면 괜찮습니다. 프로젝트를 만들면 버전이 달라집니다.

```sh
cd
```

```
.yarn
.pnp.cjs
.pnp.loader.mjs
.yarnrc.yml
yarn.lock
```

처음에 설정 잘못하면 위에 것들을 삭제해야 합니다.

`abumalick.vscode-nvm` 익스텐션을 받으면 `.nvmrc`에서 `lts/hydrogen`을 작성하면 18버전으로 자동 설정될 것입니다. 상당히 좋습니다. 로고가 없어서 id를 활용하도록 합니다.

yarn 2에서부터 모노레포를 지원하는 기능이 강해졌습니다. 1은 원래 지원하고 있었습니다.

`yarn init -w` 워크 스페이스 생성 명령입니다.

`packages`는 같이 공유할 패키지를 넣습니다. 관습은 `packages`라고 합니다. 그래서 자동생성됩니다.

`apps`는 이름을 무조건 따를 필요는 없습니다. `docs`로 문서화도 하는 경우도 있습니다.

설치한 json에 `"name": "@wanted/web",`으로 설정합니다. 이렇게 설정하면 `yarn workspace @wanted/web run dev` 으로 명령하면 모노레포에서 실행할 수 있습니다.

프로젝트 관리는 pnp.cjs에 보관합니다. apps 폴더에 설치 뒤에는 루트로 돌아와서 yarn 명령을 해야 합니다.

타입스크립트 lsp가 적용될 수 있도록 2가지 명령만 모노레포 루트에서 처리하면 됩니다.

순서는 설치 -> package.json 이름 변경 -> 루트에서 yarn 명령

```sh
yarn add -D typescript
yarn dlx @yarnpkg/sdks vscode
```

이렇게 VScode에 명령하고 타입스크립트를 감지할 수 있습니다.

arcanis.vscode-zipfs 이 익스텐션 추가도 권장합니다.

pnp.cjs는 중요한 파일입니다.

zero-install 전략도 있습니다.

.vscode 폴더는 설치 권장을 알려주게 만들 수 있습니다.

package 폴더 속에는 다른 레포들이 공유할 리소스를 담습니다.

lib 폴더를 만들고 yarn init을 합니다.

src는 공유할 파일을 담습니다. 프로젝트 사이 의존성을 만들 수 있습니다.

yarn workspace @wanted/web add @wanted/lib 이런 명령으로 하위 레포에 패키지를 전달할 수 있습니다.

yarn은 pnp의 반영명령입니다.

모노레포에서 어드민과 어플리케이션을 같이 만들 수 있습니다. 공통 라이브러리와 API 모델, 비즈니스로직 공유가 가능해집니다.

이제 이론입니다. 모노레포를 사용하는 케이스 대표적으로 3가지입니다. 개인적인 경험입니다.

1. 라이브러리 개발할 때 유용합니다. 바벨이 대표적입니다. 바벨 하위 프로젝트를 개별 설치하는 것이 가능합니다. 라이브러리 관리에 유용합니다. 또 디자인 시스템 도입도 모노레포로 많이 만듭니다.

radix-ui 라이브러리를 볼 수 있습니다.

2. 서비스 운영하는 예시입니다. B2B, B2C 어드민 하나로 합칠 때 유용합니다. 현재 원티드는 놀랍게도 폴리레포입니다. api 모델, 인증로직 중복작성하게 될 가능성이 있습니다.

배달의 민족에서 어드민, 오피스, 모바일 오피스로 구성하는 것처럼 적용하고 있습니다. 배달의 민족은 인싸라 pnpm을 활용하고 있습니다.

3. 마이크로 프론트엔드와 마이크로 서비스로 전향하기 유용합니다.

마이크로 서비스의 시대입니다. 최소한 성장한 기업입장에서는 맞습니다.

토스에는 30개의 서비스가 있었습니다. 하나의 모놀리스를 쪼갰습니다. 토스는 yarn workspace를 활용했습니다.

리액트앱을 마이크로 프론트엔드로 쪼개는데 모노레포를 활용했습니다.

모놀리스입니다.

단일 레포에서 여러 프로젝트로 쪼개는 전략입니다.

모노레포란 여러 개의 프로젝트를 개별 프로젝트를, 잘 정의된 관계를 통해서 하나의 레포에 담은 것입니다. 긱스 뉴스를 참고하기 바랍니다.

모놀리스랑 다르게 자율성이 있습니다. 각자 프로젝트가 원하는 라이브리를 자유롭게 사용할 수 있습니다. 폴리레포는 코드공유가 어렵습니다. 패키지 신버전 반영이 쉽습니다. 라이브러리의 파괘적인 반영을 지연시킬 수 있습니다. 라이브러리 변경에 참조파악이 쉽습니다. 대규모 리팩토링을 어디에 해야 할지 파악하기 수월합니다.

만약에 폴리레포는 매개변수가 추가되는 파괘적인 변경이 발생하면 연락을 일일이 취해야 합니다. 하지만 모노레포는 변경을 가한사람이 모두 변경해서 진행할 수 있습니다. 라이브러리 버전 변경 요청이 간소해진 점이 좋습니다.

모노레포의 장점 위주로 이야기했지만 단점도 있습니다.

- 개발환경을 구성하는데 초기투자를 해야 합니다. 배포를 어떻게 할지 이런 부분도 어렵습니다.
- 코드 소유권 개념이 모호해집니다. 담당자가 누구인지 애매해지는 상황이 쉽게 발생합니다.
  - 소스에 대한 책임과 무결성 문제가 될 수 있습니다.
- 리팩토링이 쉬워집니다. 이점이 장점이자 단점입니다. 너무 쉽게 변경을 가할 수 있으면 문제가 됩니다.
  - 대규모 리팩토링의 잘못된 관행을 조장합니다.

구글이 세계에서 제일큰 모노레포를 보유하고 있습니다.

깃허브가 풀 마이크로서비스로 전향한 점이 실수였다고 합니다.

서비스가 너무 많으면 소유권문제가 됩니다. 또 도구를 너무 많이 추가해야 합니다.

가능하면 모놀리스로 유지하고 모노레포로 분리를 시작하믄 큰것부터 쪼갭니다.

명령 파레트로 ts 서버 재시작으로 타입스크립트 lsp를 구동시킬 수 있습니다. 더이상 세팅 문제가 없으면 활용해보기를 권장합니다.

ESlint 서버도 재시작 구동이 가능합니다.

구성해볼 수 있는 전략은 apps에 프로젝트를 넣습니다. 그리고 디자인시스템, 타입스크립트의 타입, React-hook과 공통라이브러리를 packages에 넣습니다.

내일은 조금더 특이한 것을 시도합니다. 오늘 구성한 것을 베이스로 활용합니다. ESlint를 적용하고 타입스크립트 설정 컨벤션을 같이 가져갑니다. 모노레포의 장점을 활용합니다.

개발팀이 바뀌어도 어색하지 않게 적응할 수 있게 해줍니다.

개발팀이 바뀌어도 바로 진행할 수 있게 컴포넌트 공유도 시도해볼 것입니다. yarn barry를 활용하는데 다음주에는 타입체킹과 빌드하고 배포하고 github 액션 코드 공유도 진행합니다.

turborepo도 시도합니다. 세팅할 것이 없습니다. 세팅이 없어서 간편하고 그 편안함과 원리를 이해하기 위해 이렇게 설치하는 방법을 배워봅니다. 또 원리를 알아야 디버깅하기 쉽습니다.

yarn 1으로 workspace를 구성하는 것은 대부분 찾기 힘들어서 제외했습니다. 1에서 발생하는 차이는 의존성 주입할 때 cli로 주입할 수 없었습니다.

잘 알면 어렵지 않습니다. 잘못하면 세팅 지옥이 됩니다. 프로필 루트에서 명령하면 버전이 꼬일 수 있습니다. 공식문서는 쉽다는 쉽지 않습니다.

.yarnrc.yml에 nodeLinker를 pnp으로 설정하면 자동 지원됩니다. pnp 모드가 기본으로 지원됩니다. 지원하지 않으면

```yml
nodeLinker: "pnp"
```

기본 설정입니다.

```yml
nodeLinker: "node-modules"
```

원래 익숙한 node 모듈이 됩니다.

모노레포랑 웹성능은 당연히 관련이 없습니다. 그냥 레포관리법입니다.

모노레포에는 Nest.js를 같이 넣는 경우도 많이 있습니다. OpenAPI로 만든 레포노 넣는 경우도 있습니다. 정성적인 장점은 본인이 담당하는 프로젝트가 아니여도 개선의 여지를 발견하면 바로 수정을 시도 해볼 수 있습니다. 또 다른 장점은 10x 개발자의 PR을 보고 배울 수 있습니다. 다른 팀에 있으면 보고 배우기는 애매합니다. 공식문서에서 간단하게 풀었던 것을 보고 배울 수 있습니다.

같은 도메인을 공유하면 유용할 수 있습니다. 런타임 통합은 다릅니다. 그것은 별도입니다.

비즈니스 결합도가 높으면 런타임을 통합하면 될 것 같지만 모노레포와 무관해집니다.

리액트 네이티브가 상당히 적절한 케이스입니다. custom hook을 공유하는 것으로 비즈니스 로직을 공유하는 것이기 때문에 좋습니다.

모노레포는 빌드시간이랑 연관이 없습니다. github 액션에 빌드 결과를 보고 아티팩트라고하는데 이 아티팩트 캐싱을 공유하는 법을 나중에 배울 것입니다. 그래서 다른 프로젝트가 덕을 볼 수 있게 할 수 있습니다.

github가 모노레포를 많이 이용해서 모노레포 관련된 다양한 기능을 지원받을 수 있습니다. github 공식 블로그를 보면 알 수 있습니다. 코드 소유권을 지정할 수 있습니다.

- 여기를 참고하기 바랍니다. https://docs.github.com/ko/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners

모노레포는 패키지 매니저가 다르면 의미가 퇴색됩니다. 하지만 이것도 통합하는 라이브러리도 존재합니다. monorepo tools에서 가능합니다.

모노레포는 면접질문으로 나오려면 이력서에 포함해야 나옵니다. 왜 하게 되었는지 기술을 활용했던 경향을 질문합니다. 장학퀴즈는 지향합니다. 내일은 타입스크립트와 린트 공유와 시간이 남으면 공용컴포넌트 공유도 진행합니다.
