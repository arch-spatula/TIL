1일1커밋 무사고: 174일차

06:40

# TIL

## todo

- [x] 모노레포 특강
- [x] 리팩토링 읽기
  - 202 ~ 207/535
  - [ ] CHAPTER 06 기본적인 리팩터링
    - [x] 6.9 여러 함수를 클래스로 묶기
    - [ ] 6.10 여러 함수를 변환 함수로 묶기
    - [ ] 6.11 단계 쪼개기
- [ ] 입사 지원 [태그바이컴퍼니 (TAGby)](https://www.wanted.co.kr/wd/157290)
- [x] 사이클 20분
- [x] 프로그래머스 1시간 이상 문제 풀이
- [x] 모노레포 어제 내용 복습

## vim

- `ctrl` + `n`: 자동완성 추천

## 문자열 자르기

```js
function solution(my_str, n) {
  return my_str.match(new RegExp(`.{1,${n}}`, "g"));
}
```

## 모노레포 특강

오늘은 실습이 없습니다. 오픈 소스를 보는 시간이 될 것입니다.

평소에 오픈소스를 자주 보는가? 이번 시간을 계기로 오픈소스를 많이 읽는 연습을 하도록 합니다.

오픈소스에서 다른 사람들이 작성한 패턴화된 코드를 볼 수 있습니다. 공부에 상당히 좋습니다.

작업하다가 막히면 오픈소스를 탐구하는 것도 한계를 극복하는데 상당히 도움됩니다.

어제 배운 부분을 간단하게 복습하겠습니다.

toss yarn barry workspace 플러그인을 활용해봤습니다. 변경이 있으면 해당하는 워크 스페이스를 추출하고 빌드하는 명령을 배웠습니다.

이 방식은 많은 프로젝트가 있으면 사람이 의식해서 배포하는 것이 아니라 변경 전후를 기계가 비교하게 만들어서 배포합니다.

해당 프로젝트마다 배포하는 전략도 배웠습니다.

작업 트리거는 on을 확인하면 됩니다. 아티팩트 캐싱하는 것도 볼 수 있었습니다.

manual은 동일한 빌드를 수동으로 github action을 트리거하도록 하는 방법을 배웠습니다.

마지막에는 turbo repo를 배웠습니다. 이미 모든 것들이 설정되어 있기 때문에 설정이 쉽고 간단합니다. 상황에 따라 세팅하는데 리소스가 별로 없으면 좋은 선택지인 것을 봤습니다.

오늘은 오픈소스를 한 번 보는 시간입니다. 개인적으로 오픈소스를 자주 보는 습관을 들여야 합니다. github action 세팅도 오픈소스로 배울 수 있습니다.

오늘은 vue를 확인합니다. vue는 pnpm을 사용하고 있습니다. vitest를 활용해서 테스트를 하고 있습니다.

오픈소스를 분석하기 시작할 때는 package.json부터 보는 것이 좋습니다. vite답게 rollup을 번들러로 활용하고 있습니다. 여기서부터 세팅도 공부해볼 수 있습니다.

최근에 src 활용여부를 논의하고 있습니다. 이처럼 src 활용여부를 오픈소스는 어떻게 실천하는지 보고 배울 수 있습니다.

pnpm도 workspace를 지원하는데 개별 yml을 만드는 방식이 다릅니다. 설정을 어떻게 하는지 검색하고 보고 배울 수 있습니다.

당근마켓의 github도 공개되어 있습니다. 당근마켓은 yarn barry를 사용하고 있고 pnp모를 사용하지 않고 있습니다.

공개된 명령어도 보고 무엇을 실행하는지 탐구해볼 수 있습니다.

번들러 중에 roma 도 볼 수 있습니다. ultra 명령도 있습니다. clone하고 공부해볼 수 있습니다. local에서 실행시켜보도록 합니다.

공부하기 위해 분석해보는 시간을 갖도록 합니다.

당근마켓은 프론트엔드 관련 레포들이 많이 있습니다. 보고 공부하도록 합니다.

문법도 보고 배울 수 있습니다.

toss에서 slash 라이브러리를 공개했습니다. node version은 개발에서 중요하기 때문에 주의하도록 합니다.

build 할때 jest, test, storybook은 컴파일할 때 읽지 않도록 만들 수 있습니다.

esm은 esm 빌드로 따로 하도록 합니다.

라이브러리 만들 때 설정들이 중요합니다.

peerDependencies는 라이브러리를 사용하기 위해 설치되어 있는데 최소버전을 알려주는 정보입니다.

toss는 yarn을 아주 잘 사용합니다. zero-install 전략을 활용하고 있습니다.

github를 사용하는데 빌드처리하는 것이 없습니다.

기여 가이드 문서도 제공하고 있습니다. 배포는 circle ci를 활용하고 있습니다. github action과 유사합니다. yarnrc와 yarnrc.yml 2개를 두는 이유가 의문이 들 수 있습니다.

토스는 packages를 설계하는 것도 특이합니다. 정리가 잘 되어 있습니다. 목적별로 분류가 가능합니다.

rooks 라이브러리는 특이합니다. 모노레포로 되어 있습니다. turbo로 되어 있습니다. rooks 폴더에 핵심 비즈니스 로직들을 모았습니다.

IntersectionObserver를 활용하고 특이한 hook들을 어떻게 적용하는지 보고 배울 수 있습니다.

JSDoc 활용도 볼 수 있습니다. JSDoc 공식 문서 가독성이 상당히 떨어집니다. 개인프로젝트에서라도 도움이 많이 됩니다.

보고 배울 때 무엇이 무엇을 하는지 파악하기 위에 조각단위로 가져와보도록 합니다.

테스트 코드를 보면서 테스트 설계도 배울 수 있습니다.

공개된 자료를 보고 배울 수 있습니다. 초보 개발자들의 아티클에 덜 의존해볼 수 있습니다.

dayjs, date-fns, recoil

recoil입니다. 타입스크립트는 기초입니다. 하지만 과거 페이스북에서는 flow를 활용했습니다.

설치할 때 yarn barry도 peerDependencies가 안 맞으면 경고만 하고 있습니다. 모노레포 설정은 없습니다. recoil은 모노레포이지만 workspace로 공유하고 있지는 않습니다. 구조가 상당히 특이합니다.

esm과 cjs를 섞어 사용했습니다.

차크라 ui는 들어봤을 것입니다. 차크라 ui가 zag를 만들었습니다. 라이브러리를 어떻게 배포하고 관리하는지 package.json을 각 workspace마다 확인하면서 공부할 수 있습니다.

오픈소스에서 ci 테스트를 어떻게 다르게 하는지 보고 배울 수 있습니다.

문서에서 changeset 라이브러리로 작업내역을 로컬에서 볼 수 있게 할 수 있습니다. slack api를 활용해서 통지가 가게 만들 수 있습니다.

노티, 문서화를 자동화할 수 있게 작업 구성할 수 있습니다.

라이브러리 혹은 서비스 만들때 빌드단계에서 사이즈를 알려주도록 만들 수 있습니다. 컴파일된 사이즈를 알 수 있습니다. 사이즈 초과하면 알림이 가게 만들 수 있습니다.

모노레포를 사용해도 버저닝을 하고 있으면 외부참조를 하고 있는 것입니다. 패키지 만들 때 설정보면서 npm 등록에 설정이 중요합니다.

tailwind는 turbo를 활용하고 있습니다. 그리고 npm을 사용하고 있는 것으로 보입니다. root에 이런저런 패키지를 설치하고 src에 담는 방식입니다. 정리가 잘 안된 느낌입니다.

관심사 분리가 덜 되어 있기 때문에 그렇습니다.

오픈소스를 분석하면 성장효율이 좋습니다. 어려우면 작거나 옛날 코드베이스에서 출발하는 것도 전략입니다.

마무리입니다.

모노레포는 트렌디하고 화려해보일 수 있는 기술입니다. 하지만 더 중요한 것은 어떻게 문제를 잘 해결할 수 있는 도구로 바라봐야 합니다. 발전된 개인 프로젝트를 추가하고 발전시키는 모습을 보여주는 것이 전략입니다. 하나의 레포로 관리해서 사이드 프로젝트, 토이프로젝트를 시도해보는 것도 좋은 방법입니다.

실무에서는 B2B, B2C, 어드민 통합에 유용합니다.

toss는 빌드 배포문제 때문에 마이크로서비스로 쪼개면서 전환을 위해 사용합니다.

모노레포는 잘 정의된 관계를 하나의 Repo에 담은 것입니다. 정의는 비즈니스, 도메인의 문제입니다.

turbo를 활용하기 전에 수동으로 해보는 경험이 있어야 효용을 체감할 수 있습니다.

feature flag로 운영 맛보기도 해볼 수 있습니다. trunk base 전략입니다.

실무에서는 여러명의 프론트엔드 개발자들과 협업해야 하는 환경입니다. 모노레포를 구성하면 상호작용하면서 성장할 환경이 제공됩니다. 장점이자 단점으로 가변성이 높습니다. 여러 프로덕트에서 올라오는 코드를 볼 수 있어서 다른 프로덕트를 보고 배울 수 있고 의견을 잘 주고 받을 수 있습니다. 자유롭게 코드를 기웃거릴 수 있는 환경이 좋습니다. 잘 몰랐던 것을 더 깔끔하게 처리할 수 있게 됩니다. 전체 레포에 대해서 주인의식이 생겨서 전체적으로 개선되는 이점이 있습니다. 기술적, 비즈니스적으로 성장할 수 있습니다. 혼자 개발할 때는 재미없기 쉽습니다. 기술적으로 이야기할 것들이 있어야 합니다.

SOT를 구축할 수 있습니다. lint, prettier, 공통패키지를 사용하면 됩니다. CI/CD 파이프라인도 통합됩니다. 새로운 프로젝트를 시작하는데 세팅에 들여야 할 수고가 덜어집니다.

1년 전에 작성했던 코드는 부끄러운 코드가 많을 것입니다. 처음에는 기능추가할 때는 부족한 부분이 나올 수 있습니다. 간간히 리팩토링할 때가 많습니다. 회사에서 리팩토링을 계속합니다. 리팩토링을 해둬야 소프트웨어의 수명이 늘어납니다. 기능을 개선하고 추가하기 쉽습니다. 리팩토링관점에서도 모노레포는 상당히 유용합니다. 브레이킹 체인지 감지도 쉽습니다. 대규모 리팩토링이 가능한 부분이 장점이자 단점입니다.

여러 팀이 모노레포에서 개발하고 있으면 공통 라이브러리의 API를 쉽게 업데이트를 진행할 수 있는 환경이 조성됩니다.

모노레포 업그레이드 할 때 중요한 것은 테스트입니다. 모노레포로 되어 있으면 다른 프레임워크로 가도 크게 상관없습니다. 모노레포 환경이면 다른 프레임워크 혹은 라이브러리를 설치하는 것도 전략입니다.

swagger를 API로 현재 기술부채이기는 하지만 codegen을 활용하기는 해야 하는데 수동으로 정의하고 있습니다. 레거시는 이렇고 최근 라이브러리의 혜택이 필요한 경우가 많습니다.

E2E 테스트도 원래 프론트엔드가 작성하기는 합니다. 최근 playwrigth를 추천합니다.

동시에 띄워야 하는 상황이 생기면 root에서 보통 자동으로 3000으로 뜹니다. 많이 띄워도 2 ~ 3개정도 띄웁니다. next는 자동으로 3001로 알아서 처리합니다. 물론 사전에 미리 port 번호를 설정하는 전략이 있습니다.

테스트코드를 잘 작성하거나 잘 설계하는데 활용을 잘 해봐야 할 것은 chatGPT입니다. 다시하고 프로픔트를 추가하도록 하면 됩니다.

Make test code with jest.

Import React from ‘react’
....

Make test code with jest.

- coverage 100%

Import React from ‘react’
....

이렇게 질문을 잘해보는 것도 좋은 전략입니다.

테스트코드 작성할 때 chatGPT가 알려준 테스트코드 편하게 사용하면 됩니다.

turbo보다 패키지매니저가 제공하는 mono repo가 갖을 수 있는 장점은 제어입니다. config 위치와 방식을 본인이 원하는 방식을 세세하게 설정할 수 있습니다. 그것 이외에 장점은 크게 없습니다. 또 익숙하다는 것도 이점입니다. pnp을 활용하면 유령의존성 문제가 해결됩니다.

pnpm이 장점이 많습니다. 이것도 하나의 장점입니다. 모노레포를 잘 지원합니다.

yarn barry의 팁입니다. next.js 많이 활용하면 standalone 설정이 있습니다. output 설정에 넣습니다. 번들사이즈에서 개발의존성 패키지들하고 런타임에서 필요한 것은 다릅니다. standalone을 활용하면 node_modules가 실행에 필요한 것만 넣습니다. 하지만 이 모드를 활용하면 node_module을 활용할 때만 가능합니다. 번들사이즈를 줄일 수 있습니다. pnp의 단점입니다.

yarn barry를 toss에서 활용할 때는 배포를 1분 정도에 처리합니다. 도커사이즈를 줄일 수 있습니다.

https://youtu.be/2IE68SDTYvI

이미지 리사이징한 전략입니다. 생각보다 쉽습니다.

https://medium.com/wantedjobs/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%A7%80%EA%B5%AC-%EC%98%A8%EB%82%9C%ED%99%94%EB%A5%BC-%EB%A7%89%EB%8A%94-%EB%B0%A9%EB%B2%95-feat-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B5%9C%EC%A0%81%ED%99%94-730da53ac843

next를 사용하면 웹서버 리소스를 많이 사용하기 때문에 필요합니다.
