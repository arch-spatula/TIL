# TIL

1일1커밋 무사고: 268일차

03:59

## todo

- [ ] SQL 강의
  - [x] Ch 2. Tables
  - [ ] Ch 3. Constraints
  - [ ] Ch 4. CRUD
  - [ ] Ch 5. Basic Queries
  - [ ] Ch 6. Structuring
  - [ ] Ch 7. Aggregations
  - [ ] Ch 8. Subqueries
  - [ ] Ch 9 . Normalization
  - [ ] Ch 10. Joins
  - [ ] Ch 11. Performance
- [ ] 플래시카드 프로젝트
- [ ] 코테
- [ ] 면접 질문
- [x] golang
- [x] 장애 보고서 형식 정리하기

## 장애보고서

장애 보고서는 버그 리포트와 다릅니다.

버그를 고치는 것은 비즈니스 결정일 수 있습니다. 버그가 만드는 문제가 마이너한데 해결하기 위해 투입해야 하는 노력이 메이저하면 보류를 결정하는 것도 초기 스타트업으로 내릴 수 있는 결정입니다.

장애는 해할 수 없으면 서비스 그리고 비즈니스에 치명적입니다. 수익이 차단됩니다. 유저 수가 감소할 수 있습니다. 심각하면 법적으로 처벌받을 수 있습니다.

장애 보고서를 작성할 때 중요한 것 중 하나는 신속성입니다. 장애 보고서는 장애가 발생, 해결 직후 혹은 해결 직후 다음날 오전끝나기 전(점심 시간)까지 작성해야 합니다. 물론 회사마다 다르지만 임원진은 보통 이렇게 마감을 설정할 것입니다.

장애 보고서는 원인이란 원인의 원인이 없는 원인입니다. 재귀함수로 생각하면 베이스 케이스를 찾은 경우입니다. 원인의 여러 스택 깊게(사실 높게지만) 찾아 들어가야 합니다.

장애 보고서의 독자는 개발자와 경영 임원 2 종류입니다.

개발자 독자는 개발자마다 중요한 컨텍스트가 다르다. 비슷한 장애가 또 있다면 해결한 과정을 찾아보기 위해 활용할 것입니다.

장애 보고서는 개발자의 시말서입니다. 임원은 이 장애가 비즈니스에 준 악영향을 알고 싶어합니다. 손해를 재무적 관점에서 파악하려는 것이 관점입니다. 회사마다 이 정보를 활용하는 방식은 다를 것입니다. 인사팀은 연봉 협상 시즌이 되면 임원에게 이런 자료를 받고 감봉, 동결의 근거로 활용할 것입니다. 감봉과 동결로 해결하기 어려우면 해고하고 손해배상 청구소송 절차도 밟습니다. 이런 과정에 근거자료입니다.

장애보고서는 4가지 기법이 중요합니다.

1. 질문에 대답하는 신속한 글쓰기
2. 원인과 이유를 찾는 분석적 글쓰기
3. 상사를 고려하는 비즈니스 관점의 글쓰기
4. 원하는 것을 얻는 정치적 글쓰기

### 질문에 대답하는 신속한 글쓰기

- 대화를 글로 옮기기
  - 대화 과정에 생각하는 시간은 비교적 짧습니다.
  - 가상의 동료를 가정하고 대화의 문답을 정리하는 방식으로 정리하면 수월할 것입니다.
    - 동료는 6하원칙으로 질문하도록 합니다.
- 주어, 목적어, 서술어로 작성

```md
# 서버 모듈 변경 문제로 사용자 결제 불가(22:00 ~ 23:00)

## 요약

| 항목      | 내용                                                                                             |
| --------- | ------------------------------------------------------------------------------------------------ |
| 장애 내용 | 사용자 결제 불가(22:00 ~ 23:00, 1시간)                                                           |
| 장애 영향 | 장애 중 결제 시도 100 -> 1시간 후 결제 비율 10%(평균50%)                                         |
| 장애 원인 | 서버 쪽 결제 모듈 변경 시 모듈 인터페이스의 함수를 수정했으나 프론트에서는 기존 함수로 에러 발생 |
| 조치 사항 | 서버 쪽의 바뀐 함수를 호출하도록 프론트 코드 수정                                                |
| 조치 결과 | 결제 기능 정상 작동                                                                              |
| 핵심 원인 | 서버와 프론트 팀간 커뮤니케이션 단절                                                             |
| 향후 대책 | 서버, 프론트 팀장이 소통 방법 협의하고 보고                                                      |
```

위는 예시입니다.

```md
# (장애 제목)

## 요약

| 항목      | 내용 | 상세                    |
| --------- | ---- | ----------------------- |
| 장애 내용 | ?    | [장애 내용](#장애-내용) |
| 장애 영향 | ?    | [장애 영향](#장애-영향) |
| 장애 원인 | ?    | [장애 원인](#장애-원인) |
| 조치 사항 | ?    | [조치 사항](#조치-사항) |
| 조치 결과 | ?    | [조치 결과](#조치-결과) |
| 핵심 원인 | ?    | [핵심 원인](#핵심-원인) |
| 향후 대책 | ?    | [향후 대책](#향후-대책) |

## 장애 내용

- ?

## 장애 영향

- ?

## 장애 원인

- ?

## 조치 사항

- ?

## 조치 결과

- ?

## 핵심 원인

- ?

## 향후 대책

- ?
```

위 포멧을 활용하도록 합니다. 상세 내용까지 모두 작성해야 하면 아래 따로 다루도록 합니다. 표는 요약입니다.

### 원인과 이유를 찾는 분석적 글쓰기

구체적인 방법론의 이름이 있습니다. 5 why라고 부릅니다. 왜를 5번 질문하고 매 질문마다 더 구체적인 답변이 나와야 합니다.

다른 접근은 원인의 원인을 찾을 수 없는 상황입니다. ~~원인의 원인이 없다고 설정할 기준은 저도 모르겠습니다.~~

질문의 프레임에 따라 찾고자 한 원인이 바뀔 수 있습니다.

5번에 무조건 매몰 될 필요는 없습니다. 생각보다 원인은 얕을 수 있고 반대로 엄청 깊을 수 있습니다. 5번인 이유는 저도 잘 모릅니다. 하지만 체스 선수는 5수까지 미리 볼 수 있다고 합니다. 이거랑 관련이 있는지 모르겠습니다.

다른 이유는 너무 구체적이면 신은 존재하는가? 등 존재론적 위기 유발하는 질문으로 들어갈 수 있기 때문입니다.

why를 설정하는 방향은 2가지로 보도록 합니다. 하나는 현상, 동작에 해당하는 원입니다. 다른 하나는 사람이 초래한 이유입니다.

### 상사를 고려하는 비즈니스 관점의 글쓰기

장애 보고서를 받는 사람들은 모든 것을 돈으로 생각합니다. 장애를 (영업) 손실로 환산할 수 없다면 장애를 일으킨 서비스가 왜 필요한가? 이런 관점으로 생각합니다.

임원에게 모든 직원의 역할과 업무와 성과는 모두 월급이나 상여금 같은 돈으로 연결되어 측정됩니다. 비즈니스도 동일합니다.

장애 보고서를 작성한다는 것은 비즈니스 관점으로 매출과 비용 관점으로 설명하는 것입니다.

- 개발자 관점: 장애로 인해 사용자가 1시간 동안 결제할 수 없음
- 임원진 관점: 장애로 인해 ~~억원의 매출 손실이 발생

임원의 관점을 맞추기 위해서는 매출의 기대값을 구해야 합니다. 하루 결제량을 1/24로 구하고 말 수 있습니다. 물론 근거가 부족합니다. 시간마다 요청량이 다릅니다. 대학생이 많이 이용하면 낮에 요청이 고르게 많을 것입니다. 직장인이 주로 사용하면 퇴근 후 결제 요청이 많을 것입니다. 결제 시간대별로 원래 발생했을 결제 요청량과 결제 금액을 기대값을 구할 때 활용할 수 있습니다.

이런 측면에서는 데이터 분석과 비슷합니다. 본래 엔지니어는 기술과 비즈니스를 연결해야 하는데 비즈니스 문제를 많은 기술적인 역량을 활용하는 것입니다. 데이터 분석은 비즈니스 문제를 비즈니스로 해결하는데 기술적인 역량을 가미하는 것입니다.

### 원하는 것을 얻는 정치적 글쓰기

정치적 글쓰기라는 측면은 이런 측면입니다.

> 데이터 센터 냉방기 미교체시 화재 발생 염려

개발자는 버그와 에러로 안전과민증을 훈련 받습니다. 하지만 개발자가 아닌 사람은 안전불감증을 갖고 있는 사람이 더 많습니다. 하지만 이렇게 해서 교체를 거절해도 결국 책임 개발자의 몫입니다.

> 냉방기 폭발 시 서비스 전면 중단

위처럼 말하는 것이 더 적절합니다. 실제 교체가 필요하면 그 심각성을 알려야 합니다. 하지만 딱히 필요없는데 심각하게 하면 양치기소년처럼 골로갈 수 있습니다.

---

장애는 같은 거 같지만 다른 즉 비슷한 장애가 다시 발생할 수 있습니다. 개발자들인 이렇게 단정하기 어려운 것을 임원이 쉽게 이해할 수 있게 단정해달라고 요구받습니다.

| 장애 재발 가능성 | 표현                         |
| ---------------- | ---------------------------- |
| 1%               | 절대 재발하지 않는다         |
| 10%              | 재발하지 않는다              |
| 20%              | 재발할지도 모른다            |
| 30%              | 재발할 수 있다               |
| 40%              | 재발한다고 볼 수도 있다      |
| 50%              | 재발할 수 있다               |
| 60%              | 재발하지 않는다고 볼 수 없다 |
| 70%              | 재발한다고 보여진다          |
| 80%              | 재발한다                     |
| 90%              | 재발할 것이 틀림없다         |
| 99%              | 받드시 재발한다              |

개발자는 실제 위 표에 대응되게 장애 가능성을 표현하기에는 독단적인(arbitrary)부분이 많습니다. 어림잡기입니다.

## [Tucker의 Go 언어 프로그래밍] Go언어가 온당 - OT & 4장 복습

https://www.youtube.com/watch?v=td1Y-zp5KsM

프로그래밍 입문강의입니다. 기초는 기초에서 배워야 좋습니다.

신기술이 많이 나옵니다. 기초는 기초 단계가 아니면 배우기 어렵습니다. 기초가 없으면 응용하기 어렵습니다. 응용을 먼저하고 기초를 나중에 배우자는 안일한 생각하기 쉽습니다. 나중에 힘듭니다.

복습입니다. 컴퓨터는 우아하지만 본질은 단순합니다. 컴퓨터는 기계입니다. 기술과 이론은 복잡해보이지만 시작은 단순합니다. 단순함을 이해하고 그 위해 응용을 쌓아올리면 수월합니다.

컴퓨터는 단순하는 것에 시작합니다. 이것을 보고 부트스트랩이라고 합니다. 돌로 청동을 만들고 청동으로 철을 만든 발전이 의외로 단순합니다. 기반에서 응용으로 발전하는 것을 보고 부트스트랩단계라고 합니다.

트렌지스터는 스위치에서 컴퓨터가 시작합니다. 트렌지스터로 논리소자를 만듭니다. 논리소자로 계산기를 만듭니다. 계산기를 만들어서 명령으로 프로그래밍이 가능한 계산기가 컴퓨터의 원류가 됩니다.

컴퓨터를 보면 지금은 내부구조가 복잡해보입니다. 사실은 필요와 편의를 위해 만들어진 것입니다. 시작했을 때의 단순한 모습을 이해하기 위해 노력하도록 합니다.

변수는 바뀌는 숫자를 의미합니다. 이것은 수학적 용어입니다. 프로그래밍적 의미는 다릅니다. 컴퓨터는 특정한 값을 저장하는 공간을 가리키는 이름입니다.

데이터는 숫자, 문자, 소리, 이미지 등 다양합니다. 컴퓨터는 결국에 아는 것은 0과 1입니다. 이 데이터를 0과 1로 바꿔야 합니다. 인간이 보기에는 데이터 분류된 것이 자연스럽습니다.

데이터는 메모리 저장하고 접근할 수 있습니다. 변수는 이 메모리 공간을 가리킵니다. 이 공간을 주소로 그대로 보여주지 말고 이름으로 보여줘서 사람이 이해하기 쉽게하도록 합니다.

변수는 중요합니다. 프로그래밍은 결국에는 데이터(변수)를 조작하는 일입니다.

이미지 영상을 처리할 때 컴퓨터는 비디오 메모리가 있고 이것을 처리하는 것입니다. 이것을 조작하는 것은 비디오 메모리를 조작하는 것입니다.

조작하는 기본은 변수를 통해서 시작합니다. 데이터는 메모리 저장되어 있고 데이터를 접근할 때는 변수로 접근하기 때문입니다.

```go
var a int = 10
```

코드에서 선언이 필요한 이유입니다. 데이터를 조작하고 싶으면 먼저 데이터를 저장해야 합니다.

변수 선언 없는 언어도 신기하게 존재합니다.

변수명은 한글을 사용할 수 있는데 영문이 편할 것입니다.

언더스코어 특수문자를 앞에 붙일 수 있는데 용도는 나중에 알려주겠습니다.

자료형은 숫자(정수, 실수), 문자 등이 있는데 타입은 변수 선언할 때 메모리 사이즈 정의가 같이 포함됩니다.

프로그래밍에서 =은 할당 연산자입니다. 그리고 비교연산자도 ==입니다. 엄밀비교 약한비교는 없습니다. 좌변은 메모리 공간이고 우변은 데이터입니다.

대입연산으로 값을 재할당하는 것은 그냥 하면 됩니다.

변수는 4가지 속성이 있습니다. 이름, 값, 주소, 타입입니다. 프로그래머가 제어할 때는 이름이 중요합니다. 컴퓨터에게 이름은 의미가 없습니다.

컴퓨터는 메모리 주소는 16진수로 표현합니다. 0 ~ 9와 a ~ f까지 사용합니다. 메모리 주소를 접근해서 해당하는 주소에 데이터를 제어할 수 있게 됩니다.

변수에는 메모리 주소를 접근하는데 정확히 메모리 시작 주소입니다. 메모리 순서대로 확보합니다.

타입은 확보해야 할 공간을 정합니다.

시작주소와 공간 크기를 알면 읽을 대상을 알 수 있습니다.

go는 강타입언어입니다.

숫자타입에 앞에 u가 붙으면 양의 정수를 의미하는데 부호가 사라졌다는 의미입니다. 타입접미어로 붙은 숫자는 비트를 나타냅니다. 바이트 단위 아닙니다. 하지만 8, 16, 32, 64는 바이트 단위로 키웁니다.

소수점이 존재하는 실수형은 32, 64가 있습니다.

byte는 uint8의 별칭입니다.

rune은 int32랑 같은 타입입니다. utf-8을 문자인코딩에 사용하는데 문자 1개가 1 ~ 3바이트의 가변길입니다. rune은 고정시키기 위해 4바이트로 문자 1개를 저장하기 위한 별칭 타입입니다.

접미어로 뒤에 숫자가 없으면 컴퓨터 비트를 기준으로 정합니다. 32비트 컴퓨터, 64비트 컴퓨터에 따라 다릅니다. 이 32, 64는 레지스터 사이즈라고 합니다. CPU가 연산하기 위해 연산자를 보관하는 공간입니다. 한번 연산에 올라가는 크기를 기준으로 잡습니다.

부울타입이 있습니다. 부울은 조지 부울이 만든 논리대수 부울대수의 창시자의 이름을 따온 것입니다.

문자열은 문자들이 모여있는 것이 문자열입니다. 문자 개별로 구분하는 언어도 있습니다.

배열은 같은 타입 여러개가 모여있는 것입니다.

슬라이스는 동적 배열입니다. go가 제공하고 중요한 자료형입니다.

구조체는 여러개의 필드를 모읍니다. 나이, 이름, 학력 등 사람을 모으고 정리한 것입니다.

포인터는 다른 변수를 가리키는 변수입니다. 특정 변수를 가리키도록 만들 수 있습니다.

함수타입은 함수를 가리킵니다.

맵, 인터페이스, 채널도 다룹니다.

정수는 0, 실수는 0.0, 부울은 false, 문자열은 빈 문자열(""), 이외 모두 nil로 메모리 주소가 없다고 표현합니다.

c언어는 참은 1 거짓은 0으로 표현합니다. 하지만 go는 구분하고 숫자로 대입하지 않습니다. 대입을 지원하는 언어도 은근히 많습니다. c언어가 권위와 유산입니다.

complex64, complex128도 존재합니다. 이것은 복소수를 표현할 수 있습니다. 진수와 가수 실수 2개를 합친 개념이라고 볼 수 있습니다. 수학 분야 프로그래밍에서 활용하고 일반적인 웹 어플리케이션 분야는 거의 활용할 경우는 별로 없습니다.

왜 메모리 타입을 다양하게 지원하는가? 메모리 사이즈를 아끼기 위해 사용할 수 있습니다.

부모없는 정수로 1, 2, 4 바이트(255, 65535, 42억)는 모두 암기하는게 편합니다.

8바이트를 초과하려면 국가회계 혹은 천문학 분야일 가능성이 큽니다.

실수표현은 float32의 경우 부호(1비트), 지수부(8비트), 소수부(23비트)입니다.

지수표현과 일반표현이 있습니다. 지수표현은 실수를 표현하기 수월합니다. 10의 몇승으로 제곱으로 표현합니다. 지수부는 10의 제곱수를 표현할 수 있습니다.

32는 7자리, 64는 15자리를 소수의 자리수를 잘 암기하는 것이 중요합니다.

## [Tucker의 Go 언어 프로그래밍] 5장 fmt패키지를 이용한 표준입출력

fmt 패키지를 다룹니다. 이 패키지는 계속 다룰 것이기 때문에 먼저 다룰 것입니다. 그리고 입출력 중 표준 입출력을 이해해볼 것입니다.

다른 언어 전에 표준입출력을 이해하기 위한 시간입니다.

표준 입출력입니다. 프로그램이 있습니다. 프로그램은 사용자와 입출력으로 대화합니다. 사용자가 키보드, 마우스로 입력하면 피드백으로 화면과 사운드로 돌려줍니다. 이것은 일반적인 게임에서 자줄 볼 수 있을 것입니다. 또 게임이 온라인이라면 출력이 네트워크로 나가고 돌아올 것입니다.

하지만 우리는 표준이 되는 입출력을 다룹니다. 표준입출력을 이해하기 위해서는 초기 컴퓨터를 이해해야 합니다. 컴퓨터는 처음에는 천공카드 구멍으로 처리했습니다. 천공카드 구멍을 활용해서 코드를 작성했습니다. 히든 피겨스는 나사의 프로그래머들입니다. 옛날에 프로그래밍은 여성이 많이 했습니다. 초기 프로그래머는 여성이 꽤있었습니다.

구멍을 잘못 뚤었으면 디버깅하기 어려웠습니다.

입력은 천공카드의 구멍이 빛이 통과하고 말고로 제어했습니다. 초기 컴퓨터는 이런 천공카드가 입력장치가 표준이었고 출력도 하나였습니다. 표준입력장치가 카드로 입력하고 CPU가 처리하고 프린터가 출력했습니다. 천공카드가 표준입력이고 프린터가 표준출력입니다.

시간이 지나 지금은 키보드가 표준입력에 해당합니다. 출력도 모니터가 표준출력이 됩니다. 입력과 출력 기구는 바뀌지만 입출력과 출력의 과정에 해당하는 통로는 계속 같습니다.

리눅스를 사용하면 입출력을 라다이렉팅으로 모니터에 나와야 할 것을 프린터로 가게 만들 수 있습니다.

0과 1의 흐름이 컴퓨터에 입력되는데 이 흐름을 보고 비트스트림이라고 합니다. 스트림을 직역하면 시냇물이라고 합니다. 즉 물이 흐르는 것처럼 데이터가 흐른다는 의미로 이해해도 됩니다. 그냥 스트림이라고 해도 괜찮은게 과거에는 비트 스트림이지만 지금은 바이트 단위로 하기 때문에 바이트 스트림이라고 부르기도 합니다.

표준 출력함수입니다. fmt 패키지로 접근할 수 있습니다. 3개가 있습니다. Print(), Println(), Printf()입니다. Print는 단순 출력합니다. Println은 출력 후 개행합니다. Printf는 서식에 맞춰서 출력한다는 의미입니다.

키보드는 타자기에서 따온 것입니다. 개행은 타자기로 종소리를 내면서 밀어넣는 동작을 봤을 것입니다. 이 동작을 보고 개행이라고 합니다.

```go
package main

import "fmt"

func main() {
	var a int = 10
	var b int = 20
	var f float64 = 32799438743.8297
	fmt.Print("a:", a, "b:", b, "f:", f)
	fmt.Println("a:", a, "b:", b, "f:", f)
	fmt.Printf("a: %d b: %d f: %f \n", a, b, f)
}

// a:10b:20f:3.27994387438297e+10a: 10 b: 20 f: 3.27994387438297e+10
// a: 10 b: 20 f: 32799438743.829700
```

이렇게 됩니다.

Print는 개행이 포함되어 있지 않습니다. 또 사이에 빈칸도 없습니다. 여기도 실수를 지수로 표현합니다.

Println은 개행해주고 입력한 인자마다 빈칸을 사이에 넣어줍니다. 지수표현합니다.

Printf는 포매팅을 해줍니다. d는 정수를 표현합니다. 또 f는 소수로 표현해줍니다. 지수 표현을 하지 않습니다. 여기서 개행은 같이 작성했습니다.

d는 decimal로 10진수를 의미합니다. 영문으로 자릿수를 의미하기도 합니다.

서식은 %으로 표현하고 순서대로 들어갑니다.

%v는 기본 형태로 출력합니다. %T은 타입을 출력합니다. %t은 부울리안을 표현합니다. %b는 이진수로 출력합니다. %e 지수로 출력합니다. %f는 실수로 출력합니다.

%g는 출력해야 하는 길이가 크면 지수로 출력하고 작으면 실수로 출력합니다. 기준은 6자리입니다.

%q는 특수문자 동작을 제거합니다.

%(숫자)(형식)을 볼 수 있습니다. 여기서 숫자는 칸수입니다.

%0(숫자)(형식)이렇게 하면 빈공간을 0으로 채우라는 뜻입니다.

%-(숫자)(형식)은 왼쪽으로 정렬하도록 합니다. 여기서 %-0(숫자)(형식)에서 0은 의미 없습니다.

암기 중요하지 않고 혼란스럽지 않은 것이 중요합니다.

참고로 자릿수를 넘어가면 넘어가는데로 출력합니다.

%f는 6자리까지 표현합니다.

%g는 6자리 넘으면 지수로 표현합니다.

실수 타입 %v로 출력하면 기본은 %g로 동작합니다.

Println은 타입별로 %v로 모두 처리합니다. 각자의 타입별로 동작하게 합니다.

이스케이프 캐릭터는 \입니다.

표준출력은 fmt 패키지에서 제공합니다. 기본적으로 터미널입니다. 프로그래밍 외적으로 바꿀 수 있습니다.

fmt 패키지로 표준입력도 다룰 수 있습니다. Scan, Scanln, Scanf입니다. 표준입력, 표준 한줄, 표준 형식입니다. 하지만 Scanln을 그나마 자주 사용합니다.

```go
func fmt.Scanln(a ...any) (n int, err error)
```

Scanln 메서드 위에 마우스를 올리고 정보를 확인할 수 있습니다. n이 정수형이고 error는 error 값입니다.

```go
package main

import "fmt"

func main() {
	var a int
	var b int

	n, err := fmt.Scanln(&a, &b)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(a, b, n)
	}
}
```

a, b는 0이 됩니다. 기본값이 할당됩니다. 중요한 것은 &입니다. 이 &이 중요합니다. a, b를 입력받는데 변수 앞에 &을 넣으면 그 변수의 메모리 주소값을 나타냅니다.

사실 언어마다 다르지만 go는 기본적으로 인자로 대입하게 되면 모든 변수(지금은 a, b)는 Rvalue 즉 할당 연산의 오른쪽의 값으로 대입하게 됩니다. 그렇다면 &을 제거하면 모두 자동으로 0이 대입될 것입니다.

&a, &b로 대입하게 되면 주소를 대입한 것입니다. 우리가 이 주소에 키보드로 입력한 값을 메모리에 작성하게 한 것입니다.

입력 버퍼입니다. 표준입력과 표준출력이 있고 이 사이는 데이터의 흐름 비트 스트림으로 들어가고 나옵니다. 흐름에 따라 문자열, 파일, 프린트가 될 수 있습니다.

비트스트림이 들어오면 잠시 보관하는데 이 보관하는 장소를 보고 버퍼라고 합니다. 지금 맥락에서는 입력버퍼라고 합니다. 버퍼는 메모리 공간을 확보하고 값을 작성할 수 있는 공간을 보고 버퍼라고 합니다. 임시저장소라고 할 수 있습니다.

예를 들어 Scanln에 hello 4라고 키보드 입력을 합니다.

h는 숫자가 아니기 때문에 첫번째 인자는 실패해서 에러가 발생합니다. 그 뒤부터 버퍼를 읽지 않습니다. 문제는 버퍼에 ello가 남아있습니다.

실패하면 입력버퍼를 비워야 합니다. 입력 버퍼를 비우는 작업을 시도해보겠습니다.

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	stdin := bufio.NewReader(os.Stdin) // Stdin을 의미함
	var a int
	var b int

	n, err := fmt.Scanln(&a, &b)
	if err != nil { // err에 메모리 주소가 할당 된 경우 아래를 실행
		fmt.Println(err)
		stdin.ReadString('\n') // 개행문자까지 버퍼에서 읽기 -> 버퍼를 읽는 행위로 비움
	} else {
		fmt.Println(a, b, n)
	}

	n, err = fmt.Scanln(&a, &b)
	if err != nil { // err에 메모리 주소가 할당 된 경우 아래를 실행
		fmt.Println(err)
		stdin.ReadString('\n') // 개행문자까지 버퍼에서 읽기 -> 버퍼를 읽는 행위로 비움
	} else {
		fmt.Println(a, b, n)
	}
}
```

go는 변수를 선언하면 반드시 사용해야 합니다.

앞으로 키보 입력을 받으면 버퍼를 비우는 행동을 해야 한다는 것을 기억하기 바랍니다.

## Ch 2. Tables

https://www.youtube.com/watch?v=KBDSJU3cGkc&t=1330s

컬럼과 필드를 혼용해서 표현하는 경우가 많습니다. SQL에서는 컬럼이 더 정확한 표현이고 필드는 프로그래밍 언어차원에서 의미합니다.

```sql
CREATE TABLE people(
    id INTEGER,
    handle TEXT,
    name TEXT,
    age INTEGER,
    balance INTEGER,
    is_admin BOOLEAN
);
```

엔티티당 테이블이 있을 것입니다. 테이블이 여러개일 것입니다.

```sql
CREATE TABLE transactions(
  id INTEGER,
  recipient_id INTEGER,
  sender_id INTEGER,
  note TEXT,
  amount INTEGER
);
```

프로덕션 배포 혹은 토이 프로젝트 진행할 때는 간단하지만 테이블 문을 변경하는 것은 실제로는 어렵습니다.

```sql
ALTER TABLE employees
RENAME TO contractors;
```

테이블 이름을 수정하는 방법입니다.

```sql
ALTER TABLE contractors
RENAME COLUMN salary TO invoice;
```

컬럼 이름을 수정하는 방법입니다.

```sql
ALTER TABLE contractors
ADD COLUMN job_title TEXT;
```

컬럼을 추가하는 방법입니다.

```sql
ALTER TABLE contractors
DROP COLUMN is_manager;
```

역으로 삭제하는 방법입니다.

아래부분이 무엇을 하는지 설명합니다.

참고로 user라고 테이블을 명명하는 것은 일반적입니다.

```sql
ALTER TABLE people RENAME TO users;

ALTER TABLE users RENAME COLUMN handle TO username;

ALTER TABLE users ADD COLUMN password TEXT;
```

이런식으로 작성해서 테이블의 이름, 컬럼을 수정하고 password를 추가했습니다.

handle은 sns 성격이 강할 때 명명합니다. 그런 경우가 아니면 평소에 username으로 명명합니다.

---

좋은 데이터베이스 마이그레이션은 유닛테스트와 비슷합니다.

테이블에 컬럼을 추가하는 행위를 보고 마이그레이션이라고 합니다. 일반적으로 컬럼을 추가하는 행위는 비교적 안전합니다. 현재 코드는 무시할 가능성이 높습니다. 하지만 반대로 컬럼을 삭제하는 활동은 위험합니다.

추가(Add), 삭제(Delete), 갱신(Update) 3가지 경우가 있습니다.

Add 마이그레이션 방법입니다. 추가하고 코드를 수정하면 됩니다.

Delete 마이그레이션 방법입니다. 먼저 코드를 수정합니다. 코드가 수정되면 데이터 베이스에서 삭제하면 됩니다.

제일 어려운 것은 Update입니다. 테이블 컬럼의 이름을 수정하는 것은 상당히 어렵습니다. 그래서 이런 일이 없도록 처음부터 조심하도록 합니다. 진짜로 안전한 방법이 없습니다. 유일한 선택지는 데이터베이스 테이블이름과 코드베이스를 동시에 갱신해야 합니다. 서버가 장애시간이 반드시 있을 것입니다. 대응하는 방법은 정검시간을 실제로 확보합니다. 단순하지만 유저가 싫어합니다. 다른 방법은 동시 배포입니다. 현재 유저가 별로 없고 다운타임이 조금 있어도 괜찮으면 선택지 중 하나입니다. 마지막으로 가장 로버스트한 방법은 복사입니다. 기존 데이터를 복사하고 배포하는 전략입니다. 마이그레이션 스크립트가 복잡합니다. 에일리어싱이 더 좋은 방법입니다. 이것은 데이터베이스와 사용가능 여부 상황에 따라 다릅니다. 데이터 베이스에 테이블에 두번째이름을 부여하는 방법입니다. 이렇게 하고 완료되면 기존 이름을 Drop합니다. 하지만 처음부터 Update 안하도록 조심합니다.

Up 마이그레이션은 초신 마이그레이션입니다. 앞으로 이동합니다. Down 마이그레이션은 롤백입니다. 긴급상황에 사용하게 됩니다. 대부분 회사는 Down 마이그레이션이 없습니다. Up, Down은 시간과 관련된 문제입니다.

개발 일반적으로 데이터와 가까워질수록 작업을 조심스럽게 처리해야 합니다. 버그는 수정이 비교적 쉽지만 데이터는 수정이 어럽습니다.

좋은 마이그레이션은 이미 존재하는 스키마가 의존하는지 파악하고 처리합니다. 마이그레이션은 데이터베이스에 가한 작은 변화입니다. 마이그레이션을 작성하면 되돌리기 쉽습니다.

롤백하는 스키마를 되돌리는 것만으로 고쳐진 것은 아닙니다. 하지만 되돌린 상태에서 고치기가 더 쉽습니다.

---

- NULL - Null값
- INTEGER - 8 byte 혹은 정수입니다.
- REAL - 실수형입니다.
- TEXT - 문자열입니다.
- BLOB - 이미지, 오디오 같은 멀티미디어에 해당하는 (Binary large object)[https://en.wikipedia.org/wiki/Binary_large_object]입니다.
- 0은 false, 1은 true입니다. false로 작성해도 0으로 기록되고 true로 작성해도 1로 기록됩니다.
- varchar는 문자열 길이를 알면 활용합니다. 문자열 길이를 알면 성능개선에 활용할 수 있습니다. 비밀번호 해쉬, 이메일은 길이가 비교적 한정적입니다.
  - varchar은 캐릭터 가변을 의미합니다.
