# TIL

1일1커밋 무사고: 267일차

05:41

## todo

- [x] 면접 예상 질문
- [x] golang
- [ ] 블로그에 이번주 작업 내용을 정리
  - 기업과 과제 내용의 자세한 부분은 숨기기
- [ ] 주간회고
  - 블로그에 정리한 내용을 바탕으로 다시 생각하기

## 면접 예상 질문

### 자기소개?

엔지니어링 관점으로 좋은 제품을 만들고자 도전하는 프론트엔드 엔지니어 김상현입니다. 과거 UX/UI 디자이너로 근무했습니다. 지금은 UX 지식을 프론트엔드 엔지니어링의 기술적인 지식을 합쳐 좋은 경험을 제공하는 제품을 만들고자합니다.

### 지원동기?

지원 공고를 확인했을 때 많은 법무법인 같은 기업은 jquery와 java spring으로 만드는 경우가 많은데 ~~비밀~~은 Next.js, GraphQL을 활용하는 것을 봤습니다. 좋은 개발 문화를 갖고 있을 것 같아서 지원했습니다.

#### 개발문화가 생각과 다르게 안 좋으면 퇴사할 것인가요?

공고랑 다르게 jquery와 java spring이고 개선이 아니라 강경하게 유지하고자 하면 재직하면서 이직을 준비할 것입니다.

### webp의 동작원리는?

https://www.youtube.com/shorts/U_QNznf2FZA

https://namu.wiki/w/WebP

https://www.youtube.com/shorts/9ZfCZroZwD4

클라이언트 브라우저와 네트워크에서 webp의 동작방식입니다. 클라이언트는 서버에게 이미지를 요청하면 서버는 이미지를 png, jpg, gif 그대로 주지 않습니다. 먼저 webp로 클라이언트에게 전달합니다. 구글 크롬의 경우 webp 호환성이 좋은 편입니다.

네트워크에서 webp는 트래픽 부하가 낮은 편입니다. 원래 png, gif, jpg를 압축해서 만든 이미지입니다. 구글이 많은 트래픽을 점유하고 있는데 이 트레픽 부하를 낮추면 구글도 비용측면에서 얻을 것이 많기 때문에 제공합니다.

#### webp의 압축 과정?

이미지 압축은 손실압축 무손실압축 2가지가 있습니다. 정확히 webp의 압축과정은 모릅니다.

하지만 일반적인 이미지 압축과정은 알고 있습니다. 픽셀 1개당 컬러 1개는 1바이트이고 rgb 3바이트가 필요합니다. 압축할 때 모두 숫자 그래도 저장하면 저장공간이 많이 필요합니다. 여기서 데이터는 중복이 많이 발생합니다. 예를 들어 흰색 배경은 255, 255, 255가 연속되면 연속된 횟수와 색을 기록하는 것으로 저장 효율을 높일 수 있습니다. 다른 방식은 유사한 색들의 범위를 지정하고 가우스처리해서 유사한 색들을 많이 만드는 전략도 있습니다. 이렇게 되면 연속하는 횟수가 높아집니다.

DCT로 추출하는 방법도 있습니다. 이전에는 연속된 색상의 횟수라고 했는데 이번에는 이미지 조각을 패턴으로 저장합니다. 이미지마다 필요한 패턴의 수량을 저장하는 방식입니다. 이미지 패턴별로 숫자가 있는데 이 숫자에서 연속되는 숫자를 압축하면 됩니다.

쿼타이제이션 테이블을 활용해서 낮은 곳은 더 낮게 높은 곳은 최대한 무손실에 가깝게 계산해서 화질을 높일 수 있습니다.

<!--
예측 및 차분 인코딩:
WebP의 무손실 압축은 주로 예측 및 차분 인코딩을 사용하여 이미지 데이터를 줄입니다. 각 픽셀은 주변 픽셀들의 값으로 예측되며, 이 예측 값과 원본 픽셀 값의 차이(잔차)를 저장합니다.

Entropy Coding:
예측된 값과 잔차 데이터는 효율적인 압축을 위해 엔트로피 인코딩 방식을 사용하여 압축됩니다. 엔트로피 인코딩은 데이터의 빈도 및 패턴을 분석하여 더 적은 비트로 표현할 수 있는 방식으로 변환합니다.

Huffman Coding:
WebP의 무손실 압축에서는 Huffman 코딩이나 Golomb 코딩과 같은 압축 알고리즘을 사용하여 데이터를 인코딩합니다. 이 알고리즘들은 데이터의 빈도에 따라 더 짧은 비트 패턴을 할당하여 압축률을 향상시킵니다.

색상 테이블 사용:
이미지의 색상 데이터도 효율적으로 저장하기 위해 색상 테이블을 사용합니다. 색상 테이블은 이미지 내의 색상 값들을 인덱스로 매핑하여 저장하는 방식으로, 데이터의 중복을 줄여 압축률을 높입니다.

매타데이터 포함:
WebP 이미지에는 무손실 압축된 데이터와 함께 필요한 메타데이터(헤더 정보, 컬러 프로파일 등)도 포함됩니다.

압축된 WebP 이미지 생성:
위 단계들을 통해 압축된 데이터와 메타데이터를 조합하여 WebP 이미지를 생성합니다. 생성된 이미지는 원본 이미지의 데이터를 줄이면서도 화질을 완전히 보존합니다. -->

### 좋은 코드의 기준?

최대한 단순하게 엔지니어링 관점만 보면 복잡성이 낮은 코드가 좋은 코드입니다.

프론트엔드 엔지니어 관점에서는 대부분의 경우 가변성이 높은 코드가 좋은 코드가 됩니다. 프론트엔드는 성능 최적화보단 프로토타이핑을 많이하기 때문에 높은 가변성을 유지하는 부분이 중요한 것 같습니다. 높은 가변성을 유지하기 위해 모듈화, 추상화를 잘해서 관심사를 잘 분리하고 테스트코드를 작성하고 리팩토링을 잘 할 수 있는 부분이 중요한 것 같습니다. 장기적으로 리팩토링해서 관심사를 잘 분리하고 팀원이 익숙한 컨벤션과 정리하기 좋은 원칙들을 활용해서 작성한 코드가 좋은 코드라고 봅니다.

프로그래밍 일반적으로 조금 특수한 성능 최적화를 해야 하면 코드 결합도가 높아지는 경우가 많습니다. 눈으로 보이고 유저의 경험을 저하고 있으면 바로 대응합니다. 하지만 의심하고 측정을 먼저하도록 해야 할 것 같습니다.

### vite이란 무엇인가?

[Vite in 100 Seconds](https://www.youtube.com/watch?v=KCrXgy8qtjM)

vite은 자바스크립트 빌드툴입니다. 일반적인 번들러와 다르게 번들링의 확장이라고 볼 수 있습니다. 내부적으로 번들러는 rollup을 사용하고 그 위에 다양한 확장기능을 제공하고 있습니다. 확장기능이라고 하면 code splitting 설정을 쉽게 해주거가 기본적으로 빌드에 필요한 최적화를 추상화 해줍니다. 일반 번들러를 활용하면 라이브러리 호환 문제, 중복 라이브러리 의존성 문제, 트리쉐이킹 등 같이 수동으로 설정해줘야 하는 부분이 많습니다.

#### 빌드툴과 번들러의 차이는 무엇인가?

[Module Bundlers Explained... Webpack, Rollup, Parcel, and Snowpack](https://www.youtube.com/watch?v=5IG4UmULyoA)

먼저 번들러라는 것은 자바스크립트를 몇개의 파일로 묶어내는 도구입니다. 프로그래머가 파일 혹은 모듈단위로 프로그램을 많이 작성하는데 순수 자바스크립트 만으로 서로 연결하는데는 한계가 많습니다. 먼저 프로그래밍 관점입니다. 여러 모듈 사이 같은 변수명을 사용하면 충돌이 발생할 수 있습니다. 사용자 관점입니다. 라이브러의 일부만 사용하는데 라이브러리 전체가 사용자에게 전달되는 문제도 있습니다. 처음 사이트를 접근할 때 라이브러리 전체를 다운 받는 비효율도 있습니다. 또 라우팅을 안할지도 모르는데 다른 페이지까지 모두 전달합니다.

번들러가 해주는 역할 중 하나는 사용하지 않는 라이브러리를 제거해줍니다. 코드 주석과 공백제거를 하는 소스코드 최소화도 대신 처리해서 용량을 압축합니다. 모듈과 모듈간 관계를 쉽게 정리하고 변수명 충돌도 방지해줍니다. 리소스를 접근하고자 할 때 코드를 쪼개고 필요한 시점에 맞게 제공할 수 있게 해줍니다.

빌드 툴은 이것보다 더 기능이 확장되어 있다고 볼 수 있습니다. 소스코드 컴파일, 의존성 관리, 번들링, 환경 설정 등 out of the box로 대신해주는 기능이 추상화되어 있습니다.

프레임워크와 라이브러리 관점을 활용하면 번들러는 라이브러리와 유사하게 직접 설정해줘야 하는 부분이 많고 빌드 툴은 프레임워크처럼 대신 많은 부분을 처리해줍니다.

일반적인 소프트웨어 엔지니어링 관점에서 차이는 있지만 프론트엔드 엔지니어링 분야에서는 차이가 모호합니다.

##### 일반적인 소프트웨어 엔지니어링에서 모듈 번들러와 빌드 툴의 차이는?

모듈 번들러는 프로그램이 작성되어 있는 모듈들을 합치는 도구입니다, 빌드 툴은 의존성 관리, 테스트, 패키징, 환경관리를 대신 처리해줍니다.

#### code splitting이란?

단어를 쪼개서 이해해보면 소스코드를 분할하는 것을 의미합니다. 소스코드는 프로그래머가 직접 작성한 코드는 아닙니다. 번들러 혹은 빌드 툴이 트렌스파일을 해준 코드입니다. 이 소스코드를 클라이언트에게 분할해서 전달합니다. 분할 기준은 page 단위가 되는 경우가 많습니다. page를 접근할 때마다 해당하는 소스코드의 부분을 제공합니다.

### request waterfall이란?

리액트가 컴포넌트를 랜더링할 때 트리구조로 랜더링을 합니다. 로그인 같은 의존성 요청 로직과 랜더 트리에서 순차적으로 mount하면서 뒤 늦게 따로 요청을 보내면서 발생합니다.

사용자 경험에 문제가 되는 경우는 실제 총 대기시간이 길어진다는 점입니다. 일부 병렬로 실행할 수 있는 요청은 병렬로 처리하고 클라이언트에게 한번에 보여주는 것이 좋습니다.

### emotion과 style-component의 차이점?

emotion은 SSR설정이 더 쉽고 아주 약간 성능이 더 좋습니다.

style-component는 더 오래 많이 사용했습니다.

큰 차이가 없습니다. 모두 CSS-in-JS로 같습니다.

### API란 무엇인가?

API는 개발자가 일상에서 2가지를 같이 혼용해서 이야기합니다. 하나는 프로그래밍 인터페이스와 다른 하나는 프로토콜 인터페이스입니다. 본질적으로 같이 프로그래밍 인터페이스라고 봐도 괜찮습니다. 먼저 A와 I는 둘이 같습니다. 먼저 A는 둘다 응용을 의미합니다. 하드웨어를 직접 제어하는 것이 아닌 응용 소프트웨어 계층에서 프로그래밍 언어를 통해 제어합니다. 다음 I는 인터페이스라고 하는데 이 인터페이스의 본질은 제어할 수 있는 대상이라고 볼 수 있습니다. UI는 사용자가 화면을 보고 클릭, 입력과 같은 제어행위를 의미하고 자동차 디자인에서 핸들, 깜박이, 가속과 감속 패달처럼 제어할 수 있는 것을 보고 인터페이스라고 부릅니다. 프로그래밍 인터페이스는 이런 제어를 프로그래밍을 통해서 하는 것입니다.

이제 API의 P가 프로그래밍을 의미하는 경우입니다. 제어를 할 때 라이브러리, 프레임워크, 언어 등에서 제어하기 위한 방식들입니다. P가 프로토콜을 의미하는 경우 통신 프로토콜을 수단으로 서비스를 제어하는 것을 의합니다. 프론트엔드가 SPA와 자바스크립트의 특수한 객체를 다룰 때는 프로그래밍 인터페이스를 의미하고 프론트엔드와 백엔드가 협업할 때는 프로토콜 인터페이스를 의미합니다.

#### 서버 상태란 무엇인가?

서버 상태란 data fetching과 caching 상태를 의미합니다. data fetching과 관련된 상태들이 있습니다. 요청이 처리 중인지 실패했는지 성공했는지 관련된 상태를 의미합니다. data fetching에 대해서 제공하는 플레그는 라이브러리마다 다릅니다. 이미 캐싱이 되어 있으면 loading과 feting을 구분하는 경우도 있습니다. fetching은 캐시가 이미 있는데도 갱신을 위해 요청하고 loading은 캐시가 없는 상태에서 채우기 위해 요청을 보낼 때 보여주는 플래그입니다.

캐시는 서버로 부터 데이터를 가져오면 이 데이터를 먼저 사용자에게 보여주는 데이터입니다. 일정 시간과 조건으로 관리합니다. 의도적으로 너무 잦은 갱신을 막거나 반대로 적절한 시점에 재요청해서 갱신시킬 데이터입니다.

프론트엔드 엔지니어링할 때 최근 추세는 이런 서버 상태를 관리하는 라이브러리와 가벼운 전역상태만 관리하는 라이브러리와 조합해서 사용하는 경향이 많습니다. 예를 들면 React-Query와 Zustand 조합으로 상태관리하는 경우를 많이 볼 수 있습니다.

### JWT이란?

JSON 형식의 웹(Web) 토큰(Token)을 의미합니다. 형식은 JSON이고 정보를 구문 분석으로 만든 토큰을 웹에 사용하기 위한 데이터입니다.

refresh와 access 2개의 토큰을 활용하는 전략이 일반적입니다. refresh는 cookie에 담고 access는 메모리 혹은 웹 스토리지에 저장합니다. access 토큰의 만료는 짧고 refresh의 만료는 길게 둡니다. 토큰이 없거나 갱신이 필요하면 서버에 새로운 access token을 refresh token을 통해 받습니다. 서버와 클라이언트 도메인이 같으면 쿠키를 자동으로 보내는데 서버는 클라이언트의 쿠키를 확인하고 갱신할 access token 줄지말지 확인합니다.

### next.js는 무엇인가?

next.js는 리액트를 사용하는 메타프레임워크입니다. 메타프레임워크는 프론트엔드에서는 랜더링 제어, API, 라우팅이 공통점인 것 같습니다.

#### next.js는 왜 사용하는가?

next.js를 사용할 이유는 다양합니다. 먼저 프레임워크이기 때문에 프로그래밍을 할 때 정리하는 방식이 정해져있습니다. 어떻게 구조화할지 잘 짜여진 프로그램을 작성하기 수월합니다. 다른 이유는 다양한 편의 기능이 있습니다. Next-font, Next-image, next-link처럼 각자 놓고 보면 다루기는 쉽지만 내부적으로 제공하는 추상화가 상당히 편리합니다. API도 DB 통신처럼 클라이언트에서 요청하지 않고 서버에서 요청이 필요한 경우에 편리하게 구현할 수 있습니다. token, cookie처럼 도메인이 같을 때 사용할 수 있는 서버에 필요한 인증 로직도 구현할 수 있습니다. 프론트엔드 엔지니어에게 앱서버를 제어할 수 있게 된 장점이 있습니다.

### Error Boundary에 대해서 설명해주세요

Error boundary는 리액트를 활용해서 프로그래밍할 때 컴포넌트 내부에서 에러가 발생하면 라이프사이클 메서드가 state를 갱신해서 fallback을 랜더하도록 하는 방식으로 동작합니다. 컴포넌트에서 throw하면 리액트 클래스형 컴포넌트에서 error에 isError 플래그를 true로 갱신하는 라이프 사이클 메서드를 통해 구현합니다.

라이브러리를 설치할 수 있고 없시 구현할 수 있습니다. 라이브러리를 설치하면 장점은 fallback 컴포넌트에서 error 객체를 접근하고 error 메시지를 접근하고 클라이언트 화면에 랜더링할 수 있게할 수 있습니다. 또 react-query에 같이 적용하기 좋습니다.

### Worker API에 대해서 설명해주세요

Worker API는 자바스크립트로 병렬처리를 할 수 있게 해주는 API입니다. Worker API로 병렬처리는 크롬 브라우저와 node.js 모두 가능합니다. 자바스크립트는 싱글 쓰레드 언어이지만 worker API를 활용하면 다른 process에 계산하도록 메시지를 보내고 받을 수 있습니다. 일반적인 병렬처리 언어랑 다르게 메인 프로세스에서 다른 프로세스로 메세지를 주고 받아야 합니다. 일반적인 병렬처리를 지원하는 언어는 멀티쓰레드를 제공하고 하나의 프로세스 내에서 힙메모리를 통해 데이터를 공유하고 쓰레드별로 처리해야 합니다. 자바스크립트는 2개의 독립적인 프로세스라 힙을 공유할 수 없습니다. 또 병렬처리할 worker에서는 전역객체도 다릅니다.

보통 node.js에서만 가능할 것 같지만 브라우저도 가능합니다. 브라우저는 탭단위로 서로 독립적인 프로세스를 갖고 있습니다. 만약의 쓰레드를 공유했다면 하나의 브라우저 탭이 다른 브라우저탭에 영향을 줘야 하지만 아닙니다. 리액트로 프로그래밍하다가 useEffect로 실수로 브라우저가 정지되어도 다른 브라우저는 영향이 없습니다. 브라우저가 내부에서도 worker를 접근하고 window가 아닌 다른 전역객체를 갖고 있는 프로세스에서 실행할 수 있습니다.

### 이미지 업로드 성능 2배?

요청 응답 사이클이 2회인데 1회에 클라이언트 화면에 보여주는 것으로 달성했습니다.

2회의 요청 응답 사이클을 가질 수 밖에 없는 이유는 하나는 storage에 url을 받아와서 유저 정보에 url을 갱신하는 통신이기 때문에 느릴 수 밖에 없었습니다.

다시 생각해보면 잘못된 방법이었습니다. 첫째는 클라이언트가 브라우저에 업로드하면 바로 처리해서 보여줘야 합니다. 이것으로 optimistic update를 처리했어야 합니다. 또 이미지처럼 용량이 큰 데이터는 optimistic update를 적용하지 않는 것이 더 적절합니다. 오히려 조심성 있게 로딩하는 progress bar를 보여주는 것이 더 적절했을 것 같습니다.

### 동료와 협업 경험?

교육과정 동안 5번 협업 경험이 있습니다. 모두 프론트엔드와 협업한 경험입니다.

#### 헙업하기 좋은 동료와 어려운 동료?

협업하기 좋은 동료는 욕심이 많고 구체적인 피드백을 주는 동료인 것 같습니다. 작업이 최소한이 달성된 상태에 바로 PR을 올리는 편입니다. 동료가 기능 혹은 코드에 대해서 보완할 부분을 구체적으로 이야기해주고 배울 수 있는 것이 많았습니다.

교육과정 진행하면서 어려웠던 경우는 진전상황을 잘 공유 안 하는 동료렸습니다. 보통 다같이 하루 1 ~ 2번 중간 상황을 공유하는 경우가 많았습니다. 이 때 미리 공유하면 같이 문제해결하거나 목표로 했던 규모를 조정하기 수월합니다.

#### 동료 혹은 상사와 갈등은 어떻게 해결할 것인가?

갈등의 유형에 따라 다를 것같습니다. 기술적인 결정과 관련된 경우라면 먼저 결정을 존중하고 이해하기 위해서 더 노력해볼 것입니다. 그리고 이해할 수 있었다면 저랑 비슷하게 의문이 있을 수 있는 사람들을 위해 정리해볼 것입니다.

대인관계적인 갈등은 제가 실수하거나 오해할만한 것이 무엇인지 물어보고 풀어보기 위해서 노력할 것입니다. 최대한 다른 사람의 중재를 요청하지 않고 해소를 해볼 것입니다. 만약 상대가 계속 프로페셔널하지 못하게 임하면 중재를 요구해볼 것입니다.

### 본인의 장단점?

동료가 이야기 해준 장점은 테크 트렌드가 빠른 편이라고 했습니다. 영어권 테크 유튜버를 많이 봐서 인지하고 있는 신기술이 많다고 합니다. 갖고 있는 정보가 더 많다고 합니다.

단순하게 생각할 수 있는 것을 복잡하게 생각하는 경향이 있습니다. 아주 단순하게 하드코딩으로 빠르게 해결해도 괜찮은 경우도 있습니다. 그냥 하면 되는데 너무 성급하게 빠르게 추상화를 해야한다는 강박이 있다고 했습니다. 이거를 극복하는 방법은 리팩토링 읽고 기능구현 모자와 리팩토링 모자를 따로 쓰고 각각 따로 커밋하라고 했습니다.

<!-- 다른 단점은 겁이 많습니다. 어려운 기능을 구현하면 리팩토링 전에 바로 커밋하려는 경향이 있습니다. 원래는 좋은 습관이라고 하는데 의외로 나쁘다고 하는 분들도 꽤 많았습니다. 커밋관리 관점에서 나쁘다고 합니다. -->

### 회사에게 하고 싶은 질문?

만약 합격하게 된다면 맡게 될 업무를 더 구체적으로 알 수 있을까요?

---

## [Tucker의 Go 언어 프로그래밍] 2장 프로그래밍 언어

https://www.youtube.com/watch?v=ELOihQ1HYBY

원하는 명령을 원하는 순서대로 실행할 수 있도록 작성한 문서가 프로그램입니다.

순서는 제어입니다. 제어는 2가지입니다. 분기와 반복입니다.

프로그램은 결국에는 문서입니다. 이 문서를 만드는 작업을 보고 프로그래밍이라고 합니다. 문서를 작성할 때 사용한 언어가 프로그램 언어입니다.

문서의 독자는 컴퓨터입니다. 컴퓨터는 문자를 읽을 수 없습니다. 더 정확히 직접 읽을 줄 모릅니다.

op 코드 add(0011)로 3(0011)과 4(0100)를 더하도록 하고 싶습니다. 컴퓨터는 op 코드 즉 작업 명령을 위한 코드입니다. 컴퓨터는 add를 모릅니다. 하지만 0011은 압니다. 3 + 4를 001100110100으로 읽습니다.

mux에서 논리소자로 add 가산기인지, 감산기인지 연결됩니다. 컴퓨터는 명령을 해석하기 보단 mux 기계에서 처리합니다.

과거에는 천공카드로 0과 1을 직접 입력했습니다. 구멍을 수기로 뚤었습니다. 여기서 문제는 잘못 뚤었으면 알수 없습니다. 어디가 잘못되었느지 모릅니다. 초기 프로그램은 이런 천공카드로 작성되었습니다. 초기 프로그래머의 작업이 이런 것이었습니다.

이후에 어쎔블리어가 등장했습니다. 모니터와 키보드로 사람이 읽을 수 있을 정도로 쉬워졌습니다. ADD, SUB, MOV(복사)가 있었습니다. 천공카드보다 더 수월하게 입력할 수 있게 됩니다. 입력 내역 전체를 검토할 수 있게 됩니다.

컴퓨터는 결국에는 0과 1의 기계어로 번역되어야 합니다. 어쎔블리어를 기계어로 변환해줘야 합니다. 어쎔블리어는 1대1로 컴파일됩니다.

어쎔블리어도 결국에는 한계가 있었습니다. 컴퓨터의 명령이 1대1로 대응되어야 합니다. 문제는 번거롭고 여전히 복잡해집니다. 고급 기능을 활용하기 어렵습니다. 현대 프로그래밍 언어는 활용할 고급기능이 많습니다. 어쎔블리어는 활용할 고급기능이 없습니다. 이런 이유로 고수준 언어가 등장했습니다.

어쎔블리어를 보고 저수준 언어고 나머지는 고수준언어라고 봐야 합니다.

고수준 언어는 인간이 읽기 쉽고 동작을 예상하기 쉽습니다.

```go
func main() {
  fmt.Println("Hello, world!")
}
```

고수준 언어는 고급 기능을 활용할 수 있습니다. 고수준이든 저수준이든 결국에는 기계어로 변환되어야 합니다.

결국에는 컴파일(인터프리터)과정이 필요합니다.

언어를 구분할 때 변환되는 시점에 따라 정적 컴파일언어와 동적 컴파일 언어로 구분할 수 있습니다. 컴파일해서 기계어로 미리 만들어 생긴 파일을 보고 실행파일이라고 봅니다. 매번 컴파일 할 필요가 없어서 속도가 빠릅니다.

동적 컴파일언어는 실행하면서 소스코드를 기계어로 바꿉니다. 정적컴파일은 미리해서 편하지만 동적 컴파일은 대체로 컴파일 속도가 빠릅니다.

c언어, java는 정적 컴파일언어입니다. 정적컴파일 언어의 문제점이 있어서 동적 컴파일 언어가 탄생했습니다.

op 코드는 명령을 이진수 숫자에 대입합니다. 기계어로 변환되려면 op 코드로 변환되어야 합니다. op 코드를 알아야 기계어를 사용할 수 있습니다.

옛날에는 cpu를 만드는 회사가 많았습니다. 회사마다 op 코드가 모두 달랐습니다. 표준이 없었습니다. 실행환경마다 만들어야 하는 기계어가 달라졌습니다.

정적 컴파일 언어에서는 기계어로 바꿔야 할 때 타겟 실행파일을 알아내고 컴파일해야 합니다. 과거에는 각각의 플랫폼별로 실행파일을 만드는 경우도 있었습니다. 또 사용자도 실행파일도 각각 받아야 했습니다.

동적 컴파일언어는 현재 본인의 환경을 분석하고 거기에 맞게 기계어로 변환합니다. 동일한 코드로 컴퓨터는 달라도 동일하게 실행될 수 있게 합니다.

go는 정적 컴파일 언어입니다. 이유는 속도입니다. 또 호스트 환경 플랫폼이 단순해졌습니다. 운영체제도 옛날보다 종류가 많이 감소했습니다.

go는 여러 플랫폼에 실행파일 만들 수 있게 언어차원에서 제공해주고 있습니다.

```sh
$Env:GOOS = "linux"
```

go의 os를 임의로 바꾸는 명령입니다.

```sh
go build
```

이렇게하면 리눅스용 실행파일이 생성될 것입니다.

go 언어의 특징 중 하나는 본인의 운영체제로 기본설정하는데 다른 원하는 운영체제를 타게팅해서 만들 수 있습니다. 실행파일을 공유만 해주면 됩니다.

약타입 언어와 강타입언어로 분류도 가능합니다.

"12" + 12 = "1212"

이렇게 되는 언어도 있습니다. 자바스크립트가 그렇습니다. 문자열과 숫자가 있는데 모두 문자열로 변환하고 문자열을 concat했습니다.

"12" + 12 = error

이렇게 에러 처리해주는 언어도 있습니다.

약타입 언어 중에서도 타입이 다를 때 계산을 막는 언어도 있습니다.

약타입 강타입은 스펙트럼으로 이해하는 것이 더 적합합니다.

언어에 따라 다르지만 정수와 소수를 더하면 에러를 발생시키는 언어도 있고 모수 소수로 변환하고 계산하는 언어도 있습니다.

go 언어는 강타입 언어로 분류할 수 있습니다. 타입검사가 상당히 강한편입니다.

타입을 맞춰줘야 하는 귀찮은 경우가 많지만 큰 코드베이스에서 이상하게 발생하는 버그는 방지됩니다.

언어를 구분할 때 GC 유무로 분류가 가능합니다. 쓰레기는 메모리 쓰레기입니다. GC가 없는 언어는 C, C++, Rust, Zig입니다. 있는 언어는 go, python, java, javascript가 해당합니다.

GC가 없으면 프로그래머가 수동으로 제거해줘야 합니다. 안 하면 메모리 누수가 발생하고 프로그램이 강제 종료가 될 수 있습니다. 또 버그가 발생할 수 있습니다.

GC의 장점은 프로그래머의 편의성입니다. 단점은 성능입니다.

Go 언어는 특이하게 GC가 있어도 성능이 상당히 좋습니다.

## [Tucker의 Go 언어 프로그래밍] 3장 Hello Go World

https://www.youtube.com/watch?v=-a63oRs38DY

오픈소스를 흉내내는 프로그램 언어입니다. 켄 톰슨이 만들었습니다. 켄 톰슨은 B언어를 만들었습니다. B언어는 C언의 모체가 됩니다. go의 많은 C언어 스러운 부분이 됩니다. C언어와 닮은 부분이 많습니다.

롭 파이크 go를 창시했는데 켄 톰슨이랑 같이 utf-8을 만들었습니다. go는 utf-8이 기본 문자입니다.

문자 인코딩은 문자를 어떻게 표현할지 문제를 해결합니다. 컴퓨터는 0과 1만 압니다. 명령어를 숫자로 바꾸는 것이 op 코드인데 컴퓨터가 문자를 숫자로 변환시켜줄 수 있게 해줍니다. 그리고 컴퓨터에게 숫자가 나오면 어떤 문자의 모양을 모니터에 출력하게 해줍니다.

문자 코드입니다. 문자 코드는 ANSI만 존재했습니다. 이 코드는 1바이트로 영어를 표현했습니다. 1바이트로 표현할 수 있는 문자는 128의 문자를 표현할 수 있었습니다. 영어, 숫자, 특수 문자 몇개를 만들었습니다.

컴퓨터가 전세계에 보편화되면서 문제가 생깁니다. 표현하기 부족합니다. utf-8이 이 문제를 해결해줍니다. 유니코드는 2바이트로 문자를 표현할 수 있습니다. utf-8은 1 ~ 3바이트로 표현합니다.

go는 기본적으로 utf-8로 표현할 수 있어서 한글, 한자 문자를 표현할 수 있습니다.

오픈 소스 프로그래밍 언어입니다. 먼저 언어도 프로그램입니다. go는 컴파일러 언어입니다. go 언어는 변화하는 컴파일러 프로그램입니다. 이 go를 만든 프로그램도 존재합니다. 그리고 공개되어 있고 기여도 가능합니다. 여기에 기여하면 이력서에 추가하기 바랍니다.

go는 클래스를 지원하지 않습니다. 메서드를 가진 구조체를 지원합니다.

상속 없습니다. 클래스가 없으니 당연합니다.

메서드 있습니다. 구조체가 있습니다. 또 어떤 타입이든 메서드를 가질 수 있습니다.

인터페이스는 지원하고 있습니다. 익명함수 있습니다. 하지만 함수 리터럴이라고 합니다.

GC있습니다. 성능도 좋습니다.

포인터 있습니다. go 포인터가 있는데 c언어와 비슷합니다. 포인터는 메모리 주소를 값으로 갖는 타입을 말합니다.

제네릭 프로그래밍 지금은 있지만 많이 제공하지 않습니다. 제네릭이 만드는 문제가 상당히 많습니다.

네임스페이스 없습니다. 패키지 단위로 분리됩니다. 모든 코드가 패키지 단위로 분리합니다.

```go
package main

import "fmt"

func main() {
	// 이것은 주석입니다.
	fmt.Println("Hello, go lang!")
}
```

이제 이렇게 만들면 됩니다.

```sh
go mod init (프로젝트_디렉토리/하위디렉토리)
```

실험을 위한 폴더 이름을 만드는 팁입니다.

go의 모든 코드는 package로 시작해야 합니다. 지금 코드가 호출하는 패키지를 봐야 합니다. 패키지는 코드를 묶는 단위입니다. 패키지 명은 아무거나 작성해도 괜찮습니다. 하지만 main은 특별한 의미를 갖고 있습니다. main은 프로그램 인트리포인트를 포함하는 패키지를 의미합니다. 여기서 프로그램 처리의 모든 시작점이 됩니다.

프로그램이 실행되면 디스크에서 메모리로 호출됩니다. 그리고 CPU는 메모리에서 읽습니다. 읽을 때 어디수 부터 읽을 것인가? 컴퓨터는 사실 중간에서 시작해도 괜찮습니다. 하지만 go는 main에서 지작해야 합니다. 인트리 포인트 1개입니다. 사실 이것은 대부분 프로그램에 해당합니다. main.go에서 출발해야 합니다.

<!-- - ??? `import` fmt는 fmt라는 패키지를 호출한 것입니다. 패키지는 코드를 묶어 놓은 단위인데 패키지에 유용한 기능을 호출합니다. 기능을 갖고 있는 패키지로 `import`합니다. -->

<!-- - ??? `import` main이 가능한가? 논리적으로 불가능해야 합니다. main은 엔트리 포인트이자 프로그램의 루트 역할을 해야 합니다. -->

func는 함수 키워드입니다. 함수를 선언 한 것입니다. 함수명은 자유롭게 작성해도 괜찮지만 main은 예약어와 비슷합니다. main 함수명은 시작점을 의미합니다. package main은 main 함수를 호출해서 해당하는 예약어를 사용하고 있다고 볼 수 있습니다.

주석은 JSDoc을 제외하고 자바스크립트와 동일합니다.

주석은 모든 곳에 만들 수 있습니다. 어떤 위치에서 작성할 수 없게 언어 차원에서 차단하는 언어도 존재합니다. 하지만 golang은 제한하지 않습니다.

fmt.Println는 패키지로 호출해서 호출한 패키지의 메서드를 사용한 것입니다. 패키지의 함수를 사용한 것입니다. ln은 줄 line을 의미합니다.
