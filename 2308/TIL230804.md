# TIL

1일1커밋 무사고: 251일차

04:45

## todo

- [ ] 취업 관련 활동(사람인 이력서 수정, 피그마 이력서)
  - [ ] 1뽀모도로
  - [ ] 1뽀모도로
  - [ ] 1뽀모도로
  - [ ] 1뽀모도로
  - [x] 1뽀모도로
  - [x] 1뽀모도로
- [ ] 회사 지원하기
  - [ ] [퀀다과외](https://www.wanted.co.kr/wd/172905)
  - [ ] [레티튜(Letitu)](https://www.wanted.co.kr/wd/125018)
- [ ] github action 릴리즈 노트 자동화
- [x] 1일 3제
- [x] 원티드 특강 듣기
- [x] svelte todo app 만들기

## 기업지원

- 세진마인드 -> 미연람
- 유유유유유 -> 미연람
- 피아스페이스 -> 미연람
- 보인정보기술 -> 미연람
- 스타일셀러 -> 미연람
- 미스터디벨로(Mr.Devello) -> 미연람
- 와이즈솔루션 -> 미연람
- 메이코더스 -> 미연람
- 브이젠 -> 미연람
- VCA -> 대기(탈락)
- 헬로비즈 연람 -> 열람(탈락)
- 넥스트이노베이션 -> 열람(탈락)
- 두잇 (Doeat) -> 탈락
- 와이아웃 -> 탈락

---

방금 공카에서 연락을 받았습니다. 일경험 프로그램 참여가 가능한지 확인할 수 있을까요?

https://www.kua.go.kr/uapia010/selectJobPrgm.do 확인했을 때 제한될만한 이유가 없어보였습니다.

국취제 일경험 프로그램 오늘 신청했습니다. 죄송합니다. 8월 1일에 보낸 국취제 오늘 확인했습니다.

---

자소서에 정량적 혹은 UX적 비즈니스 임펙트 내용 추가하기(디자이너에서 엔지니어로 전향한 이야기는 유지)

---

## 원티드 특강

전역 상태관리는 지나가기만 하면 전역상태로 관리하기 바랍니다.

atom은 공통함수에서 활용하기 어럽습니다. recoil state는 다른 hook 혹은 컴포넌트에서 만 사용할 수 있습니다. 또 암시적 매개변수와 사이드 이펙트가 발생하기 때문에 조심해야 합니다. 순수함수가 아니기 때문에 함수형 프로그래밍 원칙에 어긋납니다.

일반적으로 context API는 랜더링 효율이 나쁩니다.

Optimistic update는 의외로 많이 안 씁니다.

### 개요

무엇을 테스트할 것인가? 어디까지 테스트할 것인가? 어떻게 테스트할 것인가? 테스트도 자동화할 수 있는가? 그리고 프론트엔드도 TDD를 실천할 수 있는가?

UI 테스트는 프론트엔드는 사용자가 어떻게 사용하는지 테스트를 해야 힙니다. 하지만 이번 시간에는 깊게는 안 다룹니다. UI의 스타일에 관한 테스트도 존재하지만 의미가 약합니다. 컴포넌트 렌더링 순서도 테스트하기 단점이 많습니다. UI 테스트는 존재여부를 파악하는 것이 좋습니다. 하지만 로직상 순서를 테스트할 때 도움될 경우도 있을 수 있지만 별로 없습니다.

이런 이유로 UI 테스트는 의미가 별로 없습니다.

테스트는 유저 시나리오를 기준으로 작성하는 것이 좋습니다. PM이 작성한 유저 스토리를 기준으로 테스트 코드를 작성해야 합니다. 사용자의 행위를 기준으로 테스트하기 바랍니다.

테스트를 위한 테스트는 잘못된 것입니다. 테스트 코드는 있으면 유용하지만 없다고 문제가되는 것은 아닙니다.

TDD로 테스트를 타이트하게 작성하면 코드 가변성이 너무 떨어집니다. 신뢰하기 어렵거나 버그가 자주 발생하는 지점위주로 테스트하는 것이 좋습니다.

이벤트 핸들러를 주입하기 위해 랜더링을 합니다. 이런 이유로 존재위주로 UI 테스트를 하는 것이 좋습니다.

프론트엔드에서는 단위테스트와 통합테스트 경계가 애매합니다. 프론트엔드는 경우의 수를 조합해야 하기 때문에 테스트 방식이 특이합니다.

given - when - then 으로 테스트 코드를 작성하면 됩니다. 테스트 코드를 작성하는 패턴입니다.

단위 테스트는 가장 작은 테스트 단위입니다. 하지만 자주 사용하는 테스트 코드는 jest로 테스트 코드를 작성합니다. vitest는 현재 크게 도움될 것같지 않습니다. 개인적으로 jest로 공부할 것을 더 추천합니다.

통합테스트는 컴포넌트 상호작용하는지 확인합니다. 단위테스트와 단위테스트가 결합되는 지점을 통합테스트로 이해하면 됩니다.

E2E 테스트는 사용자 관점에서 테스트를 진행하는 것입니다. QA가 빡센 회사는 E2E 테스트로 처리를 많이 한다고 합니다. 실제 환경처럼 테스트하기 때문에 실제 DB랑 연결도 됩니다. 단위 테스트에서는 이벤트 발생한것처럼 흉내내지만 E2E 테스트는 흉내내는 방식이 다릅니다. 유저 자체를 흉내닙니다.

테스트 코드의 의미가 강력한 경우는 리팩토링할 때입니다. 새로운 비즈니스 로직을 수기로 확인하지 않고 테스트코드가 보증면 작업이 편해집니다.

리팩토링을 많이 할 경우랑 대규모 업데이트가 필요할 때 테스트 코드가 효율이 좋습니다. 리팩토링한다는 것자체가 작업시간을 어느정도 보장받은 것입니다. 그래서 테스트코드 작성해서 혜택을 누리기 바랍니다.

컴포넌트에서는 hook을 사용할 수 있는데 테스트코드에서는 hook을 다르게 작성해야 합니다.

act는 테스트 코드에서 act가 있고없고 차이는 없지만 act가 있어야 실제 브라우저가 있고없고 차이가 있습니다. 브라우저가 있는 것처럼 작성해야 합니다. userEvent는 유저의 행위를 흉내냅니다. render는 컴포넌트를 그립니다. watiFor는 비동기 호출을 대기합니다.

참고로 recoil provider는 jest가 접근할 필요가 없지만 hook에서 모두 provider로 감싸주도록 합니다.

history 패키지는 현재 stack을 확인할 수 있는 패키지입니다. memoryRouter도 같이 필요합니다.

테스트 provider에서 리액트 쿼리는 retry를 false로 설정하도록 합니다.

beforeAll에 jest.spyon(console, "error").mockImplementation()

nock은 사용하면 엔드포인트를 mocking합니다. 해당하는 엔드포인트에 통신을 흉내내입니다.

waitFor는 비동기처리 관련 통신을 합니다.

data-testid로 랜더 존재여부를 쿼리하는 것을 확인할 수 있습니다.

nock은 MSW보더 덜 부담스럽습니다.

테스트 코드는 it should로 작성하는 것이 정석인 것같습니다. 최근에는 특이하게 한글로 작성하는 경우가 많습니다. PM 요구사항을 더 쉽게 표현할 수 있습니다.

PM과 QA가 테스트를 보고 작성하는 방식도 있고 본인이나 다른 개발자들이 중요하다고 생각하면 알아서 넣어야 합니다. 기획에 구멍이 생겨도 개발자가 알아서 공부해야 합니다.

it, test, spec은 각자 조직마다 컨벤션 차이입니다. given - when - then은 주석으로 알려줘도 됩니다.

테스트 코드는 하드 코딩으로 작성해도 됩니다.

history.location에 toBe 어서션으로 라우트 테스트를 할 수 있습니다.

중간 크기의 컴포넌트를 테스트하고 싶을 때는 mock을 조금섞거나 단위테스트로 쪼개는 것도 좋을 수 있습니다.

recoil은 state를 mocking할 수 없습니다. recoil은 테스트코드 작성할 때는 이벤트핸들러에서 변경되었는지만 봅입니다.

recoil값 변경을 확인하고 싶으면 변경하는 이벤트를 테스트해야 합니다.

mobx는 하드코딩하고 테스트를 하는 것이 더 일반적인 패턴입니다.

외부 API 연동은 무조건 mocking해야 합니다. 결제는 일반적으로 결제 로직을 백엔드에서 처리합니다.

오늘 예제는 나중에 공개합니다.

테스트 코드에서 항상 유저이벤트는 비동기입니다. 또 라우팅은 history.location.pathname을 접근으로 테스트를 검증하기 바랍니다.

프론트엔드에서는 완벽한 TDD는 불가능에 가깝습니다. 기본적으로 실패 케이스를 모두 확인해줘야 합니다. UI가 모두 완성된 상태에서 비즈니스로직에 테스트 코드에 작성이 가능합니다. 또 TDD는 결합도가 높아집니다. 또 PM이 본인 기획의도를 모르는 경우도 많고 구멍도 많습니다. 본인이 원하는 것이 뭔지 모르는 경우 많습니다.

빌드 전에 테스트하고 또 github action에서 테스트 설정하는 것도 전략입니다. PR 시점 뿐만아니라 merge 시점에서 테스트를 실행하는 경우도 많습니다.

userEvent보단 그냥 user라고 작성하는 것이 더 좋은 것 같습니다. provider는 모두 적용하고 import하는 경우도 많습니다.

findBy 쿼리는 비동기적으로 동작합니다. 에러는 실패케이스로 작성하는 것이 더 좋은 테스트 케이스입니다.

---

요즘관심있는 것은 무엇인가? 기술면접 대비하는 방법입니다. 뉴스레터를 읽어보는 것도 좋은 방법입니다.

기술면접에서 코테 서비스 이용하도록 합니다. 신입 프론트엔드는 질문이 어느정도 정해졌습니다. 면접 스터디를 진행해보도록 합니다. 면접 경험을 쌓도록 합니다. 서류 통과도 프로젝트와 블로그 중심으로 질문할 것이기 때문입니다. 예비 회사에서 연습을 시작합니다. 프론트엔드 CS 지식은 디스크, 케시, 메모리를 질문하지 않고 네트워크를 깊게 질문합니다.

시장에서 가치를 확인하고 싶을 때는 채용공고를 많이 확인하도록 합니다.

채용공고에서 어떤 사람을 찾는지 분석합니다.

회사 기술스택을 이해하고 그 기술스택의 장점을 설명할 준비하고 지원합니다. i18n은 국제화입니다.

테스트코드는 맥락에 따라 다릅니다. 처음 출시하는 상황이면 구축하고 테스트코드를 도입합니다. 기능 추가는 테스트코드를 먼저 추가합니다.

leetcode는 우리나라에 적합하지 않습니다. 프로그래머스 문제집 풀이가 더 좋습니다.

실제 실무에서 테스트 코드를 작성합니다. 테스트는 중요한 비즈니스 로직위주로 테스트합니다. 테스트 코드는 성공 케이스별로 UI 변화는 확인해도 스타일링에 대한 테스트는 필요 없습니다.

프론트엔드는 단위 테스트와 통합테스트 경계가 애매합니다. 프론트엔드에서 점진적으로 도입이 많이 보입니다. 리팩토링했을 때 비즈니스 로직이 동일하다는 것을 검증할 때 활용합니다.

통신 mocking은 nock을 활용합니다. 무조건 /user로 시작합니다.

nock 서순?

nock의 서순은 중요합니다. 클릭 이후에 mocking을 해서 nock을 활용해야 합니다. act 이후 nock을 처리해야 합니다. nock은 이벤트 다음에 작성해야 합니다.

act, nock, awitFor를 섞어 사용하면 라우팅 테스트도 구현할 수 있습니다.

리액트 쿼리를 테스트할 때는 custom hook을 테스트하지 말고 컴포넌트를 테스트하도록 합니다.

### 질문

E2E 테스트는 디자이너와 QA가 같이 진행합니다. 개발자가 일부만 자동화합니다.

테스트 코드는 네이버는 작성합니다. 토스는 자유로 둡니다. 리팩토링이 더 성장가능성을 잘 보여줍니다. 하나의 레포가 발전하는 모습을 보여주는 것이 더 좋습니다. 또 리팩토링은 최근의 좋은 코드만 보기 때문에 좋습니다.

useEffect lent는 다음 링크를 참고합니다. https://velog.io/@khy226/useEffect-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%9A%94%EC%95%BD

https://www.robinwieruch.de/react-router-private-routes/

의외로 에러바운더리 많이 활용합니다.

WAS는 대부분 사용합니다. node.js도 비슷하게 있을 것입니다.

함수는 순수함수 가깝게 유지하고 임시형 매개변수는 최대한 절제합니다.

https://jojoldu.tistory.com/615

에러바운더리는 한번에 처리하면 유용할 수 있습니다.

3-Way 핸드쉐이크, 웹 소캣이 뭔지 특히 소캣이 뭔지 알아봅니다.

RDBMS, NoSQL 정규효 무엇이지는 알고있도록 합니다. 가능하면 공고에 있는 것은 면접질문으로 봅니다.

이직할 때는 개인 프로젝트가 별로 안 중요합니다. 회사에서 무슨일을 했는지랑 무슨이유로 기술을 사용했는지 확인합니다. 신입은 무조건 개인 프로젝트하도록 합니다.

fontsource가 정말 좋은 라이브러리입니다. https://github.com/fontsource/fontsource

부족해도 계속 지원해보도록 합니다. 면접이라도 보도록하고 스스로 부족한 것을 확인하도록 합니다.

코테, 과제는 회사마다 다릅니다.

개발자에게 좋은 학원은 없습니다. 유명한 부트캠프 멘토링도 비슷한 고민을 하고 있습니다. 자바스크립트, 타입스크립트, 리액트 프로젝트로 충분한 경우 많습니다. 그리고 리액트 잘 사용하면 Next.js 잘 할 거 압니다.

memo는 비싼 계산에 사용하는 ifream은 useMemo가 정답이 맞을지도 모릅니다.

SI 기업 중에도 좋은 회사도 있습니다. 나쁜 서비스 회사도 있습니다.

주니어는 다양한 경험이 도움됩니다. 하지만 전문성을 위해서는 이직을 해야 합니다.

nock은 API를 더 간단하게 mocking합니다.

플젝 배포 꿀팁은 AWS Amplyfiy가 제일 편합니다. 하지만 Next.js면 그냥 vercel 사용하도록 합니다.

연봉은 회사가 부르게 만들도록 합니다.

테스트 코드는 같이 하는 것이 좋습니다.

프론트 개발 잘한다는 것은 저도 모릅니다. 유명한 개발자 만나도 모르겠는 경우도 있습니다. 개발을 잘한 다는 것은 제품 고민을 잘하는 것 같습니다. 프론트엔드는 사용자랑 가까우니까 디바이스랑 깨지지 안헥 하는 것입니다. 아니면 UX적인 지식을 활용하는 것도 좋습니다.

access Token은 스토리지에 안 담는 전략도 있습니다.

서버는 환경을 동일하게 만드는 것이 중요합니다.

GraphQL은 신입은 공부하지 말도록 합니다. REST API만 공부해도 꽤 공부할 것이 많습니다.

경력직 이직준비는 이력서 업데이트를 분기단위랑 회사가 빡치게하면 이력서를 업데이트합니다. 회사에 조금씩 지원합니다. 일반적인 공고에 지원하면 합격이 낮습니다. 그리고 회사가 면접도 가볍게 봅니다. CS 지식 리뷰하고 블로그 글 다시 복기하고 면접봅니다. 면접 필수 질문 확인합니다.

최적화 경험은 좋게 봅니다. 테스트와 최적화 중 최적화를 더 보는 것 같습니다.

props가 너무 많으면 객체로 묶어보는 전략을 활용합니다.

신입은 어디든 회사 경험이 필요합니다.

쿠키저장은 백엔드가 정한 정책을 기준으로 합니다. 하지만 response에 있는 것을 cookie에 담으면 백엔드 이상한 것입니다.

프론트엔드는 가상환경 설정할 필요 없을 수 밖에 없는 것이 브라우저에서 동작해야 하기 때문입니다.

개발바닥 이력서 리뷰 컨텐츠를 더 많이 보도록 합니다. 하나를 깊게 공부한 기록을 보여주는 것이 좋습니다. 예외처리처럼 꾸준히 뭘 한 것을 보여주는 것이 좋습니다.

타입스크립트는 요즘은 필수입니다. 하지만 Zod는 선택입니다.

블로그는 2주에 1회는 작성하려고 합니다.

경력직은 회사에서 경험한 것을 찾습니다. 현업에서 주니어가 잘해야 하는 것은 구조, 변수관리, 랜더링 관리를 잘해야 합니다.

웹 소캣 관련팁은 채팅 서비스 만들고 알아서 공부합니다.

깊게 팠다는 것은 꼬리질문을 답할 수 있으면 깊게 판것입니다.

에러 바운더리는 현업이 아니면 모를 가능성이 충분히 있습니다.

잘만든프로젝트는 코드에 군더더기가 없는 것입니다.

개발을 잘하는 것은 서비스 운영을 잘 하는 것입니다. 최적화도 사용자가 불편함을 덜어주는 것입니다. 이부분에 집중하도록 합니다.

코파일럿이 도움이 별로 안되면 코드 잘 짜는 것입니다. 최적화는 무조건 나중에 할수록 좋습니다.

팀프로젝트에서 중요한 것은 협업한 스토리입니다. 프로젝트 혼자하면 안 좋은 습관이 듭니다.

혼자하면 주어진 기능을 최대한 잘 짜도록합니다.

신입 프론트엔드는 1년만 있어도 좋은 사수를 구분할 가능성이 생깁니다.

변수 네이밍보단 변수 상태관리 잘하는 것이 더 중요합니다.

리액트를 깊게 공부하는 것은 좋은데 특이한 라이브러리를 깊게 파는 것은 융용합니다.

프론트가 제일 어려운 것을 뭘해야 할지 모를 때입니다.

신입 채용공고에서 기술 스택은 회사마다 다릅니다.

물경력은 면접으로 검증해보도록 합니다. 시장의 판단을 받기위해 면접을 보독합니다. 주니어는 3년까지 중고신입으로 봅니다.

기술스택은 직접 강의없이 혼자서 사용해보도록합니다.

부트캠프 수료 후 6개월까지는 괜찮습니다. 넘으면 조심하도록 합니다.

3년차에 준하는 신입은 아무도 모릅니다. 그래서 지원하도록 합니다.

백엔드 엔지니어와 커뮤니케이션은 정확히 소통해야 합니다. 가능한지 불가능한 잘 이야기합니다.

개발자는 다른 경력도 경력을 약간 칩니다. 물론 회사마다 다릅니다.
