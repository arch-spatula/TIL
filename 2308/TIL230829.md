# TIL

1일1커밋 무사고: 270일차

00:00

## todo

- [ ] 플래시카드 1.1 프로젝트
  - [ ] 프론트엔드
    - [ ] nock으로 통신 테스트
- [x] 코테
  - [x] 화
  - [ ] 수
  - [ ] 목
  - [ ] 금
  - [ ] 토
- [x] 면접 질문
  - [x] 화
  - [ ] 수
  - [ ] 목
  - [ ] 금
  - [ ] 토
- [ ] SQL 강의
  - [x] Ch 4. CRUD
  - [ ] Ch 5. Basic Queries
  - [ ] Ch 6. Structuring
  - [ ] Ch 7. Aggregations
  - [ ] Ch 8. Subqueries
  - [ ] Ch 9 . Normalization
  - [ ] Ch 10. Joins
  - [ ] Ch 11. Performance
- [x] golang
  - [x] 16 9장 if문
  - [x] 17 10장 Switch 문
  - [x] 18 11장 for문
  - [ ] 19 12장 배열
  - [ ] 20 13장 구조체
  - [ ] 21 14장 포인터
  - [ ] 22 15장 문자열
  - [ ] 23 16장 모듈과 패키지
  - [ ] 24 17장 숫자맞추기 게임
  - [ ] 25 18장 슬라이스 1/2
  - [ ] 26 18장 슬라이스 2/2
  - [ ] 27 19장 메서드
  - [ ] 28 20장 인터페이스 1/2
  - [ ] 29 20장 인터페이스 2/2
  - [ ] 30 21장 함수고급편
  - [ ] 31 22장 자료구조 1/2
  - [ ] 32 22장 자료구조 2 (맵)
  - [ ] 33 23장 에러핸들링
  - [ ] 34 24장 고루틴
  - [ ] 35 25장 채널과 컨텍스트
  - [ ] 36 27장 SOLID 객체 중심 설계 원칙
  - [ ] 37 28장 테스트와 벤치마크
  - [ ] 38 Go 1.18 Generic 프로그래밍 #1/3
  - [ ] 39 Go 1.18 Generic Programming #2/3
  - [ ] 40 Go 1.18 Release Generic Programming #3/3

## dfs와 순열과 조합

https://leejams.github.io/%EC%A1%B0%ED%95%A9/

https://velog.io/@rlatp1409/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-JS-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9-%EA%B5%AC%ED%98%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8

https://velog.io/@devjade/JavaScript%EB%A1%9C-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0

---

## 회사에 가장 기대하는 바가 있다면 무엇인지 말씀해주실 수 있을까요?

기술적인 스킬을 적용하면서 엔지니어로 성장할 수 있는 회사인 점이 커리어에서 제일 중요합니다.

오래된 기술을 고수하지 않고 비즈니스에 유용한 기술들을 적용하는 회사인점을 봤습니다.

다른 부분도 바라는 점이 있습니다. 함께 일하는 개발자 동료가 최소한 존재해야 합니다. 지금은 회사에 이끌어가줄 엔지니어 분이 있어서 더 좋습니다.

이끌어가줄 엔지니어가 있으면 적응하고 회사에 빠르게 기여하기 수월할 것 같습니다.

## 롤모델이 있다면 누구고 그 이유는 무엇인가요?

the primeagen이라는 인터넷 방송하는 개발자입니다. 실력도 좋지만 프로그래밍을 대하는 태도가 제일 좋았습니다. 즐겁게 개발을 하고 최대한 몰입을 합니다. 물론 건강을 잘 챙기면서 몰입합니다.

개발자로서 회사일을 잘하는 것이 중요하고 기여를 잘하기 위해 전문성을 갖추는 것이 최우선순위라고 했습니다. 하지만 절대로 회사에서 기여하고 있는 분야로 본인을 한정하지 말라고 했습니다. 넓고 다양하게 경험하고 돈은 1가지 깊게 전문성으로 벌어라고 했습니다. 사고를 넓게 하는 것이 중요하고 또 기본기가 풍부한 것도 중요하다고 했습니다.

## 힘들고 쉽지 않았지만 극복한 경험을 하나 이야기해주실 수 있을까요?

부족한 능력에 너무 과분한 자리를 받았을 때 힘들었습니다. 대학교에서 영상제를 진행하고 있었는데 경험이 너무 부족하고 협업하는 방식과 지식들이 전무한 상태에서 다른 사람들을 이끌었어야 했을 때 힘들었습니다.

극복은 불가능합니다. 프로젝트는 지금 생각해도 망했다고 봅니다. 단거리 경주로 생각하면 거기서 끝입니다.

단기거리 경주가 아니라 마라톤이라고 생각해야 하는 것같습니다. 끝나고 어떻게 더 보완했어야 했는지 찾아보기 시작했습니다. 작업의 규모가 크면 하이레벨 측면에서 위임, 정리, 공유가 중요합니다. 로우 레벨로 작업흐름도 보고 계획을 잘 하는 방법을 찾았어야 했습니다. 큰 흐름에서 같이 핵심 스토리짜고 촬영 계획 시간과 일자별로 짰어야 했습니다. 그리고 쵤영 진행할 때 담당 스태프 배정은 디테일해서 위임했어야 합니다.

비슷한 작업을 다시 했을 때는 몸만 힘들었습니다.

## 즐겁고 행복했던 경험을 하나 이야기해주실 수 있을까요?

개발자 블로그만들고 커지면서 만족감이 있습니다. 사실 눈으로 보이는 페이지들 이외에 숨겨둔 페이지들도 있습니다. 개인적으로 관심만 있고 강의듣고 정리한 내용이 많습니다. 이런 글은 보통 인사이트를 제공하지 않아서 다른 사람들이 볼 수 있게 두지 않습니다. 커지면서 분리하고 또 내용추가하고 그렇게 됩니다.

개인 프로젝트보다 더 오래 만든 프로젝트고 너무 일찍 선택한 프레임워크에서 성숙한 프레임워크를 선택해서 만족감이 큽니다.

## 개발과 무관한 본인의 장단점?

장점은 꾸준합니다. 지금까지 개발 공부한 것도 꾸준해서 가능한 것 같습니다. 1주일 몰입하고 2주 휴식하고 그런 스타일은 아닙니다. 3주 중간을 추구합니다.

단점은 쉽게 겁을 냅니다. 돌아보면 과감하게 해도 괜찮을 것에 불필요한 조심성을 갖던 경우도 많았던 것 같습니다. 개인 프로젝트에서 코드 퀄리티 강박을 갖지말고 빠른 전달을 하고 리팩토링하는 능력에 집중하는 것이 더 실용적이었을 것 같습니다.

## 개발과 관련된 장단점?

장점은 정보력이 많습니다. 영작 실력은 다른 개발자랑 비슷하거나 조금 부족한 수준인데 영어 듣기 실력은 좋은 편입니다. 영어로 된 콘텐츠를 먼저 접해서 테크 트렌드가 빠른 편이라고 동료가 피드백을 해줬습니다. 또 스타트업에서 UX/UI 디자이너로 근무한 경험이 있고 스타트업 생태계에 관심이 많아 전반적인 지식은 많은 편이라고 생각합니다.

단점은 단순하게 생각해도 괜찮은 것을 복잡하게 생각하는 경향이 있습니다. 이런 단점은 목표와 우선순위를 구체적으로 두는 것으로 해결해야 하는 것 같습니다. 부가적으로 고려해야 하는 것은 부가적인 것을 고려해도 괜찮은 맥락에 처리하는 방식도 방법인 것같습니다.

## 16 9장 if문

```go
package main

import "fmt"

func main() {
	temp := 33

	if temp > 28 {
		fmt.Println("에어컨 풀 가동")
	} else if temp < 3 {
		fmt.Println("히터 풀 가동")
	} else if temp >= 18 {
		fmt.Println("적당")
	} else {
		fmt.Println("참는다")
	}
}
```

if문 내에는 bool이 들어가야 합니다. 비교연산자 bool을 만듭니다.

```go
package main

import "fmt"

func main() {
	age := 22
	if age >= 10 && age <= 15 {
		fmt.Println("좋을 때다")
	} else if age > 30 || age < 20 {
		fmt.Println("인생 싫을 나이")
	} else {
		fmt.Println("그냥 살자")
	}
}
```

2개의 로직을 조합하는 것도 가능합니다.

golang도 쇼트 서킷 개념이 있습니다. 왼쪽에서 오른쪽 순서대로 조건을 확인하는데 ||은 true를 보면 뒤를 무시합니다. &&반대로 false를 보면 뒤를 무시하고 false로 간주합니다.

쇼트 서킷을 모르면 발생할 수 있는 실수들이 있습니다.

```go
package main

import "fmt"

var cnt int = 0 // 패키지 전역변수, cnt는 count의 약자

func add() int {
	fmt.Println("add", cnt)
	cnt += 1
	return cnt
}

func main() {
	fmt.Println("???")
	if false && add() < 5 {
		fmt.Println("1증가")
	}
}
```

false가 뒤 조건을 무시하게 만듭니다. 그래서 로직이 실행되지 않습니다.

숏서킷은 조건문에 호출은 많이 하지만 값만 비교해야 합니다. 조건문에서 조작하지 말아야 합니다. 프로그래밍적으로 불가능하다는 것이 아니라 일반적으로 권장하는 조언입니다. 조건문에서 함수를 호출하면 함수로 읽기만 하도록 합니다.

소괄호를 활용하는 방법이 있습니다. 소괄호는 로직을 처리할 순서를 제어할 때 사용합니다.

```go
package main

import "fmt"

func hasRichFriend() bool {
	return true
}

func getRichFriendCount() int {
	return 3
}

func main() {
	price := 35_000
	if price >= 50_000 {
		if hasRichFriend() {
			fmt.Println("앗 신발끈이 풀렸??")
		} else {
			fmt.Println("카뱅 ㄱ")
		}
	} else if price >= 30_000 {
		if getRichFriendCount() > 3 {
			fmt.Println("앗 신발끈이 풀렸??")
		} else {
			fmt.Println("카뱅 ㄱ")
		}
	} else {
		fmt.Println("각이다!")
	}
}
```

이렇게 중첩 로직을 표현할 수 있습니다.

이제 golang에서 특이한 부분입니다. 초기문, 조건문입니다.

```go
if 초기문; 조건문 {
  문장
}
```

위처럼 작성합니다.

```go
package main

import "fmt"

func main() {
	if filename, success := uploadFile(); success {
		fmt.Println("업로드 성공")
		} else {
		fmt.Println("업로드 실패")
	}
}
```

이런 예시로 사용할 수 있습니다. `uploadFile`은 실제 함수가 아닙니다.

golang은 한 줄에 여러 구문을 작성하면 세미콜론(`;`)으로 구분합니다.

success가 조건문에 해당합니다.

go의 스타일은 두번째 반환값을 성공과 실패, 에러를 값이자 플레그로 활용합니다.

보통 초기절에서 플래그를 접근하고 조건절에서 조건을 제어합니다.

## 17 10장 Switch 문

if는 조건을 검사하지만 switch는 값을 검사합니다.

```go
switch 비교값 {
case 값1:
  문장
case 값2:
  문장
default:
  문장
}
```

비교값과 같은 값을 찾아 실행합니다. 결국 선형비교는 동일합니다. 하지만 switch는 값이 중요합니다.

```go
package main

import "fmt"

func main() {
	a := 3
	switch a {
	case 1:
		fmt.Printf("a == 1")
	case 2:
		fmt.Printf("a == 2")
	case 3:
		fmt.Printf("a == 3")
	default:
		fmt.Printf("X")
	}
}
```

if랑 같지만 한줄에 필요한 공간이 더 작습니다. 구조적으로 이해하기 조금더 쉽습니다.

여러개의 값을 검사하는 것도 가능합니다.

```go
package main

import "fmt"

func main() {
	day := "thursday"

	switch day {
	case "monday", "tuesday":
		fmt.Printf("수업")
	case "wednesday", "thursday", "friday":
		fmt.Printf("공강")
	default:
		fmt.Printf("X")
	}
}
// 공강
```

여러개 값들 중 해당하는 값 1개를 발견하면 처리하게 만들 수 있습니다.

```go
package main

import "fmt"

func main() {

	switch true {
	case true:
		fmt.Printf("실행")
	default:
		fmt.Printf("X")
	}
}
// 실행
```

case에 조건문을 작성해서 조건문과 동일하게 작성할 수 있습니다.

조건 자체는 if문이 더 적잘합니다.

switch도 초기문을 지원합니다.

```go
switch 초기문; 비교값 {
case 값1:
  문장
case 값2:
  문장
default:
  문장
}
```

하지만 비교를 위한 비교값을 접근합니다.

```go
package main

import "fmt"

func getAge() int {
	return 3
}

func main() {
	switch age := getAge(); age {
	case 30:
		fmt.Println("나는 스물열살")
	case 20:
		fmt.Println("술먹고 지능 감소")
	case 3:
		fmt.Println("삼위일체 ㄱ")
	default:
		fmt.Printf("X")
	}
}

// 삼위일체 ㄱ
```

```go
package main

import "fmt"

type ColorType int

const (
	Red ColorType = iota
	Blue
	Green
	Yellow
)

func colorToString(color ColorType) string {
	switch color {
	case Red:
		return "Red"
	case Blue:
		return "Blue"
	case Green:
		return "Green"
	case Yellow:
		return "Yellow"
	default:
		return "none"
	}
}

func getColor() ColorType {
	return Yellow
}

func main() {
	fmt.Println("my favorite color is", colorToString(getColor()))
}

// my favorite color is Yellow
```

이런 응용도 가능합니다.

열거형을 만들어서 switch case로 구문 검사하는 패턴을 자주 볼 수 있습니다.

다른 언어는 `break`가 필요합니다. 없으면 모두 실행합니다. go는 작성할 필요가 없습니다. 실제 프로그래머가 switch case를 사용하는 방식을 참고한 것입니다. go는 작성하고 말고 선택입니다.

`fallthrough`를 사용하면 다음 case로 건너가도록 할 수 있습니다.

```go
package main

import "fmt"

func main() {
	a := 2
	switch a {
	case 1:
		fmt.Printf("a == 1")
	case 2:
		fmt.Printf("a == 2")
		fallthrough
	case 3:
		fmt.Printf("a == 3")
	default:
		fmt.Printf("X")
	}
}
// a == 2a == 3
```

이렇게 동작합니다. 참고로 go에만 있는 기능입니다.

사실 프로그래밍에서 잘 모르면 덜 사용하도록 합니다. 성능저하 문제나 이런 거는 없는데 불필요한 혼란을 발생시킬 가능성이 높기 때문입니다.

## CRUD

https://github.com/bootdotdev/fcc-learn-sql-assets/tree/main/course/4-crud/exercises

CRUD는 데이터와 데이터 베이스 관련된 것의 핵심입니다. 일반적인 REST API는 대응관계가 잘 됩니다.

http는 post - create, get - read, put - update, delete - delete로 대응됩니다.

sql도 대응됩니다. create - create, read - select, update - update, delete - delete

```sql
INSERT INTO employees(id, name, title)
VALUES (1, 'Allan', 'Engineer');
```

인서트문은 이렇게 생겼습니다.

```sql
INSERT INTO 테이블 이름(컬럼이름1, 컬럼이름2, 컬럼이름3)
VALUES (필드1, 필드2, 필드3);
```

이런 형식입니다.

데이터가 웹앱에 일반적으로 흐르는 방식입니다. 프론트엔드, 백엔드 웹서버, 데이터베이스가 있습니다. 프론트엔드는 백엔드에게 http로 주로 통신합니다. 백엔드 서버는 데이터 베이스를 sql로 통신합니다.

사용자가 회원가입 요청을 post로 서버에게 요청을 보내면 서버는 해당 정보를 sql로 실행해서 기록합니다. 이 처리가 성공하면 클라이언트는 성공응답 200을 돌려 받습니다.

프론트엔드랑 db랑 직접 통신하는 경우는 로컬 전용 어플리케이션에서 주로 합니다. 하지만 클라우드를 수단으로 서로 통신해야 하면 프론트엔드는 서버랑 통신해야 합니다.

auto increment는 자동 증감을 명시하지 않고 1개 증가를 처리할 수 있습니다. 하지만 이렇게 사용하면 db를 한번 읽어야 합니다. 하지만 그 뒤부터 서버가 구동되는 동안 증가시켜줄 필요는 없습니다. 재구동으로 메모리가 비워지면 다시 db를 읽어야 합니다. uuid도 자주 볼 수 있습니다. uuid는 삽입 전에 읽을 필요 없어서 좋습니다.

어떤 데이터 베이스는 auto increment는 명시해야 합니다. 하지만 sqlite는 명시할 필요 없습니다.

```sql
INSERT INTO users (name, age, country_code, username, password, is_admin)
VALUES (Lance, 20, US, LanChr, b00tdevisbest, false)
```

sqlite는 id를 생략하면 위처럼 자동으로 id를 increment 해줄 것입니다.

```go
sqlQuery := fmt.Sprintf(`
INSERT INTO users(name, age, country_code)
VALUES ('%s', %v, %s);
`, user.Name, user.Age, user.CountryCode)
```

위처럼 작성하는 경우는 거의 없습니다. 다른 프레임워크 orm을 통해서 처리할 것입니다. sql injection 공격으로부터 방어해줄 수 있습니다.

sql문은 동적으로 프로그래밍 언어에서 생성되는 경우가 대부분입니다. code gen을 해주는 프레임워크 및 라이브러리를 활용하게 될 것입니다.

```sql
SELECT count(*) from employees;
```

row 전체의 개수를 구하는 명령입니다. sqlite에서 지원합니다.

클라이언트는 get 서버는 db에게 select합니다. 그리고 db에서 가져오면 json으로 응답합니다. 유일한 방법은 아니고 자주 볼 수 있는 방법입니다.

where 절은 자주 볼 것입니다. where 절 없이 db를 조회하는 경우는 거의 없습니다.

```sql
SELECT name FROM users WHERE power_level >= 9000;
```

이렇게 생겼습니다.

```sql
SELECT 컬럼명 FROM 테이블명 WHERE 선택 조건;
```

위처럼 where를 사용하는 것이 일반적입니다. 안 사용하면 클라이언트, 서버가 터질 수 있습니다.

```sql
SELECT username FROM users WHERE is_admin=true;
```

위는 is_admin이 true 경우만 선택합니다.

is null과 is not null 문법으로 선택 혹은 무시하게 만들 수 있습니다.

```sql
SELECT name FROM users WHERE first_name IS NULL; -- 존재하지 않는 경우

SELECT name FROM users WHERE first_name IS NOT NULL; -- 존재하는 경우
```

위처럼 입력이 없는 경우를 무시 혹은 확인하게 만들 수 있습니다.

```sql
DELETE from employees
    WHERE id = 251;
```

위에서 where 절이 없으면 테이블이 비워집니다. where 절로 필터를 반드시 해주시기 바랍니다.

노하우가 하나 있다면 delete 명령 전에 select로 where 의도가 맞는지 확인하고 select를 delete로 바꿉니다.

삭제를 할 때는 또 조심할 점은 프라이머리키를 통해서 삭제하도록 합니다. 동시에 여러개 삭제할 필요가 없으면 프라이머리키를 접근해서 삭제합니다. 의도하지 않게 중복삭제가 발생할 수 있습니다.

```sql
DELETE from employees
    WHERE name="jake";
```

가장 지혜로운 개발자는 프로덕션 앱이 분명 버그로 가득하다는 것을 알고 있습니다. 장애까지 1커밋 남은 상황일 수 있습니다. 장애가 발생해도 db를 메모리에 저장하지 말고 사용자 db를 저장하고 있는 것이 지혜로울 것입니다.

이번에는 백업의 동작방식입니다.

제일 일반적인 방식입니다. 매일 스냅샷을 찍습니다. 밤 12시 정각에 정검시간이 있을 수 있습니다. 이때 백업 처리를 진행합니다. 파일 시스템로 디스크를 제공해주는 클라우드 서비스에 쑤셔 넣을 것입니다. 만약에 잘못되면 하루전으로 돌릴 수 있습니다. 하루 단위 스탭샷을 보관하고 월 단위로 보관할 것입니다. 월을 넘기면 삭제합니다.

단점은 스냅샷 이후로 데이터를 모두 잃습니다. 보완은 시간단위입니다. 이렇게 되면 비용이 커집니다. 하지만 작은 회사는 이렇게 해도 괜찮습니다.

조금이라도 데이터를 잃으면 안되는 경우면 다른 방법이 있습니다. DB에 변화가 발생하면 append only log에 추가되도록 합니다. 해당 log를 기록합니다. 실제 db에서 삭제하면 삭제가 된 것이지만 append only log는 삭제가 되었다는 기록을 남길 수 있습니다.

대부분의 작은 회사는 스냅샷으로 충분합니다.

항상 프로덕션 환경을 위해 백업 db를 구축하도록 합니다. 하루 단위로 데이터를 잃지만 모든 데이터를 잃는 것보다 좋습니다.

가끔은 soft delete 전략을 갖고 있습니다. db에 진짜로 delete 처리를 하지 않고 delete log를 기록하고 나중에 진짜로 삭제하고 다시 쿼리할 때는 안보이게 합니다. 문제는 복잡성입니다. 필터링이 필요합니다. 또 프라이버시 문제도 있습니다. 유저가 탈퇴했지만 유저의 데이터는 남기 쉽습니다. 또 문제는 쿼리가 느리게 만들어 줄 것입니다. 조회해야 하는 량이 많아지기 때문입니다.

```sql
UPDATE employees
SET job_title = 'Backend Engineer', salary = 150000
WHERE id = 251;
```

위와 같이 처리하면 갱신됩니다. 구체적으로 1개의 row를 갱신합니다.

ORM입니다. ORM은 DB 제어를 더 편하게 해주는 라이브러리입니다. 인메모리 객체, 구조, 레코드를 데이터베이스 스키마에 맞춰서 제어할 수 있게 해줍니다.

go는 구조체가 있습니다.

```go
type User struct {
    ID int
    Name string
    IsAdmin bool
}

user := User{
    ID: 10,
    Name: "Lane",
    IsAdmin: false,
}

// generates a SQL statement and runs it,
// creating a new record in the users table
db.Create(user)
```

모든 것은 sql문으로 직접 작성할 필요가 없어서 제어하기 좋습니다. ORM은 직접 sql작성도 쉽다는 조건 하에 ORM을 통해 작성할 것을 권장합니다.

나중에는 아주 복잡한 쿼리도 작서해야 합니다. ORM은 제어를 지불해서 낮은 복잡성을 얻는 경우가 많습니다.

코드의 작성량이 작아서 아주 좋은 장점이 있습니다. 하지만 절대 제어가 늘지 않습니다. 또 가끔 디버깅도 더 어려워질 수 있습니다. ORM이 복잡해지면 쿼리 성능도 나빠질 수 있습니다.

하지만 대부분의 경우 ORM을 사용하는 것이 좋습니다.

https://youtu.be/KBDSJU3cGkc?t=7214

## 18 11장 for문

https://www.youtube.com/watch?v=6K05jYPJlKo

go는 for 문 1가지입니다. for 문을 while 문처럼 작성할 수 있습니다.

괄호가 없는 것은 조건문과 같습니다.

```go
for 초기문; 조건문; 후처리 {
  문장
}
```

조건문이 true 동안 실행됩니다.

초기문을 실행하고 조건문을 확인합니다. 문장을 실행하고 후처리를 실행합니다. 문장을 먼저 실행하고 후처리하

```go
package main

import "fmt"

func main() {
	for i := 0; i < 10; i++ {
		fmt.Println(i, ", ")
	}
}
// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
```

i는 인덱스 말고 지금 맥락에서는 이터레이터를 의미합니다. i, j, k 3가지를 많이 활용합니다.

반복문에서 사용한 i는 반복문 블록 스코프 내에 한정됩니다.

```go
package main

import "fmt"

func main() {
	i := 0
	for ; i < 10; i++ {
		fmt.Println(i)
	}
	fmt.Println(i)
}

// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10
```

초기문이 없으면 없다고 세미콜론만 남기고 i 선언 대입은 위 밖에 스코프에 정의하면 변수를 밖으로 뺄 수 있습니다.

후처리도 문법적으로 생략이 가능하지만 실수하기 쉽기 때문에 남기도록 합니다.

```go
for 조건문 {
  문장
}

for ; 조건문; {
  문장
}
```

위 2가지 모두 가능합니다.

```go
for true {

}

for {

}
```

위 2가지로 무한루프를 만들 수 있습니다. 무한루프를 만들기 위해 `true`도 생략할 수 있습니다.

무한 반복문은 왜 필요한가? 특정 조건에 깨고 싶으면 `break` 키워드를 사용하면 됩니다.

`continue` 키워드를 보면 다음 순회로 넘어가게 합니다.

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	stdin := bufio.NewReader(os.Stdin)
	for {
		fmt.Println("숫자입력 ㄱㄱ")
		var num int
		_, err := fmt.Scanln(&num)
		if err != nil {
			fmt.Println("숫자로 ㄱㄱ")
			stdin.ReadString('\n')
			continue
		}
		fmt.Printf("%d\n", num)
		if num%2 == 0 {
			fmt.Println("짝수 해제")
			break
		}
	}
}
```

짝수를 받으면 해제하는 프로그램을 만들 수 있습니다. 표준 입출력으로 상호작용하게 만들 수 있습니다.

for문은 if문 중첩처럼 중첩이 가능하지만 성능이 나쁩니다.

이중 for문을 현실에서 보게 되는 상황은 은근히 있습니다. 성능최적화로 기여할 기회입니다.

중첩 for 문은 break로 탈출하기 어려워서 플레그 변수 혹은 레이블을 많이 활용합니다.

```go
package main

import (
	"fmt"
)

func main() {
	a := 1
	b := 1
	found := false
	for ; a <= 9; a++ {
		for b = 1; b <= 9; b++ {
			if a*b == 45 {
				found = true
				break
			}
		}
		if found {
      break
		}
	}
  fmt.Println(a, b) // 5, 9
}
```

간단하게 곱셈을 볼 수 있습니다. 위는 플래그를 활용한 예시입니다. 이중 for문까지 탈출 할 수 있습니다. 3중 for문이 필요하면 플래그 변수를 또 만들어야 합니다.

다른 방법은 레이블을 활용하는 전략입니다.

```go
package main

import (
	"fmt"
)

func main() {
	a := 1
	b := 1

outer:
	for ; a <= 9; a++ {
		for b = 1; b <= 9; b++ {
			if a*b == 45 {
				break outer
			}
		}

	}
	fmt.Println(a, b)
}
```

위에서 outer가 레이블에 해당합니다. break가 outer를 나간다고 반환 값 할당하는 것처럼 입력하면 됩니다. 장점은 간결해졌습니다. c, c++는 레이블을 지원합니다. 또 goto문도 지원합니다.

사실 레이블은 자주 작성하지 않는 것이 좋습니다. instruction pointer를 내부적으로 막 바꾸기 때문에 stack이 꼬일 수 있습니다. 또 레이블을 지원하지 않는 언어도 많습니다.

하지만 예외는 있습니다. 플레그를 먼저 사용해보고 outer가 효율적이면 outer를 활용합니다.
