# TIL

1일1커밋 무사고: 255일차

00:00

## todo

- [ ] 1일 3제
- [ ] 자기소개서 성장을 위한 리소스가 필요 없어보이는 내용 추가
  - [ ] request waterfall 해결 사례 추가???
  - [ ] 혼자서 문제를 정의하고 혼자서 능동적으로 문제를 해결
- [ ] nest.js freecodecamp 튜토리얼 완강
- [x] as const 타입스크립트 팁 정리

---

## as const

[The most underrated TypeScript feature](https://www.youtube.com/watch?v=6M9aZzm-kEc)

```ts
const routes = {
  home: '/',
  admin: '/admin',
  users: '/users',
};
```

이렇게 라우팅을 설정합니다. 당연히 상수이고 변형이 가해지면 안됩니다.

```ts
const routes = {
  home: '/',
  admin: '/admin',
  users: '/users',
};

function goToRoute(route: '/' | '/admin' | '/users') {
  // ...
}
```

일단 코드 중복이 발생합니다. 라우팅은 정책으로 언제든지 금방 늘어날 수 있습니다.

```ts
const routes = {
  home: '/',
  admin: '/admin',
  users: '/users',
};

function goToRoute(route: '/' | '/admin' | '/users') {
  // ...
}

goToRoute(routes.home); // 타입에러
```

이것은 타입스크립트가 타입 체킹하는 방식의 문제 때문에 발생합니다.

routes의 value는 string이지만 매개변수의 타입은 문자열 이넘(enum)입니다.

즉 string은 "/"이 아니다라는 이유로 타입에러를 돌려주는 것입니다.

string으로 타입추론을 하는 이유는 다른 문자열로 재할당이 가능하기 때문에 상위 문자열 타입으로 간주합니다.

```ts
const routes = {
  home: '/',
  admin: '/admin',
  users: '/users',
} as const;

function goToRoute(route: '/' | '/admin' | '/users') {
  // ...
}

goToRoute(routes.home); // 문제 없음
```

이렇게 as const로 단언하면 readonly로 지정합니다. 재할당이 불가능합니다. object.freeze와 비슷하게 재할당을 막지만 object.freeze는 얕은 freeze만합니다. as const은 깊은 freeze를 지원합니다.

```ts
const routes = {
  home: '/',
  admin: '/admin',
  users: '/users',
} as const;

type Routes = (typeof routes)[keyof typeof routes];

function goToRoute(route: Routes) {
  // ...
}

goToRoute(routes.home); // 문제 없음
```

이렇게 지정하면 읽기 전용 상수객체의 Routes를 활용할 수 있습니다. 위와 같은 '/' | '/admin' | '/users'을 추출할 수 있게 됩니다.

```ts
const routes = {
  home: '/',
  admin: '/admin',
  users: '/users',
} as const;

type RotesKeys = keyof typeof routes; // "home" | "admin" | "users"

type Routes = (typeof routes)[RotesKeys]; // "/" | "/admin" | "/users"

function goToRoute(route: Routes) {
  // ...
}

goToRoute(routes.home); // 문제 없음
```

타입에서 키와 그 값을 이런 패턴으로 as const를 활용해서 접근이 가능합니다.
