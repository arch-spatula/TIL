# TIL

1일1커밋 무사고: 267일차

05:41

## todo

- [x] 면접 진행
- [ ] 주간회고
  - 블로그에 정리한 내용을 바탕으로 다시 생각하기
- [ ] 17, 18주차 마이그레이션
- [ ] nock은 GraphQL을 지원하는가?

## 면접

총론: 선무당이 사람잡습니다.

### 스코프의 문제?

- 자바스크립트 컴파일러의 토큰관점으로 논함

### 이전회사를 퇴사한 이유?

- 이전 회사 꽤 좋은 회사고 사람들도 좋고 잘 챙겨주셔서 좋았습니다.
- 프론트엔드 엔지니어로 도전하기 위해 퇴사를 결정했습니다.

### 브라우저에 URL을 입력하면 발생하는 일?

- 큰 틀로 2단계입니다. 처음에 IP를 찾고 다음에 서버를 찾아 요청을 보냅니다.
- 자세하게는 오늘날 소프트웨어와 인프라가 어떻게 이 작업을 처리하는지 그 우아함을 확인해볼 수 있습니다.
- 여러 계층의 캐시가 있고 이 캐시를 찾아내는 과정의 연속입니다.
- 처음에 브라우저는 IP 캐시를 확인하고 캐시미스가 발생하면 운영체제에서 확인합니다.
- 운영체제에서 확인하고 여기서 또 캐시 미스가 발생하면 DNS 쿼리를 진행합니다.
- DNS 쿼리의 과정은 DNS 리솔버 서버가 있고 리솔버 서버가 DNS 계층 별로 쿼리합니다.
- 3단계 계층으로 최상위 계층에서 IP를 찾아보고 없으면 중간 계층 또 없으면 하위 계층에서 찾아보고 응답합니다.
- 이렇게 클라이언트는 IP를 찾으면 서버에 요청을 보냅니다.
- 하지만 알게 된서버가 먼저 CDN서버의 Pop을 먼저 접근합니다. 여기서 또 해당하는 리소스가 캐시 미스가 발생하면 아마존 데이터 센터로 요청을 보냅니다.
- 여기서 자원을 클라이언트에게 돌려주고 CDN은 해당 리소스를 캐싱합니다.
- 이 답변은 아쉬운 점은 별로 없습니다.
  - TLS 과정이 생략됨
  - 포워드 프록시, 리버스 프록시도 없음

### 브라우저 랜더링 과정?

#### 리페인트 리플로우를 최적화하는 방법?

### jquery를 사용하지 않고 가상 DOM을 사용하는 이유는?

- 순수 자바스크립트 혹은 jquery와 섞어서 클라이언트 앱을 만드는 것은 가능합니다.
- 또 클라이언트 디바이스의 성능이 아무리 좋아져도 한계가 많습니다.
- MPA로 동일한 계산을 또 처리하는 것은 낭비가 너무 큽니다. 실제로 계산이 필요한 부분은 UI의 작은 부분에 해당합니다. 가상 DOM을 활용하면 갱신이 발생하는 부분만 찾고 방영하기 수월하기 때문에 사용합니다.
- 과거 리액트, 앵귤러, 뷰 3대장은 가상 DOM을 이렇게 장악하고 있습니다.
- 최근 트렌드를 보면 더이상 고수할 필요가 없어지기 시작했습니다. 클라이언트에게 가상 DOM을 전달하면 번들 사이즈가 커져서 다른 점근인 컴파일러 시대 State of JS 2022에서 solid, Quik, svelte 컴파일러 라이브러리와 프레임워크가 소개 되었습니다.
- 컴파일러가 주목을 받기 시작한 지금 시대에서는 리액트를 사용하는 이유는 생태계 때문에 사용해야 한다고 보고 있습니다.

### 자기소개?

### request waterfall?

### 토큰에 대해서

#### 갱신 시간 결정 기준?

- 실제 유저가 있고 이 유저의 체류시간을 통계와 활용해서 정해야 합니다.
- 하지만 실제 유저가 없어서 임의로 1시간 access token을 설정했습니다.

#### 토큰 갱신 시간을 너무 짧게하면 생기는 문제?

- 토큰을 생성하는 것은 결국에는 암호화로 계산이기 때문에 계산비용이 높은 편입니다.
- 이 계산을 서버에게 자주 요청하면 CPU 자원비용을 많이 소모하기 때문에 보안과 비용사이 적절한 균형을 찾아야 합니다.

### 최근에 공부한 방식

### 회사에게 한 질문

#### 회사 시작 배경?

#### 합격하게 되면 하는 일은?

#### 기술적인 선택 배경?

- GraphQL은 손이 많이가기보단 머리가 많이 갑니다.

---

## [Tucker의 Go 언어 프로그래밍] 4장 변수 #1

https://www.youtube.com/watch?v=-oqy4PAxC1k

변수입니다. 가장 먼저 나오는 것이 제일 중요합니다. golang도 변수를 잘 알아야 합니다.

변수는 수학관점에서 변하는 수입니다. x만큼 변하는 y의 방정식에서 x는 변수입니다.

하지만 프로그래밍에서 변수는 다릅니다. 변수는 값을 저장하는 메모리공간을 가리키는 이름을 의미합니다.

이름인데 메모리 공간을 가르킵니다. a=1이라고 하면 a는 1을 담고 있는 메모리 공간을 가르킵니다.

변수는 값을 저장하는데 어디에 저장하는가? 저장하는 위치는 2가지입니다. 하드 디스크와 메모리입니다. 하드 디스크는 메모리 저장공간이지만 느리지만 전원이꺼져도 데이터가 보존됩니다. 메모리는 반대입니다.

프로그래밍 실행 도중 연산에 필요한 데이터는 메모리에서 가져옵니다. 메모리를 통해서 데이터를 주고 받고 연산을 합니다. 변수는 프로그램 실행 도중에 메모리에 저장된 공간을 가르키는 이름을 의미합니다.

변수가 왜 중요한가? 프로그램은 데이터를 연산하고 조작하는 일입니다. 컴퓨터의 주된 작업은 계산입니다. 계산하기 위해서는 값이 있어야 하고 이 값은 메모리에서 가져옵니다. 코드에서 메모리의 값을 조작하는 일은 변수를 통해서 발생합니다. 프로그래밍에서 데이터를 접근하는 방법은 변수를 통해서입니다.

프로그래밍은 데이터를 조작하는데 이 데이터가 기본요소입니다.

프로그램은 결국 데이터를 조작하는 일입니다. 게임, 비디오, 음악은 사람이 경험하는 것입니다. 하지만 컴퓨터 내부적으로는 결국 계산입니다.

결국에는 숫자가 바뀝니다. 화면 픽셀에서 컬러 값이 존재합니다. 컬러는 rgb로 표현합니다. 값으로 그림의 밝기를 조절하는데 이 것은 당연히 값에 불과합니다.

모든 프로그램은 데이터를 조작하는 것이 전부입니다. 데이터는 모두 숫자이고 숫자를 조작하는 것은 프로그램이고 프로그램이 데이터를 접근하기 위해서는 변수를 통해서 가능합니다.

```go
package main

import "fmt"

func main() {
	var ten int = 10
	var msg string = "hello var"

	ten = 20
	msg = "good morning"
	fmt.Println(msg, ten) // good morning 20
}
```

```sh
go mod init go-project/ex4.1
go build
./ex4.1
```

이렇게 됩니다.

`var ten int = 10`입니다. `var`는 변수 선언을 의미합니다. `a`는 변수명입니다. 첫글자는 영문자인 경우가 국룰입니다. int는 타입입니다. int는 정수형입니다.

`=`은 대입연산자입니다. 프로그래밍에서 데이터를 저장하라는 명령입니다.

타입이 있으면 공간의 크기를 결정하고 해당하는 공간에 쓰기를 합니다.

문자열할당도 동일합니다.

`a = 20`은 메모리에 값을 덮어쓴 것입니다. 대입연산은 항상 좌에 우변의 값을 쓰기합니다.

문자열도 재할당이 가능합니다. 중요한 것은 재할 당할 때 타입이 같으면 됩니다.

## [Tucker의 Go 언어 프로그래밍] 4장 변수 #2

https://www.youtube.com/watch?v=3J_S6fFCsaw

```go
var a int = 10
```

변수는 4가지 속성을 갖고 있습니다. 이름, 값, 주소, 타입입니다. 사람에게 중요한 것은 이름입니다. 값은 데이터입니다. 주소도 중요합니다. 메모리상 위치를 나타내기 위해 변수의 주소을 알아야 합니다. 메모리는 크고 바이트 단위로 주소가 있습니다. 변수는 큰 숫자값입니다. 컴퓨터 관점에서 변수명이 안 중요합니다. 사람이 제어할 때 변수의 이름이 중요합니다. 변수와 대응되는 주소가 컴퓨터에게 중요합니다.

프로그래머에게 주소를 읽을 경우가 별로 없습니다. 컴퓨터에게 주소가 중요합니다.

타입은 데이터의 형태를 나타냅니다. 정수, 실수, 문자열이 대표적입니다. 타입에서 중요한 것은 사이즈를 알 수 있습니다. 메모리상 확보해야 하는 공간을 파악할 때 타입을 기준으로 정하기 때문에 그렇습니다.

```go
var foo int16 = 23
var bar int32 = 230
```

타입의 사이즈는 이렇게 고정되어 있습니다.

int32는 32비트 공간입니다. 32비트는 4바이트까지 담을 수 있습니다. 시작주소와 타입을 알면 공간을 알 수 있습니다.

변수와 타입은 기본적인 요소입니다.

숫자는 정상적인 언어답게 정수와 실수 구분이 있습니다.

uint는 부호가 없는 정수를 의미합니다. 그냥 양수인 정수를 의미합니다.

int는 정수입니다. 하지만 부호가 존재합니다.

실수형은 float은 32, 64이 있습니다.

타입 aliasing은 같은 타입에 다른 이름을 부여했다는 뜻입니다. byte는 uint8과 같습니다. 1바이트 부호없는 정수인데 개념적으로 같습니다. 하지만 golang은 구분합니다. byte는 부호없는 숫자 데이터를 의미한다고 보면 됩니다.

rune은 문자 1개 char와 유사합니다. 문자 코드는 utf-8입니다. 문자 1개가 1 ~ 3바이트 가변 길이입니다. 1 ~ 3바이트 문자열의 데이터가 되기 위해서는 최소 3바이트를 설정해야 합니다. 또 갱신도 됩니다. 안전하기 위해 3바이트로 설정합니다. 컴퓨터는 2배수로 처리하는 것이 대체로 다루기 편하고 효율적입니다. rune은 int32랑 비슷합니다. 별칭 타입입니다. 4바이트에 모두 담기 위해 활용합니다.

int는 사용하는 플랫폼에 따라 달라집니다. 컴퓨터가 32비트면 32비트이고 64비트면 int도 64입니다. uint도 부호 제거하고 동일합니다.

bool은 조지 부울말고 이진 대수를 창안학 수학자 말고 참 혹은 거짓 값을 갖는 타입니다.

문자열은 모두 잘 알고 있는 문자열입니다.

배열은 같은 타입의 묶음입니다.

슬라이스는 배열이랑 비슷하지만 사이즈가 정해져있지 않습니다.

구조체, 포인터, 함수타입, 맵, 인터페이스, 채널이 있습니다.

별칭 타입이 있는데 rune이 int32랑 동일한 것과 byte이 int8과 동일한 것과 같습니다. 별칭 타입은 스스로 타입정의를 만들어서 타입을 적용하는 것입니다.

```go
var a int
```

여기서 a는 0이 됩니다. 타입의 초기값을 자동으로 할당합니다.

```go
var a = 10
```

이렇게 하면 타입을 생략할 수 있습니다.

바다사자 연산자로 인싸처럼 코딩하기 바랍니다.

```go
a := 10
```

선언대입문입니다.

```go
package main

import "fmt"

func main() {
	var a int = 3
	var b int
	var c = 4
	d := 5
	fmt.Println(a, b, c, d) // 3 0 4 5
}
```

실수형은 항상 기본이 float64입니다.

모든 정수형의 기본값은 0이고 실수형은 0.0이고 부울은 false이고 문자열은 빈 문자열이고 그 외에는 nil입니다. nil은 정의되지 않는 메모리 주소을 나타내는 go 키워드입니다.

타입 변환은 필요합니다. 명시적으로 하면 괜찮습니다. 연산의 각 항목은 반드시 같아야 합니다. golang에서는 정수와 실수를 억지로 더하지 않습니다.

같은 정수라도 확보해야 하는 메모리 공간이 다른 타입도 계산을 허용하지 않습니다. int8 타입의 변수와 int16 타입에 해당하는 변수를 서로 더할 수 없습니다.

```go
package main

import "fmt"

func main() {
	a := 3
	var b float64 = 3.5

	var c int = b
	d := a * b

	var e int64 = 7
	f := a * e

	fmt.Println(a, b)
}

```

이런 문제가 발생할 수 있는 상황도 존재합니다.

```go
package main

import "fmt"

func main() {
	a := 3
	var b float64 = 3.5

	var c int = int(b)
	d := float64(a) * b

	var e int64 = 7
	f := int64(a) * e

	fmt.Println(a, b, c, d, e, f)
}
```

내장함수로 간단하게 해당하는 타입으로 명시적으로 형변환하기 바랍니다.

참고로 실수를 정수로 바꾸면 내림처리합니다.

여기서 주의할 점이 있습니다. go에서 형변환할 때는 서로 허용하는 타입변환의 범위가 있습니다. 문자열을 숫자로 바꿀 수 없습니다.
