# TIL

1일1커밋 무사고: 269일차

00:00

## todo

- [x] 주간회고
- [x] 블로그 34주차
- [x] 문자 답장
- [x] golang

---

비전공이 아니라 늦게 전공했다는 마음가짐으로 CS 공부를 임할 것입니다. 사실 지식은 비전공이랑 같은데 계속 보완하고 깊게 공부하고 분야를 넓게 탐구하겠다는 마음가짐입니다.

## 주간 회고

### Liked

- 그동안 면접에서 풀어보고 싶었던 보따리를 풀었습니다.
  - Virtual DOM기반 UI 프레임워크와 라이브러리를 사용해야 할 이유와 지금은 사용하지 말아야 할 이유
  - 브라우저에 네이버를 검색하면 발생하는 일

### Learned

- 장애보고서 형식을 찾고 정리했습니다.
- 면접 답변은 짧게 깊이를 유도하는 답변이 최고입니다.
  - 면접에 긴답변을 했습니다.
  - 몇개 중요한 질문은 깊이를 보여주기위해 길게 답하는 것도 좋습니다.
  - 가능하면 최대한 직접적인 짧은 답변에 특정 깊이를 유도하는 답변이 더 좋습니다.
- 구름 플랫폼은 python으로 코테가 가능합니다. 프론트엔드 엔지니어라 JavaScript로 언어를 지정해줄 거라고 예상했지만 아닙니다.
- 과제 전형에 떨어졌습니다. 면접 피드백도 받기 어려웠습니다.
  - 이 정보는 코드 정리가 안 된 부분이 너무 안 되어 있다는 것입니다.
  - 코드를 더 잘 정리하는 방법을 찾고 정리해야 합니다.
- SQL과 golang을 한번더 보기 시작했습니다.
  - 보고 있는 강의가 CS 지식을 보완해줘서 좋습니다.
  - 2번째 프로그래밍 언어로 설명을 잘 해주고 있습니다.

### Lacked

- 지난주 프로젝트 진행을 위해 회고를 안 했습니다.
- 이번주도 면접보고 바로 회고를 진행하지 않았습니다.
- 플래시카드 프로젝트를 진행하지 않았습니다.
  - 자난주에는 과제 프로젝트로 바빠서 진행할 수 없었습니다.
- 어제 코테를 진행하지 않았습니다.

### Longed(잘하기 위해 필요한 것)

- 구금 플랫폼으로 코테를 수월하게 볼 수 있도록 python 연습을 해야 합니다.
- 플래시카드 프로젝트를 더 발전시켜야 합니다.
  - 테스트 코드를 작성한 경험을 추가해야 합니다.
  - nest.js로 porting을 진행해야 합니다.
- 코테와 면접질문은 계속 진행해야 합니다.

### Action Item

- [ ] 기술면접질문 6개
- [ ] 6일 1일3제
- [ ] nest.js todo app 만들기
- [ ] 플래시카드 프로젝트 테스트 코드 추가
- [ ] 장애(보안)보고서 블로그에 공개
- [ ] 원티드 프론트엔드 특강 8월 공개

## [Tucker의 Go 언어 프로그래밍] 7장 함수

https://www.youtube.com/watch?v=0quO6sYoowQ

function은 기능이라는 뜻도 있습니다.

수학적 함수는 어떤 입력이 있으면 처리하고 출력이 있습니다. $f(x) = 2x + 5$ 을 보면 x에 2를 대입하면 9를 기대할 수 있습니다.

수학적 변수와 프로그래밍적 변수는 다릅니다. 함수도 비슷합니다. 수학적 함수와 프로그래밍적 함수는 다릅니다. 또 프로그래밍 언어별로 또 다릅니다.

함수형 언어는 수학적 정의에 가까우고자합니다.

일반적인 프로그래밍 언어는 수학적 정의의 함수와 다릅니다.

```go
func add(a int, b int) int {
  return a + b
}
```

함수 정의할 때 사용 전에 정의해야합니다. c언어는 먼저 정의해야 하지만 go는 어디에 정의해도 상관없습니다.

func은 함수 정의 키워드입니다. 함수이름은 변수랑 규칙이 동일합니다.

매개변수는 함수 정의에서 다루는 변수입니다. 호출하고 대입하면 인자라고 부릅니다.

go는 반환타입도 지정해줘야 합니다.

함수는 반환타입을 지정하는 다음 위치에 중괄호로 함수 블록을 만들 수 있습니다.

```go
package main

import (
	"fmt"
)

func add(a int, b int) int {
	return a + b
}

func main() {
	c := add(3, 6)
	fmt.Println(c) // 9
}
```

이렇게 사용할 수 있습니다.

```go
package main

import (
	"fmt"
)

func main() {
	c := add(3, 6)
	fmt.Println(c)
}

func add(a int, b int) int {
	return a + b
}
```

go는 이렇게 순서 무관하게 정의할 수 있습니다.

수학적함수와 프로그래밍적 함수는 어떻게 다른가?

어떤 개념을 볼 때 왜 만들어졌는지 보면 이해가 수월합니다.

프로그램이란 하나의 긴 문서입니다. 입력할 때는 순서대로 입력합니다. CPU 내부에서는 하나의 거대한 종이를 순서대로 읽는 것입니다.

반복되는 부분을 읽는 부분으로 보내고 끝나면 돌아오게 만들면 작업이 더 효율적이지 않을까?

이런 관점에서 생겼을 수 있습니다.

컴퓨터가 IP 즉 instruction point 혹은 PC programming count가 있습니다. 명령을 몇번째 줄을 실행해야 하는지 나타내는지 알려주는 정보입니다. 읽는 중간에 IP로 읽을 곳을 바꾸고 끝나면 읽던곳을 알려주면 만들 수 있습니다. 이것을 보고 jump라고 합니다.

처음에는 호출하면 향할 위치을 알려줄 수 있는데 돌아갈 때 어떻게 알 수 있는가? 즉 50번째 줄에서 1500줄로 갔는데 끝나면 51로 어떻게 돌아갈 수 있는가? 방법은 점프 전에 return point를 기록하고 점프하면 됩니다. 그래서 원래 읽던 곳은 return point라고 부릅니다.

이렇게 하면 반복하는 동작을 자동화할 수 있게 되었습니다.

하지만 문제가 생겼습니다. 모든 동작이 모두 완전히 동일하지 않았습니다. 아주 조금만 동작이 달랐던 경우가 있습니다.

이 한계를 극복하기 위한 방법입니다. 먼저 메모리 공간 하나에 return point를 기록부터 시작합니다. 그리고 다른 메모리 공간에 필요하게 조금 바뀌는 부분에 해당하는 값을 기록하고 점프합니다. 그리고 점프하고 실행하고 끝나면 호출했던 곳으로 돌아합니다.

하지만 문제가 또 발생합니다. 점프하기 전에 기록해야 하는 매개변수에 해당하는 값이 유동적으로 바뀌기 시작했습니다. return point는 계속 기록합니다. 링크드 리스트로 값과 보고 있는 방향을 설정합니다. pop하면서 할당하고 처리하고 결국 돌아게 합니다. call stack이라는 부분이 됩니다.

프로그램에서 함수는 반복하는 작업을 줄여주기 위해서 생겨난 것입니다. 함수를 call을 하면 돌아갈 위치를 기록합니다. 값을 기록합니다. 값은 링크리스트로 기록합니다. 입력은 정방향 값을 읽을 때는 역방향 최근에 추가한 순서대로 읽습니다.

값을 넣는 것을 push라고 하고 값을 읽고 제거하는 것을 보고 pop이라고 합니다.

선입후출 구조를 갖습니다.

함수의 관건은 반복을 줄이는 것입니다. 함수는 결국에는 코드 블럭입니다. 기능과 동작을 나타내는 블럭 단위입니다.

golang은 멀티 반환함수를 지원합니다.

```go
package main

import (
	"fmt"
)

func main() {
	c, success := divide(9, 3)
	fmt.Println(c, success)
	d, success := divide(9, 0)
	fmt.Println(d, success)
}

func divide(a, b int) (int, bool) {
	if b == 0 {
		return 0, false
	} else {
		return a / b, true
	}
}

// 3 true
// 0 false
```

go는 같은 타입이 연속되면 위 예시처럼 묶을 수 있습니다.

하지만 여기서 의문이 생겨야 합니다. success는 이미 정의한 변수입니다. 첫번째 반환값은 중복 선언할 수 없지만 두번째 반환값은 허용합니다. 이것은 golang의 선언 대입문과 반환값의 특징입니다.

golang은 출력값에 이름을 지정할 수 있습니다.

```go
package main

import (
	"fmt"
)

func main() {
	c, success := divide(9, 3)
	fmt.Println(c, success)
	d, success := divide(9, 0)
	fmt.Println(d, success)
}

func divide(a, b int) (result int, success bool) {
	if b == 0 {
		result = 0
		success = false
	} else {
		result = a / b
		success = true
	}
	return
}

// 3 true
// 0 false
```

이렇게 반환할 값이 여러개일 때 출력부에 변수를 정의하고 할당하고 반환할 수 있습니다. 이렇게 이름을 작성하면 return을 생략해야 합니다.

재귀호출입니다. 재귀호출은 자기자신을 호출하는 것을 의미합니다.

```go
package main

import (
	"fmt"
)

func main() {
	printNo(3)
}

func printNo(n int) {
	if n == 0 {
		return
	}
	fmt.Println(n)
	printNo(n - 1)
	fmt.Println("after", n)
}

// 3
// 2
// 1
// after 1
// after 2
// after 3
```

3 -> 2 -> 1 -> 2 -> 3 순서를 잘 보도록 합니다. Println 다음에 재귀호출하고 재귀호출이 끝나면 다시 Println 순서가 됩니다. 점점 내려갔다가 다시 올라오게 됩니다.

재귀함수에서 가장 주의할 점은 베이스 케이스 즉 종료조건이 중요합니다. 안 끝나면 무한합니다.

재귀호출하는데 함수는 결국에 메모리 일부를 활용하는데 메모리 공간은 유한한데 만약에 실수로 종료조건이 없는 함수는 메모리를 모두 채울 때까지 실행합니다. 물론 모던 프로그래밍 언어는 어느 콜스택 사이즈를 초과하면 중단시켜줍니다.

go는 자동증가되는 stack입니다. 특이합니다. 일부언어는 스택이 고정되어 있습니다. go는 자동 증가되기 때문에 메모리 고갈전까지 계속 증가합니다.
