# 정보 처리기사 준비하기 19일차

1일1커밋 무사고: 572일차

## 감사일기

1. ???

## todo

- [ ] 소프트웨어 1 ~ 5장
  - [ ] 오늘 시도 (85/156 = 54.48%, 19일 남음)
  - [ ] 3장 데이터베이스 구축
    - [x] 물리 데이터베이스 설계
      - [x] 데이터베이스 보안 - 접근 통제
      - [x] 데이터베이스 백업
      - [x] 스토리지
      - [x] 요약 읽기
    - [x] SQL 응용
      - [x] SQL의 개념
      - [x] DDL
      - [x] DCL
      - [x] DML
      - [x] DML - SELECT-1
      - [x] DML - SELECT-2
      - [x] DML - JOIN
      - [x] 요약 읽기
    - [ ] SQL 활용
      - [ ] 프로시저(Procedure)
      - [ ] 트리거(Triegger)
      - [ ] 사용자 정의 함수
      - [ ] DBMS 접속 기술
      - [ ] 요약 읽기
    - [ ] 데이터 전환
      - [ ] 데이터 전환
      - [ ] 데이터 전환 방안
      - [ ] 데이터 검증
      - [ ] 오류 데이터 측정 및 정재
      - [ ] 요약 읽기
  - [ ] 4장 프로그래밍 언어 활용
    - [ ] 서버 프로그램 구현
      - [ ] 서버 개발
      - [ ] 보안 API
      - [ ] 배치 프로그램
      - [ ] 요약 읽기
    - [ ] 프로그래밍 언어 활용
      - [ ] 데이터 타입
      - [ ] 변수
      - [ ] 연산자
      - [ ] 데이터 입출력
      - [ ] 제어문
      - [ ] 반복문
      - [ ] 배열과 문자열
      - [ ] 포인터
      - [ ] 구조체
      - [ ] Python의 기초
      - [ ] Python의 활용
      - [ ] 스크립트 언어
      - [ ] 라이브러리
      - [ ] 예외 처리
      - [ ] 요약 읽기
    - [ ] 응용 SW 기초 기술 활용
      - [ ] 운영체제의 개념
      - [ ] Windows
      - [ ] UNIX / LINIX / MacOS
      - [ ] 기억장치 관리의 개요
      - [ ] 가상기억장치 구현 기법 / 페이지 교체 알고리즘
      - [ ] 가상기억장치 기타 관리 사항
      - [ ] 프로세스의 개요
      - [ ] 스케줄링
      - [ ] 주요 스케줄링 알고리즘
      - [ ] 환경 변수
      - [ ] 운영체제 기본 명령어
      - [ ] 인터넷
      - [ ] OSI 참조 모델
      - [ ] 네트워크 관련 장비
      - [ ] TCP/IP
      - [ ] 요약 읽기
  - [ ] 5장 정보시스템 구축 관리
    - [ ] 소프트웨어 개발 방법론 활용
      - [ ] 소프트웨어 개발 방법론
      - [ ] S/W 공학의 발전적 추세
      - [ ] 상향식 비용 산정 기법
      - [ ] 수학적 산정 기법
      - [ ] 프로젝트 일정 계획
      - [ ] 소프트웨어 개발 방법론 결정
      - [ ] 소프트웨어 개발 표준
      - [ ] 소프트웨어 개발 방법론 테일러링
      - [ ] 소프트웨어 개발 프레임워크
      - [ ] 요약 읽기
    - [ ] IT프로젝트 정보 시스템 구축 관리
      - [ ] 네트워크 관련 신기술
      - [ ] 네트워크 구축
      - [ ] 경로 제어 / 트레픽 제어
      - [ ] S/W 관련 신기술
      - [ ] 보안 관련 신기술
      - [ ] HW 관련 신기술
      - [ ] Secure OS
      - [ ] DB 관련 신기술
      - [ ] 회복 / 병행제어
      - [ ] 교착상태
      - [ ] 요약 읽기
    - [ ] 소프트웨어 개발 보안 구축
      - [ ] Secure SDLC
      - [ ] 세션 통제
      - [ ] 입력 데이터 검증 및 표현
      - [ ] 보안 기능
      - [ ] 에러처리
      - [ ] 코드 오류
      - [ ] 캡슐화
      - [ ] 암호 알고리즘
      - [ ] 요약 읽기
    - [ ] 시스템 보안 구축
      - [ ] 서비스 공격 유형
      - [ ] 서버 인증
      - [ ] 보안 아키텍쳐 / 보안 프레임워크
      - [ ] 로그 분석
      - [ ] 보안 솔루션
      - [ ] 요약 읽기
  - [ ] 기출문제집
    - [ ] 1회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 2회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 3회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 4회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 5회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 6회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 7회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 8회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 9회
      - [ ] 문제 풀이
      - [ ] 오답노트
    - [ ] 10회
      - [ ] 문제 풀이
      - [ ] 오답노트
- [ ] 기본서 이후 기출 문제집 따로 구매하기
- [ ] 2024년 07월 25일 (목) 08:40 호서대학교 천안캠퍼스 1호관3층 CBT 3실(305호)에 정보처리기사 필기 시험 보기
- [ ] 블로그 6월 마이그레이션
- [ ] 플래시 카드 2.0 서비스 만들기
  - [ ] nuxt 설치
  - [ ] mongoose ORM 설치
  - [ ] vercel 배포
  - [ ] 로그인 구현
  - [ ] 어드민 전용기능(배치 삭제, 생성 제한)
  - [ ] 핀터레스트 레이아웃 구현
  - [ ] 문제 유형 태그 구현
  - [ ] 카나리 설정
- [ ] go 언어 공식문서 복습
  - https://go.dev/tour/methods/23
  - 메서드 지식문제가 아니라 인코딩 디코딩에 대한 지식이 없는 문제로 보입니다.
- [ ] go 언어 숫자야구
  - [ ] 난수 3개 생성
- [ ] go 언어 TDD 문서
- [ ] go 언어 블랙잭
- [ ] TIL-CLI 1.0.1
  - [ ] json 파일 다시 설정
  - [ ] 입력 설계
  - [ ] 테스트 설계
  - [ ] 입력 - 처리 - 출력 mvc 패턴 구축
  - [ ] 실행파일 별칭 지정
- [ ] neovim 회사에서 사용가능하게 만들기

---

- 퇴근하고 연속으로 며칠동안 정보처리시가 책만 봤습니다. 손으로 하는 동작은 무엇을 문제를 풀기 시작할 때 말고 없습니다.
  - 오늘은 자취방에서 소독을 기다리고 있었습니다. 밤에 늦게 잤습니다. 또 소독 기다리면서 정보처리기사 책을 보고 있는데 너무 졸려서 컴퓨터를 켰습니다.
  - 책을 읽으면 졸음이 오는 것은 일종의 장점이자 단점입니다. 잠을 유도하고 싶을 때는 상당히 유용합니다. 문제는 실제로 학습해야 하는 상황에서는 유용하지 않습니다. 
    - 책을 읽으면서 아무런 동작이 없어서 졸리다는 것을 알고 있습니다. 필기하고 문제 풀고 암기할 플래시카드를 중간중간 만드는 활동이 잠을 깨기 유리하게 만드는 것 같습니다.
  - 프로그래밍을 공부할 때도 동일합니다. 공식문서를 그냥 읽는 것보다 예제를 직접 실행하고 풀어보면서 학습하게 됩니다.
- 요즘 드는 생각은 코드 가독성입니다. 코드의 계층과 관심사 분리입니다. 개별상태를 그냥 바꾸기만 합니다. 언제 어느 흐름과 비즈니스 로직 때문에 바꾸는지 코드베이스에서 추적하기 어려운 부분이 있습니다. `getter`랑 `setter`를 직접 사용하지 말라는 말이 이해됩니다.
  - 동료 개발자 중 1명이 타입스크립트를 사용하는데 `any`를 너무 많이 사용합니다. 굳이 따지면 그냥 객체이고 키랑 값이 있는데 정의를 너무 안 했습니다.
    - 코드를 나중에 유지보수해야 하는 관점에서 해당하는 상태 안에 무슨 속성이 있는지 `console.log`를 찍으면서 알아내야 했습니다. 
    - 타입정의가 없으면서 무슨 값, 생태를 담고 표현하려고 했는지 알아내는데 노력이 너무 많이 듭니다.
    - 어떤 경우에는 원래 객체를 담고 있던 타입인데 문자열로 바꾸는 경우도 있었습니다.
    - 필요한 것은 `any`를 사용하면 왜 `any`를 사용할 수 밖에 없었는지 설명을 달도록 하는 것이 더 쉬울 것 같습니다.
  - 플래그 변수를 사용할지 문자열 리터럴로 `enum`을 흉내낼지 결정을 잘해야 합니다.
    - 상태가 2가지라는 이유 때문에 부울을 사용하기 보단 상태가 명시적이라면 그 이름을 사용해서 문자열 리터럴이 더 유리합니다.
    - 문자열 리터럴을 사용하면 나중에 사용할 수 있는 패턴들이 있습니다.
      - 현재 상태를 기준으로 처리할 전략패턴을 사용할 수 있습니다.
      - 유한상태기계 패턴으로 변환도 가능합니다. 어떻게 언제 무엇으로 상태가 바뀔지 유한하게 설계하고 예측가능하게 관심사를 몰아버리는 전략입니다.
  - 너무 많은 계층은 가독성을 해칩니다. 하지만 일반적으로 UI - State - API 계층으로 분리하는게 익숙한 것 같습니다. 이거는 취향문제도 있는 것 같습니다.
    - 백엔드는 최소한 논리적으로 상태가 없습니다. UI도 무상태에 가까울수록 좋고 지역으로 최대한 격리될수록 관리가 쉽습니다.
    - UI에서 발생하는 이벤트가 상태를 갱신하고 상태는 API를 간접호출하게 만드는 전략을 취할 수 있습니다.
      - 일반적인 비즈니스에서는 UI가 제일 많이 바뀝니다. 그리고 비즈니스 로직이 그다음으로 많이 바뀝니다. 하지만 백엔드 API와 관련된 변화는 덜합니다.
      - 이런 멘탈모델은 전통적은 MVC인데 클라이언트 사이드 위주입니다. 이런 설계는 페이지 단위로 실천하기 쉽습니다.
      - 당연히 한계가 있습니다. 일부는 UI에서 발생하는 이벤트가 API를 호출해야 하는 경우들이 있기 때문입니다. 저는 UI 관점에서는 데이터를 채워라 그리고 API 관점에서는 서버에 요청해라 라는 각각 다른 생각을 하면서 작업을 하고 싶습니다. 
  - 회사에서는 데이터가 많고 많은 데이터를 보여주기 때문에 굉장히 많은 비즈니스 로직을 갖고 있는 컴포넌트가 있습니다.
    - 이런 경우는 꽤 흔합니다. 하지만 결론을 못찾았습니다. 결론이라기 보단 해보고 싶은 시도가 있습니다. 그리고 코드 개선에 효과적이라면 알려주는 것이 유리하다고 봅니다. 의존성 주입 패턴을 활용할 방법이 없는지 의문입니다. vue에서는 `provide`, `inject` 를 지원하는데 분명 의존성 주입용도 인 것을 알겠습니다. 지금 회사에서는 상태관리 목적으로 사용을 하고 있습니다. IoC 목적이 아닙니다. 제어를 역전시키기 위해 추상화를 하고 매개변수화하고 주입하는 전략을 모르겠습니다.
    - 주입받을 구체적인 인터페이스부터 정의해야 하는데 아직 못하고 있습니다.
    - 비즈니스 로직이 너무 거대해서 관심사별로 적당한 분리가 필요한 상황입니다.
    - 의존성 주입의 문제는 컨텍스트에 따라 각각 다르게 주입해야 하는데 이 거대한 비즈니스 로직은 그냥 거대하기만 합니다.
  - 코드 그자체가 비즈니스 가치를 창출하지는 않습니다. 코드를 통해 제품이 유저에게 전달되고 유저가 문제를 해결하면서 얼마까지 낼 의향이 있는지 얼마나 유용했는지가 코드의 가치를 정합니다.
    - 너무 재무적인 가치 위주로 생각하기는 했지만 회사입니다. 재무적인 가치로 생각했다고 순현재가치법(NPV)이나 내부수익률법(IRR) 같은 계산법은 적용할 수 없습니다.
    - 비교적 단순한 기능을 추가하려는데 코드베이스의 특정 부분이 아주 복잡한 경우도 있습니다. 이렇게 보면 개발자가 하는 리팩토링의 가치는 상당히 큽니다. 버그를 쉽게 찾고 고치거나 기능을 추가하기 유리한 구조로 코드를 작성해야 합니다.
    - 좋은 코드의 기준 중 하나는 만약에 버그가 발생한다면 어디서 찾을 수 있을지 예측이 쉬운 코드가 좋은 코드 같습니다.
    - 또 다른 좋은 코드의 기준은 변화에 견고한 코드가 좋은 코드 같습니다. 변화에 취약해서 발생하는 버그를 잘 방지할 수 있어야 합니다.
      - CSS도 공통으로 사용하는 요소가 변화하면 최대한 변수화해서 변하는 대상과 같이 변해서 발생가능성을 차단해야 합니다.
- 문제해결이라는 것을 프로그래머의 뇌에서 설명해줬습니다. 의외의 자료입니다.
  - 문제인 현재 상태와 해결인 상태를 정의하고 그 상태가 되게 만드는 여러 경로를 선택하고 수행을 잘하는 것을 보고 문제해결력이라고 볼 수 있습니다. 개발자가 좋아하는 구체적이고 작업 분해를 시도해볼만한 정의입니다. 
  - 이런 관점으로 생각해보면 무엇이 현재 문제인가? 이 정의부터 출발해볼 수 있습니다. 
  - 도달하고자 하는 것이 무엇인지 구체적이라 좋습니다. 도달해야 하는 이유가 비즈니스에서 정의를 잘 했는지 생각해보고 비즈니스 로직을 구현해야 합니다.
- 회사에서는 소프트스킬과 테크니컬한 스킬을 효과적으로 조합하는 것이 중요합니다.
  - 먼제 git & github로 소스관리할 때 전략입니다. 이런 부분은 개발자와 개발자 사이 협업 스킬과 테크니컬 스킬의 조합입니다.
  - 예전에는 소스를 공유하는 수준이었습니다. `commit`, `push`, `pull` 정도 였습니다.
  - 지금은 rebase를 사용하고 필요하면 스쿼시, 채리픽, undo 등 명령을 같이 사용합니다. 가끔은 rebase로 브랜치 이동을 할 때 같이 오는 브랜치의 커밋들을 drop 하기도 합니다. 커밋도 코드의 부분으로 보고 제어를 잘 해야 합니다.
    - 극단적으로는 롤빽을 가정하고 최종적으로 어떤 커밋을 남길지 설계하는 것도 방법입니다. 이렇게까지 코드 작성이 예측가능한 경우는 굉장히 드뭅니다.
  - merge conflict 가 발생하면 git blame 을 잘 확인해봐야 합니다. 그리고 blame과 관련있는 사람이랑 모여서 해결해야 합니다.
  - 회사 비즈니스 도메인 지식을 잘 알아야 합니다. 그래야 코드 작성을 할 때 비즈니스 로직을 표현하려면 비즈니스 도메인 지식이 풍부해야 합니다. 회사에 합격한 시점부터 시작해도 괜찮고 본인의 효과적인 학습 노하우를 갖고 있어야 합니다.
  - 글쓰기는 도구입니다. 사람은 생각을 하고 글을 쓰고 글을 써서 생각을 합니다. 이런 루프를 통해서 무엇을 알고 모르고를 정리합니다. 이런 생각하는 과정을 관련 문서에 기록해두면 나중에 다시 볼 일이 있을 때 아주 가끔은 도움됩니다.
  - 제안하기는 성장을 위해 필요한 행동입니다. 신입일수록 어떤 문제가 보이고 이 문제를 해결할 때 제안을 먼저 시도해보고 잘못된 생각이라는 것을 학습하는 과정을 겪어야 합니다. 이 것이 잘못되었다는 것을 학습하기 위해서는 시켜서 하지말고 제안을 먼저 해보고 본인의 제안이 이상한 부분이 무엇인지 설명을 들어볼 수 있어야 합니다.
    - 제안을 하면서 무엇이 문제인지 인식해보고 정의를 해보는 것부터 연습할 수단입니다.
    - 모든 것을 제안할 필요는 없습니다. 시급성으로 문제가 있어보이는 부분은 바로 말하면 됩니다.

