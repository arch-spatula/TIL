# 블로드 다시 만들기 6일차

1일1커밋 무사고: 937일차

## 감사일기

1. ???

- [x] 주간회고
- [ ] ~~책상 구매~~
  - 오늘의 집 책상 보던 것으로 하면 될 것 같습니다.
- [ ] 블로그 다시 만들기 전 실험
  - [ ] 블로그 글 작성 준비
  - [x] `data.json`으로 런타임에 공유할 데이터 파일 만들기
- [ ] 데이터 시각화 옵시디언으로 마이그레이션
  - [ ] 비중
    - [ ] 100% 누적 막대 차트(Proportional stacked bar chart)
    - [ ] 게이지 차트(Gauge Chart)
    - [ ] 와플 차트(Waffle Chart, Grid plot, Unit chart, Square pie)
    - [ ] 트리맵(Treemap)
    - [ ] 계층형 트리맵(Nested Treemap)
    - [ ] 서클 패킹(Circle packing)
    - [ ] 선버스트 차트(Sunburst Chart, Mulit-level Pie chart, Radial Treemap, Adjacency diagram, icicle chart)
    - [ ] 히스토그램(Histogram)
    - [ ] 점 나열 차트(Dot Strip Plot, Strip Plot)
    - [ ] 상자 수염 그림(Box and Whisker plot, Box plot)
  - [ ] 관계
    - [ ] 산점도(Scatter plot)
    - [ ] 버블 차트(Bubble chart)
    - [ ] 평행 좌표(Parallel Coordinates)
    - [ ] 생키 다이어그램(Sankey diagram, Alluvial diagram)
    - [ ] 패러럴 셋(Parallel Sets)
    - [ ] 코드 다이어그램(Chord Diagram, Radial network diagram)
    - [ ] 네트워크 시각화(social network diagram)
  - [ ] 위치
    - [ ] 점 밀집도(Dot Density map, Dot Distribution map, Location map, Dot map)
    - [ ] 도형표현도(Symbol map, Proportional symbol map, Graduated symbol map)
    - [ ] 단계 구분도(Field map, Choropleth map)
    - [ ] 히트 맵(Heat map)
    - [ ] 등고선 지도(Contour map, lsarithmic map, Isochrone map, Isopleth map)
    - [ ] 연결 지도(Connection map, Link map)
    - [ ] 이동 경로 지도(Route map)
    - [ ] 흐름 지도(Flow map)
    - [ ] 카토그램(Cartogram)
    - [ ] 돌링 카토그램(Dorling Cartogram, Dorling map)
    - [ ] 타일 격자 지도(Tile Grid map, Grid map, Equal-area cartogram)

---

## 주간 회고

### Liked

- 회사 업무가 아니라 개인프로젝트로 의미있는 탐구를 해볼 수 있었습니다.
  - 최소한 혼자서는 의미가 있었다고 생각이 됩니다.

### Learned

- vite만 활용하면서 블로그를 다시 만들어보고 있습니다.
  - 프론트엔드 프레임워크와 빌드 툴의 의미를 다시 생각해볼 수 있었습니다.
  - 프론트엔드 프레임워크는 결국 작성한 것을 html, css, js로 빌드를 해야 하는데 vite의 플러그인 라이프사이클과 빌드 및 번들링을 처리해주는 툴을 활용해야 합니다.
  - vite는 어떤 측면에서는 번들러를 더 추상적으로 다룰 수 있게 해주는 툴입니다.
    - 직접 다루기에 직관적이니 못한 부분들에 대해서 대신 처리하고 추상화를 해주고 있습니다.
- 책상 구매가 필요 없을 것 같습니다.
  - 책상이 좁기는 하지만 너무 많은 물건을 갖고 있는 문제를 제가 갖고 있습니다.

### Lacked

- 업무적으로는 부족하고 개인적으로는 남는 이번주였습니다.

### Longed(잘하기 위해 필요한 것)

- 저녁은 서브웨이 아니면 샐러디에서 먹어야 할 것입니다.
  - 이번주에 대안이 있다는 것을 스스로 상기해야 합니다.


### Action Item

- [ ] 블로그 다시 만들기 전 실험
  - [ ] 블로그 글 작성 준비
  - [ ] 공통 html로 한번 감싸
- [ ] 데이터 시각화 옵시디언으로 마이그레이션
  - [ ] 비중
    - [ ] 100% 누적 막대 차트(Proportional stacked bar chart)
    - [ ] 게이지 차트(Gauge Chart)
    - [ ] 와플 차트(Waffle Chart, Grid plot, Unit chart, Square pie)
    - [ ] 트리맵(Treemap)
    - [ ] 계층형 트리맵(Nested Treemap)
    - [ ] 서클 패킹(Circle packing)
    - [ ] 선버스트 차트(Sunburst Chart, Mulit-level Pie chart, Radial Treemap, Adjacency diagram, icicle chart)
    - [ ] 히스토그램(Histogram)
    - [ ] 점 나열 차트(Dot Strip Plot, Strip Plot)
    - [ ] 상자 수염 그림(Box and Whisker plot, Box plot)
  - [ ] 관계
    - [ ] 산점도(Scatter plot)
    - [ ] 버블 차트(Bubble chart)
    - [ ] 평행 좌표(Parallel Coordinates)
    - [ ] 생키 다이어그램(Sankey diagram, Alluvial diagram)
    - [ ] 패러럴 셋(Parallel Sets)
    - [ ] 코드 다이어그램(Chord Diagram, Radial network diagram)
    - [ ] 네트워크 시각화(social network diagram)
  - [ ] 위치
    - [ ] 점 밀집도(Dot Density map, Dot Distribution map, Location map, Dot map)
    - [ ] 도형표현도(Symbol map, Proportional symbol map, Graduated symbol map)
    - [ ] 단계 구분도(Field map, Choropleth map)
    - [ ] 히트 맵(Heat map)
    - [ ] 등고선 지도(Contour map, lsarithmic map, Isochrone map, Isopleth map)
    - [ ] 연결 지도(Connection map, Link map)
    - [ ] 이동 경로 지도(Route map)
    - [ ] 흐름 지도(Flow map)
    - [ ] 카토그램(Cartogram)
    - [ ] 돌링 카토그램(Dorling Cartogram, Dorling map)
    - [ ] 타일 격자 지도(Tile Grid map, Grid map, Equal-area cartogram)

--- 

## `data.json`을 처리해보자

- ~~그만 처리하자~~
- https://github.com/arch-spatula/new-blog-2025/issues/5 이번에는 여기 이슈를 처리해볼 것입니다.
- 이 `data.json`은 글 목록을 저장한 `json` 파일에 불과합니다.
  - 하지만 이 `data.json`에 불과한 이 파일 하나가 요긴하게 사용할 계획입니다.
  - 블로그 루트에서 전체 개발자 블로그 목록을 확인하기 위한 데이터 입니다.
  - `ctrl` + `k`를 눌러 검색을 활성화하면 색인을 위해 활용할 데이터입니다.
  - 목록과 검색 색인 2가지를 위해 접근 가능해야 하기 때문에 `public` 루트에 넣어둘 것입니다.
  - 실제 내용은 자주 바뀌기 때문에 `.gitignore` 해둘 것입니다.

```md
---
title: "My Blog Post"
date: "2025-07-05"
tags: ["vite", "markdown"]
---

# 안녕하세요

이 문서는 테스트용입니다.
```

- 제가 위 형식을 활용한다면 제가 추출하려는 것을 보고 yaml 형식이라고 하는 것 같습니다.
- vite 플러그인이 있다고 하지만 저의 최소 의존성 원칙을 준수하기 위해 활용하지 않을 것입니다.
- 줄의 순서는 자유로운데 각 키별로 자유롭게 처리하고자 할 것입니다.
- fallback 로직들도 어느정도 처리해야 할 것 같습니다. 
  - 하지만 이 부분은 후순위로 처리하고자 합니다.
  - `<h1>` 태그 역할을 할 title은 1개만 존재해야 합니다. 블로그에서 작성해도 삭제하는 것은 너무 많은 마법일지 의문이기는 합니다.
  - 저는 저의 개발자 블로그에서 SEO는 후순위입니다. 브라우저의 검색 조건을 탐구해보는 것은 프론트엔드, 그로스해커, 퍼포먼스 마케터로서 가치가 있을 것입니다.

```ts 
const markdownToMeta = async (markdownSource: string) => {
  /**
   * ---
   * title: "My Blog Post"
   * date: "2025-07-05"
   * tags: ["vite", "markdown"]
   * ---
   *
   * # foo
   *
   * - hello foo
   *
   *   위에서 `---\n` 부터 `---\n`까지 사이 텍스트를 선택할 때 활용함.
   */
  const frontMatterRegex = /^---\n([\s\S]*?)\n---\n?/;

  const match = markdownSource.match(frontMatterRegex);

  /**
   * `---\n`, `---\n` 사이에 메타 정보를 작성할 것을 준수함.
   */
  if (match) {
    const metaDataString = match[1]; // YAML 부분 (string)
    const result = { title: "" } satisfies MetaObject;

    for (const metaData of metaDataString.split("\n")) {
      const [key, value] = metaData.split(":");

      switch (key.trim()) {
        case "title":
          /**
           * 3가지 경우의 수가 있음.
           * `"`으로 시작하면 "으로 끝나야함.
           * `'`으로 시작하면 '으로 끝나야함.
           * `"`, `'` 2가지 중 1개 도 없으고 빈 문자열이 아니면 추가함
           * 허용할 수 없는 형태면 제목을 추가하지 않음.
           */
          const title = value.trim();
          // console.log(title.startsWith('"') && title.endsWith('"'));
          if (title.startsWith('"') && title.endsWith('"')) {
            const frontMatterRegex = /^"([\s\S]*?)"/;
            const match = title.match(frontMatterRegex);
            if (match) {
              console.log(match[1]);
            }
          }

          if (title.startsWith("'") && title.endsWith("'")) {
            const frontMatterRegex = /'([\s\S]*?)'/;
            const match = title.match(frontMatterRegex);
            if (match) {
              console.log(match[1]);
            }
          }

          // console.log({ value: value.trim() });
          break;
        case "date":
          console.log({ value: value.trim() });
          break;
        case "tags":
          console.log({ value: JSON.parse(value) });
          break;
        case "draft":
          console.log({ value: value.trim() });
          break;

        default:
          console.warn("허용한 하지 않은 키입니다.");
          break;
      }
    }
    // const content = markdownSource.slice(match[0].length); // 나머지 markdown content
  }
  /**
   * - `---\n`, `---\n` 사이에 메타 정보 작성 안해도 제목은 작성함.
   * - ``# 이런저런 제목\n` 같은 형식을 찾아보고 title로 간주함.
   */

  /**
   * 제목도 작성 안 하는 막장은 굳이 보여주지 않음.
   * 콘솔에 경고 보여주고 다음 파일로 넘어가도록 함.
   */
};
```

- 처음 시작한 로직은 위와 같습니다.
- 생각을 더해보니 결국 json으로 변환해서 저장이 가능해야 한다면 그냥 json 변환 가능여부 정도 체크하면 될 것 같습니다.
  - 공백 문자는 처리해야 하지만 당장 중요한 관심사인가?
    - 저의 답은 json 저장이 가능한 형태로 전환하고 의도에 맞는 형태로 저장 되어야 합니다.
