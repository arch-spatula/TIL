# 개발자 블로그 6일차

1일1커밋 무사고: 480일차

## 감사일기

1. warp에 감사합니다. 마크다운으로 문서화된 코드 스니펫을 드라이브에 저장하고 꺼내 쓸 수 있게 되었습니다. 자주 찾는 커맨드는 더 쉽고 빠르게 찾을 수 있게 되었습니다. 

## todo

- 개발자 블로그
  - [ ] C 언어 숫자 야구 CLI DIY-CS에 추가
    - [ ] 버퍼를 수동으로 비우도록 설계한 이유는 무엇인가?
      - [ ] `scanf`의 동작 원리는 무엇인가?
    - [ ] `fgets`란 무엇인가?
      - [ ] 자료 찾기
      - [ ] 함수의 목적은 무엇인가?
      - [ ] 스트림이란 무엇인가?
- [ ] 블랙잭 만들기
- [ ] 정보처리 기사 문제집 기본서 시작하기
- [ ] 이력서 24년 2분기 작성
  - [ ] 레이아웃 구성
  - [ ] 경력 기술서
  - [ ] PDF 출력
- [ ] 4월 기술 블로그 소재 2개
- [ ] 5월 기술 블로그 소재 2개
- [ ] 6월 기술 블로그 소재 2개
- [ ] 정보처리 기사 문제집 기본서 시작하기
  - [ ] 소프트웨어 1 ~ 5장
  - [ ] 2024.06.18. 필기 원서 접수
  - [ ] 기본서 이후 기출 문제집 따로 구매하기
- [ ] 4장. 연산자 - 기본
  - [x] 4.1. 산술 연산자
    - [x] 4.1.1. 덧셈, 뺄셈 연산자
    - [x] 4.1.2. 이형자료 간의 연산 및 형승격
    - [x] 4.1.3. 곱셈, 나눗셈 연산자
    - [x] 4.1.4. 나머지 연산자
  - [ ] 4.2. 대입 연산자
    - [x] 4.2.1. 단순 대입 연산자
    - [ ] 4.2.2. 복합 대입 연산자
  - [ ] 4.3. 형변환 연산자
  - [ ] 4.4. 단항 증감 연산자
  - [ ] 4.5. 비트 연산자
    - [ ] 4.5.1. 비트 연산자의 사용
    - [ ] 4.5.2. 마스크 연산
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 5장. 연산자 - 응용
  - [ ] 5.1. sizeof 연산자
  - [ ] 5.2. 관계 연산자
  - [ ] 5.3. 논리 연산자
    - [ ] 5.3.1. 논리합(OR)과 논리곱(AND)
    - [ ] 5.3.2. 부정
    - [ ] 5.3.3. 쇼트서킷
  - [ ] 5.4. 조건 연산자(삼항 연산자)
  - [ ] 5.4.1. 최댓값 구하기
  - [ ] 5.4.2. 최댓값 구하기 방식 비교
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 6장. 기본 제어문
  - [ ] 6.1. if문
  - [ ] 6.1.1. 기본 구조
  - [ ] 6.1.2. 제어문과 스코프
  - [ ] 6.2. if else문
  - [ ] 6.2.1. 기본구조
  - [ ] 6.2.2. 중첩된 제어문
  - [ ] 6.2.3. 식별자 검색순서(스코프의 중첩)
  - [ ] 6.3. 다중 if문
  - [ ] 6.4. switch-case문
  - [ ] 6.5. goto문
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 7장. 반복문
  - [ ] 7.1. while - 조건 기반 반복문
  - [ ] 7.1.1. 기본구조 조건에 의한 제어
  - [ ] 7.1.2. 무한루프
  - [ ] 7.1.3. 반복문 내부에 선언한 자동변수
  - [ ] 7.1.4. 반복문의 중첩
  - [ ] 7.2. for, 계수 기반 반복문
  - [ ] 7.2.1. while문과 비교
  - [ ] 7.2.2. '\*'를 이용한 도형출력 실습
  - [ ] 7.3. do while문
  - [ ] 7.4. break와 continue
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 8장. 배열
  - [ ] 8.1. 1차원 배열의 기본 문법
  - [ ] 8.2. 최댓값/최솟값
  - [ ] 8.3. 문자의 배열
  - [ ] 8.3.1. 문자열의 기본 구조
  - [ ] 8.3.2. 문자열의 끝이 '\0'인 이유
  - [ ] 8.4. 다차원 배열
  - [ ] 8.4.1. 2차원 배열의 기본 문법
  - [ ] 8.4.2. 3차원 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 9장. 배열을 활용한 프로그래밍 기법
  - [ ] 9.1. 배열 요소의 정렬
  - [ ] 9.1.1. 선택정렬로 알려진 버블정렬
  - [ ] 9.1.2. 버블정렬
  - [ ] 9.1.3. 선택정렬
  - [ ] 9.2. 배열과 교차의 구현
  - [ ] 9.3. 달팽이 배열 채우기
  - [ ] 9.4. Lookup 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 10장. 함수에 대한 기본 이론
  - [ ] 10.1. 사용자 정의 함수의 선언 및 정의
  - [ ] 10.1.1. 매개변수
  - [ ] 10.1.2. 반환 자료형
  - [ ] 10.2. 두 가지 함수 설계 원칙
  - [ ] 10.2.1. UI와 기능의 분리
  - [ ] 10.2.2. 재사용 가능한 단위 기능의 구현
  - [ ] 10.3. 코드 분할
  - [ ] 10.3.1. 함수의 원형 선언
  - [ ] 10.3.2. 전역변수
  - [ ] 10.3.3. 전역변수와 식별자 검색 순서
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 11장. 메모리와 포인터
  - [ ] 11.1. 컴퓨터와 메모리
  - [ ] 11.1.1. 메모리의 종류
  - [ ] 11.1.2. 포인터 변수의 선언 및 정의
  - [ ] 11.1.3. 포인터와 배열
  - [ ] 11.2. 메모리 동적 할당 및 관리
  - [ ] 11.2.1. 메모리 초기화 및 사용(배열)
  - [ ] 11.2.2. 메모리 복사
  - [ ] 11.2.3. 메모리 비교(memcmp( ), strcmp( ))
  - [ ] 11.2.4. 문자열 검색
  - [ ] 11.2.5. 배열 연산자 풀어쓰기
  - [ ] 11.2.6. realloc( ), sprintf( ) 함수
  - [ ] 11.3. 잘못된 메모리 접근
  - [ ] 11.4. 포인터의 배열과 다중 포인터
  - [ ] 11.4.1. char\*의 배열
  - [ ] 11.4.2. 다중 포인터
  - [ ] 11.4.3. 다차원 배열에 대한 포인터
  - [ ] 11.5. 변수와 메모리
  - [ ] 11.5.1. 정적변수 static
  - [ ] 11.5.2. 레지스터 변수 register
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 12장. 함수 응용
  - [ ] 12.1. 매개변수 전달 방법
  - [ ] 12.1.1. Call by value
  - [ ] 12.1.2. Call by reference
  - [ ] 12.2. 스택 프레임 그리는 방법
  - [ ] 12.3. 재귀호출
  - [ ] 12.3.1. 재귀호출을 이용한 문자열 출력
  - [ ] 12.3.2. 재귀호출의 장/단점
  - [ ] 12.4. 문자/문자열 처리 함수
  - [ ] 12.4.1. 문자 처리 함수
  - [ ] 12.4.2. 문자열 처리 함수
  - [ ] 12.4.3. 유니코드 문자열
  - [ ] 12.5. 유틸리티 함수
  - [ ] 12.5.1. atoi( ), atol( ), atof( ) 함수
  - [ ] 12.5.2. time( ), localtime( ), ctime( ) 함수
  - [ ] 12.5.3. srand( ), rand( ) 함수
  - [ ] 12.5.4. system( ), exit( ) 함수
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 13장. 구조체와 공용체
  - [ ] 13.1. 구조체
  - [ ] 13.1.1. 구조체 선언 및 정의
  - [ ] 13.1.2. 구조체 동적 할당
  - [ ] 13.1.3. 반환자료, 매개변수 구조체
  - [ ] 13.1.4. 구조체를 멤버로 가지는 구조체
  - [ ] 13.1.5. 구조체 멤버 맞춤
  - [ ] 13.2. 비트필드
  - [ ] 13.3. 공용체
  - [ ] 연습문제
- [ ] 14장. 파일 입출력
  - [ ] 14.1. 파일 시스템 기본 이론
  - [ ] 14.1.1. 텍스트 파일과 바이너리 파일
  - [ ] 14.1.2. fopen( ), fclose( ) 함수
  - [ ] 14.2. 텍스트 파일 입출력
  - [ ] 14.2.1. fprintf( ), fscanf( ) 함수
  - [ ] 14.2.2. fgetc( ), fputc( ) 함수
  - [ ] 14.2.3. fgets( ), fgets_s( ), fputs( ) 함수
  - [ ] 14.2.4. fflush( ) 함수
  - [ ] 14.3. 바이너리 파일 입출력
  - [ ] 14.3.1. fread( ), fwrite( ) 함수
  - [ ] 14.3.2. fseek( ), rewind( ), ftell( ) 함수
  - [ ] 14.3.3. 기타 알아 두면 좋은 함수
  - [ ] 연습문제
- [ ] 15장. 변수와 상수 고급 이론
  - [ ] 15.1. 형한정어
  - [ ] 15.1.1. const
  - [ ] 15.1.2. 상수형 포인터
  - [ ] 15.1.3. 심볼릭 상수를 만드는 또 다른 방법
  - [ ] 15.1.4. volatile
  - [ ] 15.2. extern 외부변수 선언
  - [ ] 15.3. 형 재선언
  - [ ] 15.4. 열거형 상수
  - [ ] 연습문제
- [ ] 16장. 전처리기
  - [ ] 16.1. `#include`
  - [ ] 16.2. 매크로
  - [ ] 16.2.1. `__inline` 함수와 메크로
  - [ ] 16.2.2. 매크로 특수화 연산자 `#`, `##`
  - [ ] 16.3. 조건부 컴파일
  - [ ] 연습문제
- [ ] 17장. 함수에 대한 고급 이론
  - [ ] 17.1. 성능 향상을 위한 이론
  - [ ] 17.1.1. 컴파일러 최적화
  - [ ] 17.1.2. `__inline 함수`
  - [ ] 17.2. 함수 호출 규칙
  - [ ] 17.2.1. `__cdecl`
  - [ ] 17.2.2. `__stdcall`
  - [ ] 17.2.3. `__fastcall`
  - [ ] 17.3. 함수 포인터와 역호출 구조
  - [ ] 17.3.1. 함수 포인터
  - [ ] 17.3.2. 역호출 구조
  - [ ] 17.4. 정적 라이브러리의 구현
  - [ ] 17.4.1. 라이브러리 프로젝트 생성
  - [ ] 17.4.2. 헤더파일의 구성
  - [ ] 17.4.3. 정적 라이브러리 사용하기
  - [ ] 17.5. 가변인자 사용하기
  - [ ] 연습문제

---

## 버퍼를 수동으로 비우도록 설계한 이유는 무엇인가?

입출력장을 읽어도 결국 답을 얻을 수 없습니다.

버퍼 메모리에 대한 유튜브 영상을 보고 동작원리를 하이레벨로 이해해도 C 언어가 버퍼 메모리를 수동으로 비우도록 설계한 의도는 알 수 없습니다.

---

휴대용 키보드와 영타연습 그리고 영단어 연습이 너무 필요합니다. 키보드 환경이 바뀐다고 자주 내는 오타를 너무많이 내고 있습니다.

영단어를 작성하면서 몰라서 생기는 문제도 너무 많습니다.

```vim 
" relative path
:let @+ = expand("%")

" full path
:let @+ = expand("%:p")

" just filename
:let @+ = expand("%:t")
```

vim에 이런 충격적인 명령들이 있습니다. 아마 이런 명령은 C 컴파일 명령이랑 연결할 수 있을 것 같습니다.

