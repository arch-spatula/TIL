# 개발자 블로그 10일차

1일1커밋 무사고: 484일차

## 감사일기

1. ???

## todo

- [ ] 블랙잭 만들기
  - [ ] 브랜치 만들기
  - [ ] 폴더 만들기
  - [ ] 핵심 파일 만들기
  - [ ] 비즈니스 로직 수도 코드로 작성하기
- [ ] 이력서 24년 2분기 작성
  - [ ] 레이아웃 구성
    - [ ] 목차 결정
    - [ ] 소제목 작성
  - [ ] 경력 기술서
  - [ ] PDF 출력
- [ ] 4월 기술 블로그 소재 2개
  - [ ] vue 오픈 소스 코드를 읽는 방법
  - [ ] vue에서 발생하는 특이한 랜더링 순서
- [ ] 5월 기술 블로그 소재 2개
  - [ ] LSP란 무엇인가?
  - [ ] ???
- [ ] 6월 기술 블로그 소재 2개
  - [ ] ???
  - [ ] ???
- [ ] 정보처리 기사 문제집 기본서 시작하기
  - [ ] 소프트웨어 1 ~ 5장
  - [ ] 2024.06.18. 필기 원서 접수
  - [ ] 기본서 이후 기출 문제집 따로 구매하기
- [ ] 6장. 기본 제어문
  - [ ] 6.1. if문
    - [ ] 6.1.1. 기본 구조
    - [ ] 6.1.2. 제어문과 스코프
  - [ ] 6.2. if else문
    - [ ] 6.2.1. 기본구조
    - [ ] 6.2.2. 중첩된 제어문
    - [ ] 6.2.3. 식별자 검색순서(스코프의 중첩)
  - [ ] 6.3. 다중 if문
  - [ ] 6.4. switch-case문
  - [ ] 6.5. goto문
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 7장. 반복문
  - [ ] 7.1. while - 조건 기반 반복문
    - [ ] 7.1.1. 기본구조 조건에 의한 제어
    - [ ] 7.1.2. 무한루프
    - [ ] 7.1.3. 반복문 내부에 선언한 자동변수
    - [ ] 7.1.4. 반복문의 중첩
  - [ ] 7.2. for, 계수 기반 반복문
    - [ ] 7.2.1. while문과 비교
    - [ ] 7.2.2. `*`를 이용한 도형출력 실습
  - [ ] 7.3. do while문
  - [ ] 7.4. break와 continue
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 8장. 배열
  - [ ] 8.1. 1차원 배열의 기본 문법
  - [ ] 8.2. 최댓값/최솟값
  - [ ] 8.3. 문자의 배열
    - [ ] 8.3.1. 문자열의 기본 구조
    - [ ] 8.3.2. 문자열의 끝이 `\0`인 이유
  - [ ] 8.4. 다차원 배열
    - [ ] 8.4.1. 2차원 배열의 기본 문법
    - [ ] 8.4.2. 3차원 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 9장. 배열을 활용한 프로그래밍 기법
  - [ ] 9.1. 배열 요소의 정렬
    - [ ] 9.1.1. 선택정렬로 알려진 버블정렬
    - [ ] 9.1.2. 버블정렬
    - [ ] 9.1.3. 선택정렬
  - [ ] 9.2. 배열과 교차의 구현
  - [ ] 9.3. 달팽이 배열 채우기
  - [ ] 9.4. Lookup 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 10장. 함수에 대한 기본 이론
  - [ ] 10.1. 사용자 정의 함수의 선언 및 정의
    - [ ] 10.1.1. 매개변수
    - [ ] 10.1.2. 반환 자료형
  - [ ] 10.2. 두 가지 함수 설계 원칙
    - [ ] 10.2.1. UI와 기능의 분리
    - [ ] 10.2.2. 재사용 가능한 단위 기능의 구현
  - [ ] 10.3. 코드 분할
    - [ ] 10.3.1. 함수의 원형 선언
    - [ ] 10.3.2. 전역변수
    - [ ] 10.3.3. 전역변수와 식별자 검색 순서
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 11장. 메모리와 포인터
  - [ ] 11.1. 컴퓨터와 메모리
    - [ ] 11.1.1. 메모리의 종류
    - [ ] 11.1.2. 포인터 변수의 선언 및 정의
    - [ ] 11.1.3. 포인터와 배열
  - [ ] 11.2. 메모리 동적 할당 및 관리
    - [ ] 11.2.1. 메모리 초기화 및 사용(배열)
    - [ ] 11.2.2. 메모리 복사
    - [ ] 11.2.3. 메모리 비교(`memcmp( )`, `strcmp( )`)
    - [ ] 11.2.4. 문자열 검색
    - [ ] 11.2.5. 배열 연산자 풀어쓰기
    - [ ] 11.2.6. `realloc( )`, `sprintf( )` 함수
  - [ ] 11.3. 잘못된 메모리 접근
  - [ ] 11.4. 포인터의 배열과 다중 포인터
    - [ ] 11.4.1. char\*의 배열
    - [ ] 11.4.2. 다중 포인터
    - [ ] 11.4.3. 다차원 배열에 대한 포인터
  - [ ] 11.5. 변수와 메모리
    - [ ] 11.5.1. 정적변수 static
    - [ ] 11.5.2. 레지스터 변수 register
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 12장. 함수 응용
  - [ ] 12.1. 매개변수 전달 방법
    - [ ] 12.1.1. Call by value
    - [ ] 12.1.2. Call by reference
  - [ ] 12.2. 스택 프레임 그리는 방법
  - [ ] 12.3. 재귀호출
    - [ ] 12.3.1. 재귀호출을 이용한 문자열 출력
    - [ ] 12.3.2. 재귀호출의 장/단점
  - [ ] 12.4. 문자/문자열 처리 함수
    - [ ] 12.4.1. 문자 처리 함수
    - [ ] 12.4.2. 문자열 처리 함수
    - [ ] 12.4.3. 유니코드 문자열
  - [ ] 12.5. 유틸리티 함수
    - [ ] 12.5.1. `atoi( )`, `atol( )`, `atof( )` 함수
    - [ ] 12.5.2. `time( )`, `localtime( )`, `ctime( )` 함수
    - [ ] 12.5.3. `srand( )`, `rand( )` 함수
    - [ ] 12.5.4. `system( )`, `exit( )` 함수
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 13장. 구조체와 공용체
  - [ ] 13.1. 구조체
    - [ ] 13.1.1. 구조체 선언 및 정의
    - [ ] 13.1.2. 구조체 동적 할당
    - [ ] 13.1.3. 반환자료, 매개변수 구조체
    - [ ] 13.1.4. 구조체를 멤버로 가지는 구조체
    - [ ] 13.1.5. 구조체 멤버 맞춤
  - [ ] 13.2. 비트필드
  - [ ] 13.3. 공용체
  - [ ] 연습문제
- [ ] 14장. 파일 입출력
  - [ ] 14.1. 파일 시스템 기본 이론
    - [ ] 14.1.1. 텍스트 파일과 바이너리 파일
    - [ ] 14.1.2. `fopen( )`, `fclose( )` 함수
  - [ ] 14.2. 텍스트 파일 입출력
    - [ ] 14.2.1. `fprintf( )`, `fscanf( )` 함수
    - [ ] 14.2.2. `fgetc( )`, `fputc( )` 함수
    - [ ] 14.2.3. `fgets( )`, `fgets_s( )`, `fputs( )` 함수
    - [ ] 14.2.4. `fflush( )` 함수
  - [ ] 14.3. 바이너리 파일 입출력
    - [ ] 14.3.1. `fread( )`, `fwrite( )` 함수
    - [ ] 14.3.2. `fseek( )`, `rewind( )`, `ftell( )` 함수
    - [ ] 14.3.3. 기타 알아 두면 좋은 함수
  - [ ] 연습문제
- [ ] 15장. 변수와 상수 고급 이론
  - [ ] 15.1. 형한정어
    - [ ] 15.1.1. `const`
    - [ ] 15.1.2. 상수형 포인터
    - [ ] 15.1.3. 심볼릭 상수를 만드는 또 다른 방법
    - [ ] 15.1.4. volatile
  - [ ] 15.2. extern 외부변수 선언
  - [ ] 15.3. 형 재선언
  - [ ] 15.4. 열거형 상수
  - [ ] 연습문제
- [ ] 16장. 전처리기
  - [ ] 16.1. `#include`
  - [ ] 16.2. 매크로
    - [ ] 16.2.1. `__inline` 함수와 메크로
    - [ ] 16.2.2. 매크로 특수화 연산자 `#`, `##`
  - [ ] 16.3. 조건부 컴파일
  - [ ] 연습문제
- [ ] 17장. 함수에 대한 고급 이론
  - [ ] 17.1. 성능 향상을 위한 이론
    - [ ] 17.1.1. 컴파일러 최적화
    - [ ] 17.1.2. `__inline 함수`
  - [ ] 17.2. 함수 호출 규칙
    - [ ] 17.2.1. `__cdecl`
    - [ ] 17.2.2. `__stdcall`
    - [ ] 17.2.3. `__fastcall`
  - [ ] 17.3. 함수 포인터와 역호출 구조
    - [ ] 17.3.1. 함수 포인터
    - [ ] 17.3.2. 역호출 구조
  - [ ] 17.4. 정적 라이브러리의 구현
    - [ ] 17.4.1. 라이브러리 프로젝트 생성
    - [ ] 17.4.2. 헤더파일의 구성
    - [ ] 17.4.3. 정적 라이브러리 사용하기
  - [ ] 17.5. 가변인자 사용하기
  - [ ] 연습문제

---

## 새로운 도구 말고 새로운 개념

일부러 언어를 제한할 이유는 많습니다. 제한을 안 두면 계속 새로운 언어를 찾아봅니다. 도구 측면에서도 계속 새로운 도구를 찾습니다. 제일 중요한 것은 개념입니다. 언어와 도구를 몇개로만 스스로 제한을 둬서 새로운 개념과 방법론을 찾는 습성이 들도록 바꿔야 합니다.

기술적이라는 것은 같습니다. AVL 트리, 레드 블렉 트리처럼 트리의 응용 개념을 잘 모릅니다. 이 개념들일 학습하는 습성과 성형을 길러야 합니다. 몇개만의 도구를 사용한다고 해도 엄청 잘 사용하기 위해서는 어느정도 제약을 둬야 합니다.

이런 이유로 최대한 C 언어를 통해 해결해야 합니다. C 언어를 통해 많은 문제를 풀어야 합니다. SLL, DLL 부터 B 플러스 트리를 검색 없이 구현이 가능해야 합니다.

해쉬도 자체적으로 구현이 가능해야 합니다.

C 언어를 이팩티브하게 사용하는 방법을 스스로 학습해야 합니다. 독서 자체도 좋은 방법이 될 것 같습니다.

## 엔지니어링은 문제해결

엔지니어에게는 다양한 도구를 갖고 있어야 합니다.

과학과 과학적 방법론도 디버깅 같은 상황에서 유용한 도구입니다. 개발의 증상을 분석하고 원인에 대해서 가설을 세우고 기각하는 방법은 일반적입니다. 물론 항상 되는 것은 아닙니다. 하지만 없는 경우보다는 수월합니다.

개발을 진행하면서 글쓰기가 생각을 정리하는데 도와주면 적극적으로 사용할 도구입니다. 디버깅하거나 기능을 추가하는데 생각을 정리하기 유용하면 과감히 활용하도록 합니다. 글을 써서 생각하고 생각하고 글을 쓰는데 그 루프 중간에 코드작성이 순서는 유동적이지만 부분으로 있어야 합니다.

프론트엔드 혹은 모바일처럼 UI를 다루는 개발 영역은 스크린샷을 적극적으로 활용하도록 합니다. 의도한 UI가 맞는지 스크린샷찍고 바뀐 부분 현재 이상한 부분을 표시합니다. 머릿속에 넣고 작업할 이유는 없습니다. 완료된 시점에 의도한 것이 맞는지 비교하면 됩니다. 개발자로서 버그를 덜 만들게 인지하는 능력을 늘려주면 과감히 사용할 도구입니다.

가끔 텍스트만으로 요구사항이 정의 되면 바로 개발해보기 전에 스스로 UI를 피그마로 만들어 볼 필요가 있습니다. 단순하더라도 어느정도 설계를 확실하게 할 수 있어야 합니다. 물론 UI 영역 특히 view, 페이지라고 말하는 영역은 자주 바뀌는 영역이라고 해도 자체적으로 설계하고 케이스를 가시적으로 볼 필요가 있습니다. 이렇게 된 이유는 팀 내에 PM, 디자이너의 요구사항 정의 리소스가 부족한 상황입니다. 핵심 의도를 갖고 가능한 자세하게 정의해야 한다는 생각을 갖고 있으면 괜찮은 비개발 IT 직군과 협업하는 것입니다. 핵심 의도를 파악이 가능하면 개발자로서 정의가 안 된 부분도 추론을 통해 제안이 가능해집니다.

