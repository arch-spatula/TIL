# 개발자 블로그 5일차

1일1커밋 무사고: 479일차

## 감사일기

1. ???

## todo

- 개발자 블로그
  - [ ] C 언어 숫자 야구 CLI DIY-CS에 추가
    - [ ] 버퍼를 수동으로 비우도록 설계한 이유는 무엇인가?
      - [ ] `scanf`의 동작 원리는 무엇인가?
    - [ ] `fgets`란 무엇인가?
      - [ ] 자료 찾기
      - [ ] 함수의 목적은 무엇인가?
      - [ ] 스트림이란 무엇인가?
- [ ] 블랙잭 만들기
- [ ] 정보처리 기사 문제집 기본서 시작하기
- [ ] 이력서 24년 2분기 작성
  - [ ] 레이아웃 구성
  - [ ] 경력 기술서
  - [ ] PDF 출력
- [ ] 4월 기술 블로그 소재 2개
- [ ] 5월 기술 블로그 소재 2개
- [ ] 6월 기술 블로그 소재 2개
- [ ] 정보처리 기사 문제집 기본서 시작하기
  - [ ] 소프트웨어 1 ~ 5장
  - [ ] 2024.06.18. 필기 원서 접수
  - [ ] 기본서 이후 기출 문제집 따로 구매하기
- [x] 3장
  - [x] 3.4. scanf( ) 함수
    - [x] 3.4.1. 정수 입력
    - [x] 3.4.2. 두 정수의 입력 및 구분
    - [x] 3.4.3. 문자 입력
    - [x] 3.4.4. 문자열 입력
  - [x] 모범답안과 해설
  - [x] 연습문제
- [ ] 4장. 연산자 - 기본
  - [ ] 4.1. 산술 연산자
    - [ ] 4.1.1. 덧셈, 뺄셈 연산자
    - [ ] 4.1.2. 이형자료 간의 연산 및 형승격
    - [ ] 4.1.3. 곱셈, 나눗셈 연산자
    - [ ] 4.1.4. 나머지 연산자
  - [ ] 4.2. 대입 연산자
    - [ ] 4.2.1. 단순 대입 연산자
    - [ ] 4.2.2. 복합 대입 연산자
  - [ ] 4.3. 형변환 연산자
  - [ ] 4.4. 단항 증감 연산자
  - [ ] 4.5. 비트 연산자
    - [ ] 4.5.1. 비트 연산자의 사용
    - [ ] 4.5.2. 마스크 연산
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 5장. 연산자 - 응용
  - [ ] 5.1. sizeof 연산자
  - [ ] 5.2. 관계 연산자
  - [ ] 5.3. 논리 연산자
    - [ ] 5.3.1. 논리합(OR)과 논리곱(AND)
    - [ ] 5.3.2. 부정
    - [ ] 5.3.3. 쇼트서킷
  - [ ] 5.4. 조건 연산자(삼항 연산자)
  - [ ] 5.4.1. 최댓값 구하기
  - [ ] 5.4.2. 최댓값 구하기 방식 비교
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 6장. 기본 제어문
  - [ ] 6.1. if문
  - [ ] 6.1.1. 기본 구조
  - [ ] 6.1.2. 제어문과 스코프
  - [ ] 6.2. if else문
  - [ ] 6.2.1. 기본구조
  - [ ] 6.2.2. 중첩된 제어문
  - [ ] 6.2.3. 식별자 검색순서(스코프의 중첩)
  - [ ] 6.3. 다중 if문
  - [ ] 6.4. switch-case문
  - [ ] 6.5. goto문
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 7장. 반복문
  - [ ] 7.1. while - 조건 기반 반복문
  - [ ] 7.1.1. 기본구조 조건에 의한 제어
  - [ ] 7.1.2. 무한루프
  - [ ] 7.1.3. 반복문 내부에 선언한 자동변수
  - [ ] 7.1.4. 반복문의 중첩
  - [ ] 7.2. for, 계수 기반 반복문
  - [ ] 7.2.1. while문과 비교
  - [ ] 7.2.2. '\*'를 이용한 도형출력 실습
  - [ ] 7.3. do while문
  - [ ] 7.4. break와 continue
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 8장. 배열
  - [ ] 8.1. 1차원 배열의 기본 문법
  - [ ] 8.2. 최댓값/최솟값
  - [ ] 8.3. 문자의 배열
  - [ ] 8.3.1. 문자열의 기본 구조
  - [ ] 8.3.2. 문자열의 끝이 '\0'인 이유
  - [ ] 8.4. 다차원 배열
  - [ ] 8.4.1. 2차원 배열의 기본 문법
  - [ ] 8.4.2. 3차원 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 9장. 배열을 활용한 프로그래밍 기법
  - [ ] 9.1. 배열 요소의 정렬
  - [ ] 9.1.1. 선택정렬로 알려진 버블정렬
  - [ ] 9.1.2. 버블정렬
  - [ ] 9.1.3. 선택정렬
  - [ ] 9.2. 배열과 교차의 구현
  - [ ] 9.3. 달팽이 배열 채우기
  - [ ] 9.4. Lookup 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 10장. 함수에 대한 기본 이론
  - [ ] 10.1. 사용자 정의 함수의 선언 및 정의
  - [ ] 10.1.1. 매개변수
  - [ ] 10.1.2. 반환 자료형
  - [ ] 10.2. 두 가지 함수 설계 원칙
  - [ ] 10.2.1. UI와 기능의 분리
  - [ ] 10.2.2. 재사용 가능한 단위 기능의 구현
  - [ ] 10.3. 코드 분할
  - [ ] 10.3.1. 함수의 원형 선언
  - [ ] 10.3.2. 전역변수
  - [ ] 10.3.3. 전역변수와 식별자 검색 순서
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 11장. 메모리와 포인터
  - [ ] 11.1. 컴퓨터와 메모리
  - [ ] 11.1.1. 메모리의 종류
  - [ ] 11.1.2. 포인터 변수의 선언 및 정의
  - [ ] 11.1.3. 포인터와 배열
  - [ ] 11.2. 메모리 동적 할당 및 관리
  - [ ] 11.2.1. 메모리 초기화 및 사용(배열)
  - [ ] 11.2.2. 메모리 복사
  - [ ] 11.2.3. 메모리 비교(memcmp( ), strcmp( ))
  - [ ] 11.2.4. 문자열 검색
  - [ ] 11.2.5. 배열 연산자 풀어쓰기
  - [ ] 11.2.6. realloc( ), sprintf( ) 함수
  - [ ] 11.3. 잘못된 메모리 접근
  - [ ] 11.4. 포인터의 배열과 다중 포인터
  - [ ] 11.4.1. char\*의 배열
  - [ ] 11.4.2. 다중 포인터
  - [ ] 11.4.3. 다차원 배열에 대한 포인터
  - [ ] 11.5. 변수와 메모리
  - [ ] 11.5.1. 정적변수 static
  - [ ] 11.5.2. 레지스터 변수 register
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 12장. 함수 응용
  - [ ] 12.1. 매개변수 전달 방법
  - [ ] 12.1.1. Call by value
  - [ ] 12.1.2. Call by reference
  - [ ] 12.2. 스택 프레임 그리는 방법
  - [ ] 12.3. 재귀호출
  - [ ] 12.3.1. 재귀호출을 이용한 문자열 출력
  - [ ] 12.3.2. 재귀호출의 장/단점
  - [ ] 12.4. 문자/문자열 처리 함수
  - [ ] 12.4.1. 문자 처리 함수
  - [ ] 12.4.2. 문자열 처리 함수
  - [ ] 12.4.3. 유니코드 문자열
  - [ ] 12.5. 유틸리티 함수
  - [ ] 12.5.1. atoi( ), atol( ), atof( ) 함수
  - [ ] 12.5.2. time( ), localtime( ), ctime( ) 함수
  - [ ] 12.5.3. srand( ), rand( ) 함수
  - [ ] 12.5.4. system( ), exit( ) 함수
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 13장. 구조체와 공용체
  - [ ] 13.1. 구조체
  - [ ] 13.1.1. 구조체 선언 및 정의
  - [ ] 13.1.2. 구조체 동적 할당
  - [ ] 13.1.3. 반환자료, 매개변수 구조체
  - [ ] 13.1.4. 구조체를 멤버로 가지는 구조체
  - [ ] 13.1.5. 구조체 멤버 맞춤
  - [ ] 13.2. 비트필드
  - [ ] 13.3. 공용체
  - [ ] 연습문제
- [ ] 14장. 파일 입출력
  - [ ] 14.1. 파일 시스템 기본 이론
  - [ ] 14.1.1. 텍스트 파일과 바이너리 파일
  - [ ] 14.1.2. fopen( ), fclose( ) 함수
  - [ ] 14.2. 텍스트 파일 입출력
  - [ ] 14.2.1. fprintf( ), fscanf( ) 함수
  - [ ] 14.2.2. fgetc( ), fputc( ) 함수
  - [ ] 14.2.3. fgets( ), fgets_s( ), fputs( ) 함수
  - [ ] 14.2.4. fflush( ) 함수
  - [ ] 14.3. 바이너리 파일 입출력
  - [ ] 14.3.1. fread( ), fwrite( ) 함수
  - [ ] 14.3.2. fseek( ), rewind( ), ftell( ) 함수
  - [ ] 14.3.3. 기타 알아 두면 좋은 함수
  - [ ] 연습문제
- [ ] 15장. 변수와 상수 고급 이론
  - [ ] 15.1. 형한정어
  - [ ] 15.1.1. const
  - [ ] 15.1.2. 상수형 포인터
  - [ ] 15.1.3. 심볼릭 상수를 만드는 또 다른 방법
  - [ ] 15.1.4. volatile
  - [ ] 15.2. extern 외부변수 선언
  - [ ] 15.3. 형 재선언
  - [ ] 15.4. 열거형 상수
  - [ ] 연습문제
- [ ] 16장. 전처리기
  - [ ] 16.1. `#include`
  - [ ] 16.2. 매크로
  - [ ] 16.2.1. `__inline` 함수와 메크로
  - [ ] 16.2.2. 매크로 특수화 연산자 `#`, `##`
  - [ ] 16.3. 조건부 컴파일
  - [ ] 연습문제
- [ ] 17장. 함수에 대한 고급 이론
  - [ ] 17.1. 성능 향상을 위한 이론
  - [ ] 17.1.1. 컴파일러 최적화
  - [ ] 17.1.2. `__inline 함수`
  - [ ] 17.2. 함수 호출 규칙
  - [ ] 17.2.1. `__cdecl`
  - [ ] 17.2.2. `__stdcall`
  - [ ] 17.2.3. `__fastcall`
  - [ ] 17.3. 함수 포인터와 역호출 구조
  - [ ] 17.3.1. 함수 포인터
  - [ ] 17.3.2. 역호출 구조
  - [ ] 17.4. 정적 라이브러리의 구현
  - [ ] 17.4.1. 라이브러리 프로젝트 생성
  - [ ] 17.4.2. 헤더파일의 구성
  - [ ] 17.4.3. 정적 라이브러리 사용하기
  - [ ] 17.5. 가변인자 사용하기
  - [ ] 연습문제

---

문서를 작성하면 PR도 그렇고 본인이 작업하는 과정을 작성하든 다른 사람에게 어떤지 피드백을 받아보도록 합니다. 스크린샷이 오히려 혼선을 만들고 영상 녹화가 너무 무거운지 확인해야 합니다.

매번 자주 받을 필요는 없습니다. 하지만 한달에 한번 분기에 한번 정도 피드백은 수집해볼 필요는 있습니다.
