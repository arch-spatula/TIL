# 개발자 블로그 8일차

1일1커밋 무사고: 482일차

## 감사일기

1. 내일이 어머니 생일이라는 것이 감사합니다. 오늘 맛있는 저녁 식사를 할 수 있었습니다.

- [x] 주간회고
- [x] 주간 줍줍
- 개발자 블로그
  - [ ] 개발자 밈
    - [ ] 리눅스 밈
- [ ] 블랙잭 만들기
- [ ] 정보처리 기사 문제집 기본서 시작하기
- [ ] 이력서 24년 2분기 작성
  - [ ] 레이아웃 구성
  - [ ] 경력 기술서
  - [ ] PDF 출력
- [ ] 4월 기술 블로그 소재 2개
  - [ ] vue 오픈 소스 코드를 읽는 방법
  - [ ] vue에서 발생하는 특이한 랜더링 순서
- [ ] 5월 기술 블로그 소재 2개
  - [ ] ???
  - [ ] ???
- [ ] 6월 기술 블로그 소재 2개
  - [ ] ???
  - [ ] ???
- [ ] 정보처리 기사 문제집 기본서 시작하기
  - [ ] 소프트웨어 1 ~ 5장
  - [ ] 2024.06.18. 필기 원서 접수
  - [ ] 기본서 이후 기출 문제집 따로 구매하기
- [x] 4장. 연산자 - 기본
  - [x] 4.3. 형변환 연산자
  - [x] 4.4. 단항 증감 연산자
  - [x] 4.5. 비트 연산자
    - [x] 4.5.1. 비트 연산자의 사용
    - [x] 4.5.2. 마스크 연산
  - [x] 모범답안과 해설
  - [x] 연습문제
- [ ] 5장. 연산자 - 응용
  - [x] 5.1. sizeof 연산자
  - [x] 5.2. 관계 연산자
  - [x] 5.3. 논리 연산자
    - [x] 5.3.1. 논리합(OR)과 논리곱(AND)
    - [x] 5.3.2. 부정
    - [x] 5.3.3. 쇼트서킷
  - [ ] 5.4. 조건 연산자(삼항 연산자)
    - [ ] 5.4.1. 최댓값 구하기
    - [ ] 5.4.2. 최댓값 구하기 방식 비교
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 6장. 기본 제어문
  - [ ] 6.1. if문
    - [ ] 6.1.1. 기본 구조
    - [ ] 6.1.2. 제어문과 스코프
  - [ ] 6.2. if else문
    - [ ] 6.2.1. 기본구조
    - [ ] 6.2.2. 중첩된 제어문
    - [ ] 6.2.3. 식별자 검색순서(스코프의 중첩)
  - [ ] 6.3. 다중 if문
  - [ ] 6.4. switch-case문
  - [ ] 6.5. goto문
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 7장. 반복문
  - [ ] 7.1. while - 조건 기반 반복문
    - [ ] 7.1.1. 기본구조 조건에 의한 제어
    - [ ] 7.1.2. 무한루프
    - [ ] 7.1.3. 반복문 내부에 선언한 자동변수
    - [ ] 7.1.4. 반복문의 중첩
  - [ ] 7.2. for, 계수 기반 반복문
    - [ ] 7.2.1. while문과 비교
    - [ ] 7.2.2. '\*'를 이용한 도형출력 실습
  - [ ] 7.3. do while문
  - [ ] 7.4. break와 continue
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 8장. 배열
  - [ ] 8.1. 1차원 배열의 기본 문법
  - [ ] 8.2. 최댓값/최솟값
  - [ ] 8.3. 문자의 배열
    - [ ] 8.3.1. 문자열의 기본 구조
    - [ ] 8.3.2. 문자열의 끝이 '\0'인 이유
  - [ ] 8.4. 다차원 배열
    - [ ] 8.4.1. 2차원 배열의 기본 문법
    - [ ] 8.4.2. 3차원 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 9장. 배열을 활용한 프로그래밍 기법
  - [ ] 9.1. 배열 요소의 정렬
    - [ ] 9.1.1. 선택정렬로 알려진 버블정렬
    - [ ] 9.1.2. 버블정렬
    - [ ] 9.1.3. 선택정렬
  - [ ] 9.2. 배열과 교차의 구현
  - [ ] 9.3. 달팽이 배열 채우기
  - [ ] 9.4. Lookup 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 10장. 함수에 대한 기본 이론
  - [ ] 10.1. 사용자 정의 함수의 선언 및 정의
    - [ ] 10.1.1. 매개변수
    - [ ] 10.1.2. 반환 자료형
  - [ ] 10.2. 두 가지 함수 설계 원칙
    - [ ] 10.2.1. UI와 기능의 분리
    - [ ] 10.2.2. 재사용 가능한 단위 기능의 구현
  - [ ] 10.3. 코드 분할
    - [ ] 10.3.1. 함수의 원형 선언
    - [ ] 10.3.2. 전역변수
    - [ ] 10.3.3. 전역변수와 식별자 검색 순서
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 11장. 메모리와 포인터
  - [ ] 11.1. 컴퓨터와 메모리
    - [ ] 11.1.1. 메모리의 종류
    - [ ] 11.1.2. 포인터 변수의 선언 및 정의
    - [ ] 11.1.3. 포인터와 배열
  - [ ] 11.2. 메모리 동적 할당 및 관리
    - [ ] 11.2.1. 메모리 초기화 및 사용(배열)
    - [ ] 11.2.2. 메모리 복사
    - [ ] 11.2.3. 메모리 비교(`memcmp( )`, `strcmp( )`)
    - [ ] 11.2.4. 문자열 검색
    - [ ] 11.2.5. 배열 연산자 풀어쓰기
    - [ ] 11.2.6. `realloc( )`, `sprintf( )` 함수
  - [ ] 11.3. 잘못된 메모리 접근
  - [ ] 11.4. 포인터의 배열과 다중 포인터
    - [ ] 11.4.1. char\*의 배열
    - [ ] 11.4.2. 다중 포인터
    - [ ] 11.4.3. 다차원 배열에 대한 포인터
  - [ ] 11.5. 변수와 메모리
    - [ ] 11.5.1. 정적변수 static
    - [ ] 11.5.2. 레지스터 변수 register
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 12장. 함수 응용
  - [ ] 12.1. 매개변수 전달 방법
    - [ ] 12.1.1. Call by value
    - [ ] 12.1.2. Call by reference
  - [ ] 12.2. 스택 프레임 그리는 방법
  - [ ] 12.3. 재귀호출
    - [ ] 12.3.1. 재귀호출을 이용한 문자열 출력
    - [ ] 12.3.2. 재귀호출의 장/단점
  - [ ] 12.4. 문자/문자열 처리 함수
    - [ ] 12.4.1. 문자 처리 함수
    - [ ] 12.4.2. 문자열 처리 함수
    - [ ] 12.4.3. 유니코드 문자열
  - [ ] 12.5. 유틸리티 함수
    - [ ] 12.5.1. `atoi( )`, `atol( )`, `atof( )` 함수
    - [ ] 12.5.2. `time( )`, `localtime( )`, `ctime( )` 함수
    - [ ] 12.5.3. `srand( )`, `rand( )` 함수
    - [ ] 12.5.4. `system( )`, `exit( )` 함수
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 13장. 구조체와 공용체
  - [ ] 13.1. 구조체
    - [ ] 13.1.1. 구조체 선언 및 정의
    - [ ] 13.1.2. 구조체 동적 할당
    - [ ] 13.1.3. 반환자료, 매개변수 구조체
    - [ ] 13.1.4. 구조체를 멤버로 가지는 구조체
    - [ ] 13.1.5. 구조체 멤버 맞춤
  - [ ] 13.2. 비트필드
  - [ ] 13.3. 공용체
  - [ ] 연습문제
- [ ] 14장. 파일 입출력
  - [ ] 14.1. 파일 시스템 기본 이론
    - [ ] 14.1.1. 텍스트 파일과 바이너리 파일
    - [ ] 14.1.2. `fopen( )`, `fclose( )` 함수
  - [ ] 14.2. 텍스트 파일 입출력
    - [ ] 14.2.1. `fprintf( )`, `fscanf( )` 함수
    - [ ] 14.2.2. `fgetc( )`, `fputc( )` 함수
    - [ ] 14.2.3. `fgets( )`, `fgets_s( )`, `fputs( )` 함수
    - [ ] 14.2.4. `fflush( )` 함수
  - [ ] 14.3. 바이너리 파일 입출력
    - [ ] 14.3.1. `fread( )`, `fwrite( )` 함수
    - [ ] 14.3.2. `fseek( )`, `rewind( )`, `ftell( )` 함수
    - [ ] 14.3.3. 기타 알아 두면 좋은 함수
  - [ ] 연습문제
- [ ] 15장. 변수와 상수 고급 이론
  - [ ] 15.1. 형한정어
    - [ ] 15.1.1. `const`
    - [ ] 15.1.2. 상수형 포인터
    - [ ] 15.1.3. 심볼릭 상수를 만드는 또 다른 방법
    - [ ] 15.1.4. volatile
  - [ ] 15.2. extern 외부변수 선언
  - [ ] 15.3. 형 재선언
  - [ ] 15.4. 열거형 상수
  - [ ] 연습문제
- [ ] 16장. 전처리기
  - [ ] 16.1. `#include`
  - [ ] 16.2. 매크로
    - [ ] 16.2.1. `__inline` 함수와 메크로
    - [ ] 16.2.2. 매크로 특수화 연산자 `#`, `##`
  - [ ] 16.3. 조건부 컴파일
  - [ ] 연습문제
- [ ] 17장. 함수에 대한 고급 이론
  - [ ] 17.1. 성능 향상을 위한 이론
    - [ ] 17.1.1. 컴파일러 최적화
    - [ ] 17.1.2. `__inline 함수`
  - [ ] 17.2. 함수 호출 규칙
    - [ ] 17.2.1. `__cdecl`
    - [ ] 17.2.2. `__stdcall`
    - [ ] 17.2.3. `__fastcall`
  - [ ] 17.3. 함수 포인터와 역호출 구조
    - [ ] 17.3.1. 함수 포인터
    - [ ] 17.3.2. 역호출 구조
  - [ ] 17.4. 정적 라이브러리의 구현
    - [ ] 17.4.1. 라이브러리 프로젝트 생성
    - [ ] 17.4.2. 헤더파일의 구성
    - [ ] 17.4.3. 정적 라이브러리 사용하기
  - [ ] 17.5. 가변인자 사용하기
  - [ ] 연습문제

---

## 주간 회고

### Liked

- "독하게 시작하는 C 프로그래밍"를 읽기 시작했습니다. "C를 배우기 전에 반드시 알아야 할 것들"를 이미 읽어서 수월합니다.
  - 단순하게 학습 측면에서는 많지 않지만 세세한 부분을 볼 수 있다는 점에서는 학습한 것이 있습니다.

### Learned

- vue에 어답터를 사용하는 방법을 학습했습니다.
- 부울 값은 be 동사를 접두어로 붙는 것으로 끝나지 않습니다. 거기에 긍정형을 기준으로 작성해야 합니다. `!isValid`가 `isInvalid`보다 파악이 쉽습니다. 후자는 타입은 알아도 혼선의 여부가 발생할 수 있습니다. 
  - is 같은 비동사가 접두어로 붙으면 과거 헝가리안 케이스과 비슷하지만 다릅니다. 항가리안 케이스는 변수명의 접두어로 타입을 알려줍니다. 무슨 자료형이 IDE의 도움을 받기 어려울 때 활용하던 방식입니다. 하지만 지금은 컨벤션에서 변수를 관리하는 유형으로 생각할 수 있습니다. 지금의 경우 플래그 역할을 한다고 볼 수 있습니다.
- 코드를 읽을 때도 작성할 때도 어떻게 청킹할지 고려하면서 작성합니다. 그렇게 해서라도 인지부하를 줄여봅니다.
  - 회사 내에서 라이프 사이클 기준으로 작성하던 방식에서 관심사 기준으로 작성하는 방식으로 변경했습니다. 앞으로 코드 베이스에서 인지부하를 낮추는 방식으로 작성하고 읽기 쉽게 작성하는 방법을 고민하기 시작할 것 같습니다.

### Lacked

- 정보처리 기사를 학습하기 시작을 결정해놓고 전혀 다른 C 언어를 학습하기 시작했습니다.
- 개발자 블로그에 글쓸 소재를가 있는데 아직도 다루고 있지 않습니다.
- 이력서에 추가할 실력이 아직도 없습니다.
- 옵시디언을 활용하려고 했는데 안하고 있었습니다. 회사에서 학습한 것을 다시 접근하고 집에서 학습한 것을 회사에서 접근이 가능하게 자료를 계속 쌓아야 하는데 안했습니다.

### Longed(잘하기 위해 필요한 것)

- 코드를 읽는 능력 복잡한 로직을 빠르게 구현하는 능력.
- 라이브러리 코드라고 최적화를 할 수 없다고 생각하지 않고 제어영역으로 들어오게 만들 수 있다고 생각하기.
- 읽기 능력을 개선하기 위해 책을 읽는 다고 읽기 능력이 개선되는 것은 아닙니다. 개선은 이 학습한 이론을 어디에 어떻게 실천하면서 이루어지는 것입니다. 아직도 읽기능력에 문제가 있고 개선이 없는 것입니다.

### Action Item

- 개발자 블로그
  - [ ] 개발자 밈
    - [ ] 리눅스 밈
- [ ] 블랙잭 만들기
- [ ] 정보처리 기사 문제집 기본서 시작하기
- [ ] 이력서 24년 2분기 작성
  - [ ] 레이아웃 구성
  - [ ] 경력 기술서
  - [ ] PDF 출력
- [ ] 4월 기술 블로그 소재 2개
  - [ ] vue 오픈 소스 코드를 읽는 방법
  - [ ] vue에서 발생하는 특이한 랜더링 순서
- [ ] 5월 기술 블로그 소재 2개
  - [ ] ???
  - [ ] ???
- [ ] 6월 기술 블로그 소재 2개
  - [ ] ???
  - [ ] ???
- [ ] 정보처리 기사 문제집 기본서 시작하기
  - [ ] 소프트웨어 1 ~ 5장
  - [ ] 2024.06.18. 필기 원서 접수
  - [ ] 기본서 이후 기출 문제집 따로 구매하기
- [ ] 5장. 연산자 - 응용
  - [ ] 5.4. 조건 연산자(삼항 연산자)
    - [ ] 5.4.1. 최댓값 구하기
    - [ ] 5.4.2. 최댓값 구하기 방식 비교
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 6장. 기본 제어문
  - [ ] 6.1. if문
    - [ ] 6.1.1. 기본 구조
    - [ ] 6.1.2. 제어문과 스코프
  - [ ] 6.2. if else문
    - [ ] 6.2.1. 기본구조
    - [ ] 6.2.2. 중첩된 제어문
    - [ ] 6.2.3. 식별자 검색순서(스코프의 중첩)
  - [ ] 6.3. 다중 if문
  - [ ] 6.4. switch-case문
  - [ ] 6.5. goto문
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 7장. 반복문
  - [ ] 7.1. while - 조건 기반 반복문
    - [ ] 7.1.1. 기본구조 조건에 의한 제어
    - [ ] 7.1.2. 무한루프
    - [ ] 7.1.3. 반복문 내부에 선언한 자동변수
    - [ ] 7.1.4. 반복문의 중첩
  - [ ] 7.2. for, 계수 기반 반복문
    - [ ] 7.2.1. while문과 비교
    - [ ] 7.2.2. `*`를 이용한 도형출력 실습
  - [ ] 7.3. do while문
  - [ ] 7.4. break와 continue
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 8장. 배열
  - [ ] 8.1. 1차원 배열의 기본 문법
  - [ ] 8.2. 최댓값/최솟값
  - [ ] 8.3. 문자의 배열
    - [ ] 8.3.1. 문자열의 기본 구조
    - [ ] 8.3.2. 문자열의 끝이 `\0`인 이유
  - [ ] 8.4. 다차원 배열
    - [ ] 8.4.1. 2차원 배열의 기본 문법
    - [ ] 8.4.2. 3차원 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 9장. 배열을 활용한 프로그래밍 기법
  - [ ] 9.1. 배열 요소의 정렬
    - [ ] 9.1.1. 선택정렬로 알려진 버블정렬
    - [ ] 9.1.2. 버블정렬
    - [ ] 9.1.3. 선택정렬
  - [ ] 9.2. 배열과 교차의 구현
  - [ ] 9.3. 달팽이 배열 채우기
  - [ ] 9.4. Lookup 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 10장. 함수에 대한 기본 이론
  - [ ] 10.1. 사용자 정의 함수의 선언 및 정의
    - [ ] 10.1.1. 매개변수
    - [ ] 10.1.2. 반환 자료형
  - [ ] 10.2. 두 가지 함수 설계 원칙
    - [ ] 10.2.1. UI와 기능의 분리
    - [ ] 10.2.2. 재사용 가능한 단위 기능의 구현
  - [ ] 10.3. 코드 분할
    - [ ] 10.3.1. 함수의 원형 선언
    - [ ] 10.3.2. 전역변수
    - [ ] 10.3.3. 전역변수와 식별자 검색 순서
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 11장. 메모리와 포인터
  - [ ] 11.1. 컴퓨터와 메모리
    - [ ] 11.1.1. 메모리의 종류
    - [ ] 11.1.2. 포인터 변수의 선언 및 정의
    - [ ] 11.1.3. 포인터와 배열
  - [ ] 11.2. 메모리 동적 할당 및 관리
    - [ ] 11.2.1. 메모리 초기화 및 사용(배열)
    - [ ] 11.2.2. 메모리 복사
    - [ ] 11.2.3. 메모리 비교(`memcmp( )`, `strcmp( )`)
    - [ ] 11.2.4. 문자열 검색
    - [ ] 11.2.5. 배열 연산자 풀어쓰기
    - [ ] 11.2.6. `realloc( )`, `sprintf( )` 함수
  - [ ] 11.3. 잘못된 메모리 접근
  - [ ] 11.4. 포인터의 배열과 다중 포인터
    - [ ] 11.4.1. char\*의 배열
    - [ ] 11.4.2. 다중 포인터
    - [ ] 11.4.3. 다차원 배열에 대한 포인터
  - [ ] 11.5. 변수와 메모리
    - [ ] 11.5.1. 정적변수 static
    - [ ] 11.5.2. 레지스터 변수 register
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 12장. 함수 응용
  - [ ] 12.1. 매개변수 전달 방법
    - [ ] 12.1.1. Call by value
    - [ ] 12.1.2. Call by reference
  - [ ] 12.2. 스택 프레임 그리는 방법
  - [ ] 12.3. 재귀호출
    - [ ] 12.3.1. 재귀호출을 이용한 문자열 출력
    - [ ] 12.3.2. 재귀호출의 장/단점
  - [ ] 12.4. 문자/문자열 처리 함수
    - [ ] 12.4.1. 문자 처리 함수
    - [ ] 12.4.2. 문자열 처리 함수
    - [ ] 12.4.3. 유니코드 문자열
  - [ ] 12.5. 유틸리티 함수
    - [ ] 12.5.1. `atoi( )`, `atol( )`, `atof( )` 함수
    - [ ] 12.5.2. `time( )`, `localtime( )`, `ctime( )` 함수
    - [ ] 12.5.3. `srand( )`, `rand( )` 함수
    - [ ] 12.5.4. `system( )`, `exit( )` 함수
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 13장. 구조체와 공용체
  - [ ] 13.1. 구조체
    - [ ] 13.1.1. 구조체 선언 및 정의
    - [ ] 13.1.2. 구조체 동적 할당
    - [ ] 13.1.3. 반환자료, 매개변수 구조체
    - [ ] 13.1.4. 구조체를 멤버로 가지는 구조체
    - [ ] 13.1.5. 구조체 멤버 맞춤
  - [ ] 13.2. 비트필드
  - [ ] 13.3. 공용체
  - [ ] 연습문제
- [ ] 14장. 파일 입출력
  - [ ] 14.1. 파일 시스템 기본 이론
    - [ ] 14.1.1. 텍스트 파일과 바이너리 파일
    - [ ] 14.1.2. `fopen( )`, `fclose( )` 함수
  - [ ] 14.2. 텍스트 파일 입출력
    - [ ] 14.2.1. `fprintf( )`, `fscanf( )` 함수
    - [ ] 14.2.2. `fgetc( )`, `fputc( )` 함수
    - [ ] 14.2.3. `fgets( )`, `fgets_s( )`, `fputs( )` 함수
    - [ ] 14.2.4. `fflush( )` 함수
  - [ ] 14.3. 바이너리 파일 입출력
    - [ ] 14.3.1. `fread( )`, `fwrite( )` 함수
    - [ ] 14.3.2. `fseek( )`, `rewind( )`, `ftell( )` 함수
    - [ ] 14.3.3. 기타 알아 두면 좋은 함수
  - [ ] 연습문제
- [ ] 15장. 변수와 상수 고급 이론
  - [ ] 15.1. 형한정어
    - [ ] 15.1.1. `const`
    - [ ] 15.1.2. 상수형 포인터
    - [ ] 15.1.3. 심볼릭 상수를 만드는 또 다른 방법
    - [ ] 15.1.4. volatile
  - [ ] 15.2. extern 외부변수 선언
  - [ ] 15.3. 형 재선언
  - [ ] 15.4. 열거형 상수
  - [ ] 연습문제
- [ ] 16장. 전처리기
  - [ ] 16.1. `#include`
  - [ ] 16.2. 매크로
    - [ ] 16.2.1. `__inline` 함수와 메크로
    - [ ] 16.2.2. 매크로 특수화 연산자 `#`, `##`
  - [ ] 16.3. 조건부 컴파일
  - [ ] 연습문제
- [ ] 17장. 함수에 대한 고급 이론
  - [ ] 17.1. 성능 향상을 위한 이론
    - [ ] 17.1.1. 컴파일러 최적화
    - [ ] 17.1.2. `__inline 함수`
  - [ ] 17.2. 함수 호출 규칙
    - [ ] 17.2.1. `__cdecl`
    - [ ] 17.2.2. `__stdcall`
    - [ ] 17.2.3. `__fastcall`
  - [ ] 17.3. 함수 포인터와 역호출 구조
    - [ ] 17.3.1. 함수 포인터
    - [ ] 17.3.2. 역호출 구조
  - [ ] 17.4. 정적 라이브러리의 구현
    - [ ] 17.4.1. 라이브러리 프로젝트 생성
    - [ ] 17.4.2. 헤더파일의 구성
    - [ ] 17.4.3. 정적 라이브러리 사용하기
  - [ ] 17.5. 가변인자 사용하기
  - [ ] 연습문제

---

> 코드를 작성할 때 긴장된다면 당신은 나쁜 프로그래머입니다. 민폐 그만끼치고 퇴사좀 하세요. 긴장되고 어려울 때는 본인의 제어영역 밖에 있는 버그가 발생한 것일 때만입니다.

- 석사과정에서 그나마 고급알고리즘을 작성할 때도 검색과 긴장 없이 바로 가능해야 합니다.

---

- 본인의 장점 혹은 강점은 무엇인가?
  - 강점, 장점은 소속한 조직에 따라 좌우됩니다. 
  - 스스로 근면하고 CS 지식이 많은 편이라고 착각할 수 있습니다.
