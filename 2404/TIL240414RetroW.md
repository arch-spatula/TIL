# 개발자 블로그 15일차

1일1커밋 무사고: 489일차

## 감사일기

1. ???

- [x] 이번주 배운 내용 줍줍 짱박아두기
- [x] 주간회고
- [ ] 블랙잭 만들기
  - [ ] 브랜치 만들기
  - [ ] 폴더 만들기
  - [ ] 핵심 파일 만들기
  - [ ] 비즈니스 로직 수도 코드로 작성하기
- [ ] 이력서 24년 2분기 작성
  - [ ] 레이아웃 구성
    - [ ] 목차 결정
    - [ ] 소제목 작성
  - [ ] 경력 기술서
  - [ ] PDF 출력
- [ ] 4월 기술 블로그 소재 2개
  - [ ] vue 오픈 소스 코드를 읽는 방법
    - [ ] 래퍼런스 자료 정리
  - [ ] vue에서 발생하는 특이한 랜더링 순서
- [ ] 5월 기술 블로그 소재 2개
  - [ ] LSP란 무엇인가?
  - [ ] ???
- [ ] 6월 기술 블로그 소재 2개
  - [ ] ???
  - [ ] ???
- [ ] 정보처리 기사 문제집 기본서 시작하기
  - [ ] 소프트웨어 1 ~ 5장
  - [ ] 2024.06.18. 필기 원서 접수
  - [ ] 기본서 이후 기출 문제집 따로 구매하기
- [x] 7장. 반복문
  - [x] 7.2. for, 계수 기반 반복문
    - [x] 7.2.1. while문과 비교
    - [x] 7.2.2. `*`를 이용한 도형출력 실습
  - [x] 7.3. do while문
  - [x] 7.4. break와 continue
  - [x] 모범답안과 해설
  - [x] 연습문제
- [ ] 8장. 배열
  - [x] 8.1. 1차원 배열의 기본 문법
  - [x] 8.2. 최댓값/최솟값
  - [ ] 8.3. 문자의 배열
    - [ ] 8.3.1. 문자열의 기본 구조
    - [ ] 8.3.2. 문자열의 끝이 `\0`인 이유
  - [ ] 8.4. 다차원 배열
    - [ ] 8.4.1. 2차원 배열의 기본 문법
    - [ ] 8.4.2. 3차원 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 9장. 배열을 활용한 프로그래밍 기법
  - [ ] 9.1. 배열 요소의 정렬
    - [ ] 9.1.1. 선택정렬로 알려진 버블정렬
    - [ ] 9.1.2. 버블정렬
    - [ ] 9.1.3. 선택정렬
  - [ ] 9.2. 배열과 교차의 구현
  - [ ] 9.3. 달팽이 배열 채우기
  - [ ] 9.4. Lookup 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 10장. 함수에 대한 기본 이론
  - [ ] 10.1. 사용자 정의 함수의 선언 및 정의
    - [ ] 10.1.1. 매개변수
    - [ ] 10.1.2. 반환 자료형
  - [ ] 10.2. 두 가지 함수 설계 원칙
    - [ ] 10.2.1. UI와 기능의 분리
    - [ ] 10.2.2. 재사용 가능한 단위 기능의 구현
  - [ ] 10.3. 코드 분할
    - [ ] 10.3.1. 함수의 원형 선언
    - [ ] 10.3.2. 전역변수
    - [ ] 10.3.3. 전역변수와 식별자 검색 순서
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 11장. 메모리와 포인터
  - [ ] 11.1. 컴퓨터와 메모리
    - [ ] 11.1.1. 메모리의 종류
    - [ ] 11.1.2. 포인터 변수의 선언 및 정의
    - [ ] 11.1.3. 포인터와 배열
  - [ ] 11.2. 메모리 동적 할당 및 관리
    - [ ] 11.2.1. 메모리 초기화 및 사용(배열)
    - [ ] 11.2.2. 메모리 복사
    - [ ] 11.2.3. 메모리 비교(`memcmp( )`, `strcmp( )`)
    - [ ] 11.2.4. 문자열 검색
    - [ ] 11.2.5. 배열 연산자 풀어쓰기
    - [ ] 11.2.6. `realloc( )`, `sprintf( )` 함수
  - [ ] 11.3. 잘못된 메모리 접근
  - [ ] 11.4. 포인터의 배열과 다중 포인터
    - [ ] 11.4.1. char`*`의 배열
    - [ ] 11.4.2. 다중 포인터
    - [ ] 11.4.3. 다차원 배열에 대한 포인터
  - [ ] 11.5. 변수와 메모리
    - [ ] 11.5.1. 정적변수 static
    - [ ] 11.5.2. 레지스터 변수 register
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 12장. 함수 응용
  - [ ] 12.1. 매개변수 전달 방법
    - [ ] 12.1.1. Call by value
    - [ ] 12.1.2. Call by reference
  - [ ] 12.2. 스택 프레임 그리는 방법
  - [ ] 12.3. 재귀호출
    - [ ] 12.3.1. 재귀호출을 이용한 문자열 출력
    - [ ] 12.3.2. 재귀호출의 장/단점
  - [ ] 12.4. 문자/문자열 처리 함수
    - [ ] 12.4.1. 문자 처리 함수
    - [ ] 12.4.2. 문자열 처리 함수
    - [ ] 12.4.3. 유니코드 문자열
  - [ ] 12.5. 유틸리티 함수
    - [ ] 12.5.1. `atoi( )`, `atol( )`, `atof( )` 함수
    - [ ] 12.5.2. `time( )`, `localtime( )`, `ctime( )` 함수
    - [ ] 12.5.3. `srand( )`, `rand( )` 함수
    - [ ] 12.5.4. `system( )`, `exit( )` 함수
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 13장. 구조체와 공용체
  - [ ] 13.1. 구조체
    - [ ] 13.1.1. 구조체 선언 및 정의
    - [ ] 13.1.2. 구조체 동적 할당
    - [ ] 13.1.3. 반환자료, 매개변수 구조체
    - [ ] 13.1.4. 구조체를 멤버로 가지는 구조체
    - [ ] 13.1.5. 구조체 멤버 맞춤
  - [ ] 13.2. 비트필드
  - [ ] 13.3. 공용체
  - [ ] 연습문제
- [ ] 14장. 파일 입출력
  - [ ] 14.1. 파일 시스템 기본 이론
    - [ ] 14.1.1. 텍스트 파일과 바이너리 파일
    - [ ] 14.1.2. `fopen( )`, `fclose( )` 함수
  - [ ] 14.2. 텍스트 파일 입출력
    - [ ] 14.2.1. `fprintf( )`, `fscanf( )` 함수
    - [ ] 14.2.2. `fgetc( )`, `fputc( )` 함수
    - [ ] 14.2.3. `fgets( )`, `fgets_s( )`, `fputs( )` 함수
    - [ ] 14.2.4. `fflush( )` 함수
  - [ ] 14.3. 바이너리 파일 입출력
    - [ ] 14.3.1. `fread( )`, `fwrite( )` 함수
    - [ ] 14.3.2. `fseek( )`, `rewind( )`, `ftell( )` 함수
    - [ ] 14.3.3. 기타 알아 두면 좋은 함수
  - [ ] 연습문제
- [ ] 15장. 변수와 상수 고급 이론
  - [ ] 15.1. 형한정어
    - [ ] 15.1.1. `const`
    - [ ] 15.1.2. 상수형 포인터
    - [ ] 15.1.3. 심볼릭 상수를 만드는 또 다른 방법
    - [ ] 15.1.4. volatile
  - [ ] 15.2. extern 외부변수 선언
  - [ ] 15.3. 형 재선언
  - [ ] 15.4. 열거형 상수
  - [ ] 연습문제
- [ ] 16장. 전처리기
  - [ ] 16.1. `#include`
  - [ ] 16.2. 매크로
    - [ ] 16.2.1. `__inline` 함수와 메크로
    - [ ] 16.2.2. 매크로 특수화 연산자 `#`, `##`
  - [ ] 16.3. 조건부 컴파일
  - [ ] 연습문제
- [ ] 17장. 함수에 대한 고급 이론
  - [ ] 17.1. 성능 향상을 위한 이론
    - [ ] 17.1.1. 컴파일러 최적화
    - [ ] 17.1.2. `__inline 함수`
  - [ ] 17.2. 함수 호출 규칙
    - [ ] 17.2.1. `__cdecl`
    - [ ] 17.2.2. `__stdcall`
    - [ ] 17.2.3. `__fastcall`
  - [ ] 17.3. 함수 포인터와 역호출 구조
    - [ ] 17.3.1. 함수 포인터
    - [ ] 17.3.2. 역호출 구조
  - [ ] 17.4. 정적 라이브러리의 구현
    - [ ] 17.4.1. 라이브러리 프로젝트 생성
    - [ ] 17.4.2. 헤더파일의 구성
    - [ ] 17.4.3. 정적 라이브러리 사용하기
  - [ ] 17.5. 가변인자 사용하기
  - [ ] 연습문제

---

## 주간 회고

### Liked

- 이번주 수요일은 휴일이었습니다. 휴식할 수 있어서 좋았습니다.
- 다음주부터 조금더 어려운 C 언어 주제를 다룰 것 같습니다. 컴퓨터 공학적으로 도전적인 부분을 어느정도 학습해볼 수 있을 것 같습니다.

### Learned

- neovim에도 멀티커서를 지원하게 만들 수 있는 플러그인이 있습니다.
- 저수준을 학습할 수 있는 강의자료를 인터넷에서 발견했습니다. 지금은 결제를 안 했습니다.

### Lacked

- 수요일 휴일이 있었음에도 불구하고 책을 읽을 시간을 너무 많이 낭비했습니다.
- 퇴근하고 고민을 별로 안했습니다. 어떻게 업무를 더 잘할지 생각을 많이 안 했습니다.
- 연산자, 조건문, 반복문은 상당히 쉬운 편인데 더 빠르게 끝낼 수 없었습니다.

### Longed(잘하기 위해 필요한 것)

- 독하게 시작하는 C 프로그래밍을 빠르게 끝내야 합니다.
- 중심으로 생각하는 과제가 독서라고 프로젝트 자체에 대해서 생각을 별로 안하고 있습니다.
- 업무를 잘하기 위해 필요한 것을 다시 생각하는 시간에 회사 도메인 지식을 정리하기 위해 옵시디언을 많이 활용합시다.

### Action Item

- [ ] 예비군 다녀오기
- [ ] 8장. 배열
  - [ ] 8.3. 문자의 배열
    - [ ] 8.3.1. 문자열의 기본 구조
    - [ ] 8.3.2. 문자열의 끝이 `\0`인 이유
  - [ ] 8.4. 다차원 배열
    - [ ] 8.4.1. 2차원 배열의 기본 문법
    - [ ] 8.4.2. 3차원 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 9장. 배열을 활용한 프로그래밍 기법
  - [ ] 9.1. 배열 요소의 정렬
    - [ ] 9.1.1. 선택정렬로 알려진 버블정렬
    - [ ] 9.1.2. 버블정렬
    - [ ] 9.1.3. 선택정렬
  - [ ] 9.2. 배열과 교차의 구현
  - [ ] 9.3. 달팽이 배열 채우기
  - [ ] 9.4. Lookup 배열
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 10장. 함수에 대한 기본 이론
  - [ ] 10.1. 사용자 정의 함수의 선언 및 정의
    - [ ] 10.1.1. 매개변수
    - [ ] 10.1.2. 반환 자료형
  - [ ] 10.2. 두 가지 함수 설계 원칙
    - [ ] 10.2.1. UI와 기능의 분리
    - [ ] 10.2.2. 재사용 가능한 단위 기능의 구현
  - [ ] 10.3. 코드 분할
    - [ ] 10.3.1. 함수의 원형 선언
    - [ ] 10.3.2. 전역변수
    - [ ] 10.3.3. 전역변수와 식별자 검색 순서
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 11장. 메모리와 포인터
  - [ ] 11.1. 컴퓨터와 메모리
    - [ ] 11.1.1. 메모리의 종류
    - [ ] 11.1.2. 포인터 변수의 선언 및 정의
    - [ ] 11.1.3. 포인터와 배열
  - [ ] 11.2. 메모리 동적 할당 및 관리
    - [ ] 11.2.1. 메모리 초기화 및 사용(배열)
    - [ ] 11.2.2. 메모리 복사
    - [ ] 11.2.3. 메모리 비교(`memcmp( )`, `strcmp( )`)
    - [ ] 11.2.4. 문자열 검색
    - [ ] 11.2.5. 배열 연산자 풀어쓰기
    - [ ] 11.2.6. `realloc( )`, `sprintf( )` 함수
  - [ ] 11.3. 잘못된 메모리 접근
  - [ ] 11.4. 포인터의 배열과 다중 포인터
    - [ ] 11.4.1. char`*`의 배열
    - [ ] 11.4.2. 다중 포인터
    - [ ] 11.4.3. 다차원 배열에 대한 포인터
  - [ ] 11.5. 변수와 메모리
    - [ ] 11.5.1. 정적변수 static
    - [ ] 11.5.2. 레지스터 변수 register
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 12장. 함수 응용
  - [ ] 12.1. 매개변수 전달 방법
    - [ ] 12.1.1. Call by value
    - [ ] 12.1.2. Call by reference
  - [ ] 12.2. 스택 프레임 그리는 방법
  - [ ] 12.3. 재귀호출
    - [ ] 12.3.1. 재귀호출을 이용한 문자열 출력
    - [ ] 12.3.2. 재귀호출의 장/단점
  - [ ] 12.4. 문자/문자열 처리 함수
    - [ ] 12.4.1. 문자 처리 함수
    - [ ] 12.4.2. 문자열 처리 함수
    - [ ] 12.4.3. 유니코드 문자열
  - [ ] 12.5. 유틸리티 함수
    - [ ] 12.5.1. `atoi( )`, `atol( )`, `atof( )` 함수
    - [ ] 12.5.2. `time( )`, `localtime( )`, `ctime( )` 함수
    - [ ] 12.5.3. `srand( )`, `rand( )` 함수
    - [ ] 12.5.4. `system( )`, `exit( )` 함수
  - [ ] 모범답안과 해설
  - [ ] 연습문제
- [ ] 13장. 구조체와 공용체
  - [ ] 13.1. 구조체
    - [ ] 13.1.1. 구조체 선언 및 정의
    - [ ] 13.1.2. 구조체 동적 할당
    - [ ] 13.1.3. 반환자료, 매개변수 구조체
    - [ ] 13.1.4. 구조체를 멤버로 가지는 구조체
    - [ ] 13.1.5. 구조체 멤버 맞춤
  - [ ] 13.2. 비트필드
  - [ ] 13.3. 공용체
  - [ ] 연습문제
- [ ] 14장. 파일 입출력
  - [ ] 14.1. 파일 시스템 기본 이론
    - [ ] 14.1.1. 텍스트 파일과 바이너리 파일
    - [ ] 14.1.2. `fopen( )`, `fclose( )` 함수
  - [ ] 14.2. 텍스트 파일 입출력
    - [ ] 14.2.1. `fprintf( )`, `fscanf( )` 함수
    - [ ] 14.2.2. `fgetc( )`, `fputc( )` 함수
    - [ ] 14.2.3. `fgets( )`, `fgets_s( )`, `fputs( )` 함수
    - [ ] 14.2.4. `fflush( )` 함수
  - [ ] 14.3. 바이너리 파일 입출력
    - [ ] 14.3.1. `fread( )`, `fwrite( )` 함수
    - [ ] 14.3.2. `fseek( )`, `rewind( )`, `ftell( )` 함수
    - [ ] 14.3.3. 기타 알아 두면 좋은 함수
  - [ ] 연습문제
- [ ] 15장. 변수와 상수 고급 이론
  - [ ] 15.1. 형한정어
    - [ ] 15.1.1. `const`
    - [ ] 15.1.2. 상수형 포인터
    - [ ] 15.1.3. 심볼릭 상수를 만드는 또 다른 방법
    - [ ] 15.1.4. volatile
  - [ ] 15.2. extern 외부변수 선언
  - [ ] 15.3. 형 재선언
  - [ ] 15.4. 열거형 상수
  - [ ] 연습문제
- [ ] 16장. 전처리기
  - [ ] 16.1. `#include`
  - [ ] 16.2. 매크로
    - [ ] 16.2.1. `__inline` 함수와 메크로
    - [ ] 16.2.2. 매크로 특수화 연산자 `#`, `##`
  - [ ] 16.3. 조건부 컴파일
  - [ ] 연습문제
- [ ] 17장. 함수에 대한 고급 이론
  - [ ] 17.1. 성능 향상을 위한 이론
    - [ ] 17.1.1. 컴파일러 최적화
    - [ ] 17.1.2. `__inline 함수`
  - [ ] 17.2. 함수 호출 규칙
    - [ ] 17.2.1. `__cdecl`
    - [ ] 17.2.2. `__stdcall`
    - [ ] 17.2.3. `__fastcall`
  - [ ] 17.3. 함수 포인터와 역호출 구조
    - [ ] 17.3.1. 함수 포인터
    - [ ] 17.3.2. 역호출 구조
  - [ ] 17.4. 정적 라이브러리의 구현
    - [ ] 17.4.1. 라이브러리 프로젝트 생성
    - [ ] 17.4.2. 헤더파일의 구성
    - [ ] 17.4.3. 정적 라이브러리 사용하기
  - [ ] 17.5. 가변인자 사용하기
  - [ ] 연습문제
- [ ] 블랙잭 만들기
  - [ ] 브랜치 만들기
  - [ ] 폴더 만들기
  - [ ] 핵심 파일 만들기
  - [ ] 비즈니스 로직 수도 코드로 작성하기
- [ ] 이력서 24년 2분기 작성
  - [ ] 레이아웃 구성
    - [ ] 목차 결정
    - [ ] 소제목 작성
  - [ ] 경력 기술서
  - [ ] PDF 출력
- [ ] 4월 기술 블로그 소재 2개
  - [ ] vue 오픈 소스 코드를 읽는 방법
    - [ ] 래퍼런스 자료 정리
  - [ ] vue에서 발생하는 특이한 랜더링 순서
- [ ] 5월 기술 블로그 소재 2개
  - [ ] LSP란 무엇인가?
  - [ ] ???
- [ ] 6월 기술 블로그 소재 2개
  - [ ] ???
  - [ ] ???
- [ ] 정보처리 기사 문제집 기본서 시작하기
  - [ ] 소프트웨어 1 ~ 5장
  - [ ] 2024.06.18. 필기 원서 접수
  - [ ] 기본서 이후 기출 문제집 따로 구매하기

## 저수준의 중요성

https://www.youtube.com/watch?v=7aYbwgMoUdE

- 성능 때문에 어쎔블리를 작성하는 것은 필요없다고 많이 오해합니다.
- 지금 CPU의 한계에 도달했습니다. 지금 컴퓨터는 빠르기는 하지만 한계에 도달하면 다시 저수준으로 제어해야 합니다.
- CUDA를 직접 작성하지 않고 C언어로 ML을 훈련합니다. GC 언어는 근본적으로 한계를 가질 수 밖에 없습니다.
- 이해 못하는 버그를 이해할 때 도움이 많이 됩니다. GC가 없으면 버그 파악이 쉽습니다. 컴퓨터의 원리를 이해하고 현상분석이 쉽습니다.
  - 어쎔블리는 GC가 있는 언어보다 더 빠른 경우가 더 많습니다. POC 수준이 아니라 정상적인 제품 수준에 해당합니다.
- 컴퓨터의 근본은 크게 다르지 않습니다.
- C++은 저수준 성능으로 고수준으로 작성합니다. 통역할 때 전문 통번역자가 직역을 의역과 재조합해 이해를 더 잘 할 수 있게 해줍니다. 하지만 GC가 있는 언어는 저성능 번역기로 변환하는 것입니다.
- 어쎔블리와 C++가 필요하다는 것은 엄청난 행운입니다.
- 컴퓨터를 잘 이해하는 것이 최소한입니다. 추상적이면 절대 안됩니다.
- 프로는 컴퓨터 하드웨어 차원에서 전압도 파악하는 것이 당연합니다. 하드웨어 결함까지 파악이 가능해야 합니다.
- 훌륭한 개발자가 되겠다고 하는데 저수준을 이해 안해도 괜찮다는 사람들이 아깝습니다.
- 잔기술만 많이 늘어가고 있습니다. 핵심만 잘 이해하면 본질은 모두 같습니다.
