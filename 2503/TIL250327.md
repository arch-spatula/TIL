# AoC 일찍 포기하고 플래시카드 만들기 107일차

1일1커밋 무사고: 836일차

## 감사일기

1. ???

## todo

- [ ] ???

---

## 정적분석 vs 유닛테스트

- https://www.youtube.com/watch?v=rrWxa7QBPcM
- 단위테스트 작성을 위해 DI를 많이 만들기 위해 인터페이스를 많이 만드는 방식을 잘못된 방식입니다.
  - 대부분의 상황에서 잘못된 방법입니다.
- 정적 분석에 더 많이 의존하는 것이 더 효율적입니다.
  - C#보다 C++에 더 효과적입니다.
  - 정적분석은 유용합니다. 만약에 배열을 만들었는데 사이즈를 초과하는 주소를 접근하려는 행위를 하는 경우가 있습니다. 또는 포인터를 초기화를 안해서 이상한 숫자가 들어있는 경우가 많습니다.
  - C++은 이상한게 들어가면 자유도가 높아 더 크게 잘못될 가능성이 높습니다.
  - 정적 분석은 단언과 소스코드로 실행하지 않고 소스코드 분석으로 알아냅니다.
  - 게임에서 존 카맥이 발표를 했었습니다.
  - MS의 비주얼 스튜디오는 기본적으로 그냥 들어가있습니다.
  - C 언어 개발자에게 권장합니다. PR 전 CI에 넣을 것을 권장하고 있습니다.
  - 정적 분석은 오타 혹은 작성 중에 놓치는 것을 많이 발견할 수 있어서 유용합니다.
- C#도 잘 동작합니다.
- 정적 분석과 단위 테스트의 역할 자체는 본질적으로 다릅니다.
- 정적 분석은 코드 자체를 잘못짜거나 엉뚱하게 작성하는 방식에 대한 대비책으로 활용할 수 있습니다.
- 단위테스트도 시간이 들어가고 정적분석도 시간이 들어갑니다.
- 단위테스트보다 작성 노력이 더 작은 것은 정적 분석입니다. 또 실행하는 시간도 작습니다.
- 소프트웨어 개발을 할 때는 프로젝트의 위험제어가 제일 중요합니다.
- 시간적인 노력은 정적 분석이 제일 덜 듭니다. 단위테스트는 더 많이 듭니다. 하지만 회사에서 시간이 제일 중요한 자원입니다.
- 납품하는 상황이고 완벽하게 버그가 없는 것을 검증하는 것이 중요하지 않는 이상 단위 테스트에 의존하지 말아야 합니다.
- AI에게 단위테스트 케이스를 작성하도록 시킬 수 있습니다. 어느정도 자동화가 가능하면 자동화를 활용해서 작성 노력을 줄여야 합니다.

## 면접관이 물었다. 만일 스택이 매우 커질 수 있다면 힙은 불필요할까?

- https://www.youtube.com/watch?v=9TSojdIr8Q0
- 스택메모리를 무한하게 키울 수 있는 인프라를 가질 수 있다면 힙이 필요한가?
  - 힙 파편화에 대해 논해라도 질문입니다.
- 질문은 CS 이론을 얼마나 잘 알고 있는지 알아내려는 것입니다. AI 시대라고 AI를 잘 사용하는 것이 중요하지만 AI를 더 잘 쓰기 위해 CS 지식을 쌓아야 합니다.
  - 의사, 변호사는 AI에 대체될 수 있는가? 개발자랑 전혀 다른 위상을 갖고 있어서 비교대상이 아닙니다.
- 전공자 저학년 수준의 질문입니다. 컴퓨터 구조론과 운영체제에 대한 지식입니다. 가상메모리에 대한 이해가 기반이 되어야 합니다.
- 정답이 있습니다. 이 정답을 수준 높게 답하면 됩니다. 전반적인 지식의 수준을 알아내려는 것이 의도입니다. 종합적으로 파악하기 좋은 질문입니다.
- Stack과 Heap은 존재 이유가 다릅니다. 둘은 서로 다르게 계속 있어야 한다고 봅니다.
- 함수의 자동변수, 매개변수, 반환주소는 스택 프레임 내에 있습니다. 호출규약에 대해서 잘 알고 대답까지 해줘야 합니다.
- Stack은 컴파일 타임에 메모리 공간에 필요한 크기를 사전에 알 수 있습니다.
  - 지역변수의 생명주기를 알 수 있습니다.
  - 코드의 흐름과 의존 구조를 알 수 있습니다.
    - 이런 의존성 문제는 병렬 혹은 동시성과 관련된 문제랑 연결됩니다.
- Call Stack이 깊어지면 제어흐름이 길어지면서 파악이 어려워질 수 있습니다.
- 일정한 수준을 넘을 정도로 Stack을 많이 쓰면 사람이 파악하기 어려운 코드가 될 수 있습니다. 물론 상호 의존성이 높은 경우에 해당합니다.
- 힙은 가변길이 배열처럼 사이즈가 동적이어야 하는 경우가 많기 때문에 필요합니다.
- Stack 만으로는 멀티쓰레드 처리가 까다롭습니다. 쓰레드에서 언제 어떤 변수를 관리해서 제거할지 파악이 어렵습니다. 하드웨어의 사이즈의 문제보단 코드 관리의 문제입니다. 함수 범위를 초과하고 존재해야 하면 변수관리가 어려워집니다.
  - 참고로 멀티쓰레드는 일반적인 어플리케이션입니다.
- 힙메모리 파편화도 다루어야 합니다. malloc은 함수가 꽤 느립니다. 게임서버를 만드는 개발자는 mallco을 설계부터 사용하지 않도록 설계합니다.
  - 미리 mallco 공간을 할당하고 서버가 이벤트를 받도록 해줍니다.
  - 백엔드와 인프라가 긴밀한 조직이거나 게임 회사로 추측됩니다.
- 메모리 파편화는 대부분 알고 있습니다.
  - 메모리는 정렬이 중요합니다. 메모리 관리 편하게 만들기 위해 이렇게 합니다.
  - 메모리는 일부 단편화로 낭비가 있어도 균일하게 분리하는 것이 구현과 관리가 쉽습니다.
- 4kb를 보통 메모리 저장 단위로 활용합니다. OS에서 제공하는 page 최소 사이즈입니다. 이 사이즈보다 작게 할당해도 내부단편화가 발생해도 관리가 쉽습니다.
  - 내 단편화를 억지로 제거하려다가 외부 단편화 문제가 발생할 것입니다. 또 공간의 사이즈 확인도 해야하는 등 이런저런 이슈가 많아집니다.
  - 메모리 페이지 인스턴스의 사이즈에 따라 초기화와 제거는 달라집니다. 트레이드 오프 고려를 잘해야 합니다.
- 힙 메모미 파편화는 배열처럼 미리 할당하는 전략을 꽤 많이 사용합니다. 이것의 한계는 최대 크기가 정해졌습니다. 문제는 동적인 경우입니다. GC랑 비슷한 비슷한 기능을 구현해야 합니다.
  - 마크엔 스윕으로 만들고 추적하는 것도 있지만 컴팩트 사이클도 추가해볼 수 있습니다.
  - JVM의 경우 세대 개념을 갖고 있습니다.
  - 런타임의 어플리케이션 메모리 사용은 별도의 쓰레드에서 관리하는 것이 일반적입니다. 동기화 이슈 해결까지 잘 완벽하게 설명해줘야 합니다.
  - 메모리 파편화 전략도 당연히 논해야 합니다. 반응속도와 메모리 관리 효율 사이 트레이드 오프에 맞게 선택하는 것도 보여줘야 합니다.
