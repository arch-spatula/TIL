# 블로그 다시 만들기 101일차

1일1커밋 무사고: 1032일차

## 감사일기

1. ???

## todo

- [ ] ???

---

## CPU는 어떻게 다양한 하드웨어와 상호작용할 수 있는가?

- How CPUs Interact with So Many Different Devices
- https://www.youtube.com/watch?v=tadUeiNe5-g
- 일반목적 컴퓨터는 다양한 과제를 수행할 수 있개 프로그래밍이 가능해야 합니다.
  - io장치랑 상호작용하는 것을 의미합니다.
- 다양한 추상화가 되었습니다. 엄청 요약되었습니다.
- io 장치는 입출력 장치입니다. 키보드 마우스는 입력장치입니다. 모니터와 스피커는 출력 장치입니다.
- CPU는 메모리를 버스를 통해서 통신합니다.
- CPU가 직접 제어하는 것이 좋지 못합니다. 엄청나게 많은 계산을 처리하는데 io장치는 오래걸립니다. 세세한 제어를 CPU가 직접핸들링하면 불필요한 작업을 수행하게 됩니다. 불필요한 대기가 많아집니다.
- CPU에게 직접 키보드 버튼 1개당 전선 1개를 주면 비효율적입니다. 오히려 격자를 주고 스캔사이클에 주르는 동안 AND 게이트에 활성화된 키를 감지하게 됩니다. 이렇게 되면 선을 절약하면서 무슨 키가 활성화되었는지 알 수 있습니다.
  - 문제는 CPU가 이런 스캔사이클을 계속 사용해야 합니다.
  - 마이크로프로세서가 이런 일을 대신해줄 수 있습니다.
  - 마이크로 컨트롤러가 CPU와 키보드의 중개인이 됩니다.
  - 이런 설계는 키보드에게 만 있지 않습니다.
- CPU가 파일 읽기 명령을 받아서 수행해야 하면 CPU는 제어 버스에게 명령을 전달하고 제어 버스는 디스크 장치에게 요청을 합니다.
- 디스크 장치는 CPU랑 별도로 행동합니다. 찾고자 하는 파일의 주소를 찾고 그 주소를 반환해주고 그 주소공간에 연속되게 읽어야 하면 읽어서 제어버스를 통해 CPU에게 전달해줍니다.
- CPU는 io 장치를 직접 제어하지 않고 통신을 한다는 것이 중요합니다.
- 제어버스를 이제 확인해보겠습니다. 의외로 그림을 보면 단순합니다.
  - 제어버스를 구현할 때는 즉 io를 설계할 때 고려할 것은 2가지입니다.
  - 통신 방법과 데이터 이동 방법 2가지입니다.
  - io장치는 각각의 마이크로 컨트롤러가 있어서 각각의 메모리도 있습니다. 시스템을 메모리 주소 방법으로 통신할 수 있습니다. 메모리를 공유하고 확장했다고 생각할 수 있습니다.
  - 격리 io 방법도 있습니다. 별도의 버스로 관리하는 것입니다. 병렬친화적입니다. 하지만 전선이 더 필요합니다. 각각의 메모리 역할을 하게 만들 포트가 필요해서 포트맵 io라고 알려져있습니다.
  - 각각의 장치들은 준비 비트를 폴링 비트를 별도로 두고 전압이 걸렸으면 데이터를 가져갑니다. 다른 방법은 인터럽트 주도 io 입니다. 이렇게 되면 cpu 태스크를 중단하고 다른 테스크를 점프하고 처리하고 돌아옵니다. 하드웨어 지원이 필요하지만 대부분의 하드웨어에서 지원하고 있습니다. 보통 인터럽트가 더 효율적입니다. 메모리맵핑과 인터럽트 io가 제일 많이 보일 것입니다.
- 현대 컴퓨터는 포트 io 비슷한 격리 io 비슷하게 행동하는 점들이 많습니다.
- PCI는 밴드위드가 높은 요소에 사용합니다.
- 남북 브릿지를 사용하는 방법이 있습니다. io가 집약적이면 북이 처리하고 느리면 남이 처리하는 설계입니다.
- 최근 컴퓨터를 조립하면 이제는 남북 브릿지는 사용하지 않고 포트맵핑이 CPU 성능이 좋아지면서 더 많이 보이게 되었습니다.
  - 남북브릿지의 기능이 CPU로 많이 이동하고 일부 남은 북브릿지와 대부분의 남브릿지의 기능은 칩세트라는 마더보드 요소 바뀌었습니다.
- 여기서 의문은 포트맵 io 방식을 하드웨어상 그대로 사용할 수 있는 것처럼 보이는데 굳이 메모리 맵 io를 사용하는 이유입니다. 1980대의 문제를 이해해야 합니다. 1980년대는 하드웨어와 소프트웨어는 상호운용이 불가능했습니다. 과거 CPU는 와 메모리 맵핑은 제조사마다 각각의 레이아웃을 가졌습니다.
  - 지금시대에 하드웨어를 구매했는데 서로의 메모리 주소가 겹쳐서 이상한 행동을 한다고 생각하면 엄청난 악몽일 것 입니다.
  - 이론적으로 하드웨어마다 필요한 메모리 주소를 동적으로 처리하게 만들면 해결 될 것 아닌가? 이론적으로 맞습니다. 이렇게 되면 핸드쉐이크 과정이 필요합니다. 각각의 표준이 있으면 처음부터 하드웨어가 그 표준을 그냥 지키면 되는 것입니다. 이것이 가장 간결한 이유입니다. 
- 모든 장치는 각자 고유한 언어를 구사한다고 생각해야 합니다. 이 서로 번역해주는 역할을 해주는 것이 드라이버입니다.
