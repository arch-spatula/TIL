# 블로그 다시 만들기 113일차

1일1커밋 무사고: 1044일차

## 감사일기

1. ???

## todo

- [ ] Do it C++ 코딩 테스트
  - [ ] 3일차
    - [ ] 투 포인터
      - [x] 연속된 자연수의 합 구하기
      - [ ] 주몽의 명령
    - [ ] 슬라이딩 윈도우
  - [ ] 4일차
    - [ ] 스택과 큐
  - [ ] 5일차
    - [ ] 버블 정렬
    - [ ] 선택 정렬
  - [ ] 6일차
    - [ ] 삽입 정렬
    - [ ] 퀵 정렬


---

## 투 포인터

- 확실히 투 포인터 문제의 전형이라고 보입니다.

```cpp 
#include <ios>
#include <iostream>

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(NULL);
  std::cout.tie(NULL);

  int n;
  std::cin >> n;

  int sum = 1;
  int count = 1;
  int startIdx = 1;
  int endIdx = 1;

  while (endIdx != n) {
    if (sum > n) {
      sum -= startIdx;
      startIdx += 1;
      continue;
    }
    if (sum < n) {
      endIdx += 1;
      sum += endIdx;
      continue;
    }
    if (sum == n) {
      endIdx += 1;
      sum += endIdx;
      count += 1;
      continue;
    }
  }

  std::cout << count << '\n';

  return 0;
}
```

## 주몽

- https://www.acmicpc.net/problem/1940
- 주몽이라고 합니다.
- 데이터의 사이즈를 확인해보는 것으로 시작해야 합니다.
  - 아직은 문제를 분석하는 단계입니다.

```cpp 
#include <iostream>
#include <limits>

int main() {
  std::cout << (std::numeric_limits<int>::max() > 10000000) << std::endl;
  return 0;
}
```

- `1`을 출력해서 int 자료형을 사용해도 괜찮다는 것을 알아냈습니다.
- 제한 시간은 2초 정도 됩니다.
- 브루트 포트 방식을 사용한다면 2번 중첩 순회해서 풀 것입니다.
  - $O(n^{2})$ 시간 복잡성을 가질 수 있습니다.
  - 책에서는 정렬을 하고 투포인터를 적용하면 $O(n log n)$ 시간 복잡성으로 풀어내는 것이 가능하다고 합니다.


