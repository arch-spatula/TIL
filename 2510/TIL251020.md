# 블로그 다시 만들기 112일차

1일1커밋 무사고: 1043일차

## 감사일기

1. ???

## todo

- [ ] Do it C++ 코딩 테스트
  - [ ] 3일차
    - [ ] 투 포인터
    - [ ] 슬라이딩 윈도우
  - [ ] 4일차
    - [ ] 스택과 큐
  - [ ] 5일차
    - [ ] 버블 정렬
    - [ ] 선택 정렬
  - [ ] 6일차
    - [ ] 삽입 정렬
    - [ ] 퀵 정렬

---

## 연속된 자연수의 합 구하기

- https://www.acmicpc.net/problem/2018
- 수들의 합 5
- 손으로 그려보면 $O(2n)$ 시간 복잡성을 갖고 결국 $O(n)$ 시간복잡성으로 분류할 수 있을 것 같습니다.
- $n(n+1) / 2$ 라는 등차수열 합의 공식을 사용하는 방법이 있기는 하지만 이전의 계산을 계속 활용한다는 내용을 발견했습니다.
  - 제가 등차수열의 값을 활용하면 오히려 선형시간복잡성의 기울기를 높이는 것입니다.
  - 기울기 값을 낮추기 위해 더 몇번 없는 작업횟수로 처리해야 합니다.
- 책의 설명을 확인하고 이전의 계산된 결과를 활용할 수 있었습니다. 만약에 처음 풀었다면 아마 등차수열의 합 공식을 그대로 사용했을 것 같습니다.

```
sum > N : sum -= startIdx; startIdx++;
sum < N : endIdx++; sum += endIdx;
sum == N : endIdx++; sum += endIdx; count++;
```

- 위가 핵심 로직입니다. 작으면 startIdx를 높이고 빼면 됩니다.
- 값이 부족하면 end를 옮기면 됩니다.

```
v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 1
^

v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 3
  ^

v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 6
    ^

v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 10
      ^

v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 15; count = 2;
        ^

v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 21;
          ^

  v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 20;
          ^

    v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 18;
          ^

      v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 15; count = 3;
          ^

      v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 22;
            ^

        v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 18;
            ^

          v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 13;
            ^

          v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 21;
              ^

            v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 15; count = 4;
              ^

            v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 24;
                ^

              v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 17;
                ^

                v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 9;
                ^

                v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 19;
                  ^

                  v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 10;
                  ^

                  v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 21;
                      ^

                      v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 11;
                      ^

                      v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 23;
                         ^

                         v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 12;
                         ^

                         v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 25;
                            ^

                            v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 13;
                            ^

                            v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 27;
                               ^

                               v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 14;
                               ^

                               v
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 29; // 종료 시점 여기 이미 1개인 본인을 포함함
                                  ^
```

- 여기서 더 의문은 배열이 필요한가?
- 최종코드를 잠깐 봤는데 정말로 배열을 만드는 행위는 없었습니다.
