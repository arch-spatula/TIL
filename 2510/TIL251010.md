# 블로그 다시 만들기 102일차

1일1커밋 무사고: 1033일차

## 감사일기

1. ???

## todo

- [ ] Do it C++ 코딩 테스트
  - [ ] 3일차
    - [x] 구간 합
    - [ ] 정답 이해해보기
      - 이 내용은 책과 무관하게 따로 탐구해봐야 할 것 같습니다.
    - [ ] 구간 합 구하기 2
- [ ] 마이크로 튜토리얼
  - [ ] Chapter 4 - Request Lines
  - [ ] Chapter 5 - HTTP Headers
  - [ ] Chapter 6 - HTTP Body
  - [ ] Chapter 7 - HTTP Responses
  - [ ] Chapter 8 - Chunked Encoding
  - [ ] Chapter 9 - Binary Data
- [ ] 블로그 다시 만들기 전 실험
  - [ ] vite로 github pages가 정적 리소스 응답하는 방식 흉내내기
  - [ ] ToC
    - [ ] `data.json`에 h1 ~ h6에 해당하는 데이터 추가
    - [ ] DOM에 붙이기
  - [ ] 검색 팝업에서 tag 클랙해도 input 상태 보존하기


---

```cpp 
#include <iostream>
#include <ostream>
#include <vector>

int main() {
  int size = 0;
  int query = 0;
  std::cin >> size >> query;

  std::vector<int> subSum(size + 1);
  subSum[0] = 0;
  for (int i = 1; i <= size; i++) {
    int temp;
    std::cin >> temp;
    subSum[i] = temp + subSum[i - 1];
  }

  for (int i = 0; i < query; i++) {
    int startIdx = 0;
    int endIdx = 0;
    std::cin >> startIdx >> endIdx;
    std::cout << subSum[endIdx] - subSum[startIdx - 1] << std::endl;
  }
  return 0;
}
```

- 위는 제가 작성한 답안입니다.
- 제출하면 시간초과가 발생합니다.
- C++이 보이지 않는 제어흐름이 이런저런 성능저하를 유발했다고 합니다.
- C++의 구현 디테일 이슈가 문제를 틀리게 만들었습니다. 로직자체는 문제가 아니었습니다.

```cpp 
#include <iostream>
#include <ostream>
#include <vector>

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(NULL);
  std::cout.tie(NULL);

  int size, query;
  std::cin >> size >> query;

  std::vector<int> subSum(size + 1, 0);

  for (int i = 1; i <= size; i++) {
    int temp;
    std::cin >> temp;
    subSum[i] = temp + subSum[i - 1];
  }

  for (int i = 0; i < query; i++) {
    int startIdx, endIdx;
    std::cin >> startIdx >> endIdx;
    std::cout << subSum[endIdx] - subSum[startIdx - 1] << '\n';
  }
  return 0;
}
```

- 위는 책에서 알려주는 시간 단축 방법입니다.
- 위 3가지 구문은 자주 사용하는 관용어구 같습니다.
- `std::ios::sync_with_stdio(false);`은 C++의 iostream의 동기화를 비활성화, 독립 버퍼 사용으로 수행 속도를 높인다고 합니다.
- `std::cin.tie(NULL); std::cout.tie(NULL);`은 하나로 묶인 두 스트림을 푼다고 합니다.
  - `cin`, `cout`은 하나로 묶였다고 합니다. 한 스트림이 다른 스트림에서 각 io 작업을 진행하기 전 자동으로 버퍼를 비워주는 것을 보장한다고 합니다. 정확히 무슨 의미인지 잘 모르겠습니다.
  - `cin`을 수행하기 전에 기본적으로 `cout` 출력 버퍼를 지우는 작업을 수행하는데 이 작업을 생략한다고 합니다. 이렇게 지우는 동작이 사라지면서 성능을 더 높입니다.
  - 멀티스레드 환경과 화면 출력부분에 의도랑 다르게 동작할 가능성이 높습니다. 실제 프로젝트에서는 피해야 하는 구문입니다. 코딩테스트는 대부분의 경우 싱글 쓰레드 환경입니다. 물론 이제 이 지식을 알게된 면접관인 저라면 멀티쓰레드 환경 문제를 내볼 것 같습니다. 코딩테스트는 싱글 쓰레드로 문제를 풀어야 합니다.
- https://velog.io/@d2h10s/c-iossyncwithstdio%EB%9E%80
  - 처음 검색해서 알게 된 블로그 자료입니다.
- https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull
  - 조금 더 좋을 것이라고 생각되는 자료입니다.

