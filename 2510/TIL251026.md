# 블로그 다시 만들기 118일차

1일1커밋 무사고: 1일차

## 감사일기

1. ???

## todo

- [ ] ???

---

- 1일 1커밋을 다시 정의해야 할 때가 된 것 같습니다.
- 진정으로 성장을 측정할 수 없게 되었습니다.
- 진정으로 성장을 측정할 수 없으면 의미를 잃게 됩니다.
- 이런 이유로 til은 정말 무엇을 배운 것이 있는 날에만 작성할 것입니다.

## 주몽

- https://www.acmicpc.net/problem/1940
- 주몽이라고 합니다.
- 데이터의 사이즈를 확인해보는 것으로 시작해야 합니다.
  - 아직은 문제를 분석하는 단계입니다.

```cpp
#include <iostream>
#include <limits>

int main() {
  std::cout << (std::numeric_limits<int>::max() > 10000000) << std::endl;
  return 0;
}
```

- `1`을 출력해서 int 자료형을 사용해도 괜찮다는 것을 알아냈습니다.
- 제한 시간은 2초 정도 됩니다.
- 브루트 포트 방식을 사용한다면 2번 중첩 순회해서 풀 것입니다.
  - $O(n^{2})$ 시간 복잡성을 가질 수 있습니다.
  - 책에서는 정렬을 하고 투포인터를 적용하면 $O(n log n)$ 시간 복잡성으로 풀어내는 것이 가능하다고 합니다.

```
v
1 2 3 4 5 7 // 8 < 9
          ^

  v
1 2 3 4 5 7 // 9 == 9, count = 1
          ^

    v
1 2 3 4 5 7 // 8 < 9
        ^

      v
1 2 3 4 5 7 // 9 == 9, count = 2
        ^

        v
1 2 3 4 5 7 // break
      ^
```

- 위가 구현하고 싶은 알고리즘입니다.

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // std::sort

int main() {
    std::vector<int> v = {5, 2, 8, 1, 3};

    std::sort(v.begin(), v.end()); // 오름차순 정렬

    for (int x : v)
        std::cout << x << " ";
}
```

- C++의 정렬 함수를 모르고 있었습니다.
- `std::sort(v.begin(), v.end(), std::greater<int>());`은 내림차순 정렬이라고 합니다.
- `for (int x : v)`같은 표현도 알게되었습니다. 그냥 문법 설탕으로 보입니다.

```
6 
9
2 7 4 1 5 3
```

```cpp 
#include <algorithm>
#include <ios>
#include <iostream>

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(NULL);
  std::cout.tie(NULL);

  int size, target, startIdx = 0, endIdx, count = 0;

  std::cin >> size;
  endIdx = size - 1;

  std::cin >> target;
  std::vector<int> material(size);

  for (int i = 0; i < size; i++) {
    // 표준입력 저장
    std::cin >> material[i];
  }
  std::sort(material.begin(), material.end()); // 오름차순 정렬

  while (startIdx < endIdx) {
    int measurement = material[startIdx] + material[endIdx];
    if (measurement == target) {
      count += 1;
      startIdx += 1;
      endIdx -= 1;
    }
    if (measurement < target) {
      startIdx += 1;
    }
    if (measurement > target) {
      endIdx -= 1;
    }
  }

  std::cout << count << '\n';

  return 0;
}
```

## '좋은 수' 구하기

- https://www.acmicpc.net/problem/1253
- https://www.youtube.com/watch?v=esesL0D9vsE


