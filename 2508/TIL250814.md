# 블로그 다시 만들기 45일차

1일1커밋 무사고: 976일차

## 감사일기

1. ???

## todo

- [ ] 블로그 다시 만들기 전 실험
  - [ ] 검색 만들기
    - [ ] 검색 목록이 search popup에서 보이게 하기
      - [ ] 선택 상태 표현
    - [ ] tag 보여주기
    - [ ] url에 상태 추가
    - [ ] MPA 갬성으로 ctrl + k 상태를 url에 기록
  - [ ] ToC
    - [ ] `data.json`에 h1 ~ h6에 해당하는 데이터 추가
    - [ ] ???
  - [x] tag
    - [x] 필터 상태관리
    - [x] 활성화 태그 url에 보여주기
    - [x] 뒤로가기 앞으로가기 동기화
  - [x] MPA 갬성

---

## tag 관리를 MPA 갬성으로 처리하기

- 막상 url에 넣고 url href만 동적으로 처리하니까 잘 됩니다.
- SPA 방식으로 url 연결하고 상태관리 동기화하는데 3시간 걸렸지만 MPA 방식을 활용하니까 1시간에 구현했습니다.
- 브라우저 url 히스토리 관리를 대신 알아서 해줍니다.

## EventBus

- javaScript 내에서 `EventTarget`랑 `CustomEvent`로 옵저버 패턴을 비슷하게 구현하는 방법을 알아냈습니다.
- 싱글튼 패턴과 섞으면 값과 상태를 상당히 자유롭게 사용할 수 있을 것 같습니다.
- 타입정의랑 활용만 잘하면 SPA 없는 개발도 해볼 수 있을 것 같습니다.

```ts
const EventBus = new EventTarget();

class URLBinding {
  // ... 생략
  /**
   * URL 변경 시 실행할 로직
   * this binding이 window로 변경될 것을 방지하기 위해 화살표 함수로 정의함
   * @todo 뒤로가기를 눌렀을 때 모든 상태 동기화
   */
  handleUrlChange = (e?: Event) => {
    EventBus.dispatchEvent(
      new CustomEvent("url:change", {
        detail: {
          tags: this.readTags(),
          isBackBtn: e instanceof PopStateEvent,
        },
      }),
    );
  };
}

class TagMediator {
  urlBinding: URLBinding;
  lookup: Lookup;
  constructor(urlBinding: URLBinding, lookup: Lookup) {
    this.urlBinding = urlBinding;
    this.lookup = lookup;
    EventBus.addEventListener("url:change", (e) => {
      const customEvent = e as CustomEvent<{
        tags: string[];
        isBackBtn: boolean;
      }>;
      if (!customEvent.detail) return;
      /**
       * 여기 값이 절대 진리 값
       * 순회하고
       * 동기화하고
       * ui에 내용 반영
       */
      const tags = customEvent.detail.tags;
      this.urlBinding.tags = new Set([...tags]);
      this.lookup.sycnTags(tags);

      const isBack = customEvent.detail.isBackBtn;
      if (isBack) {
        updateBlogListUIOnece();
      }
    });
  }
  // ... 생략
}
```

- LLM이 알려준 더 단순한 예시가 있습니다.

```ts
const EventBus = new EventTarget();

class ClassA {
  trigger() {
    console.log("A 동작");
    EventBus.dispatchEvent(
      new CustomEvent("A:done", { detail: "A 실행 완료" }),
    );
  }
}

class ClassB {
  constructor() {
    EventBus.addEventListener("A:done", (e) => {
      console.log("B: A 완료 이벤트 받음 →", e.detail);
    });
  }
}

const a = new ClassA();
const b = new ClassB();

a.trigger();
```

- 별도의 3개의 객체이지만 `ClassB`는 `ClassA`의 `trigger`가 실행할 `dispatchEvent`로 구독하게 만들 수 있습니다.

