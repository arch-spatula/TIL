# 블로그 다시 만들기 32일차

1일1커밋 무사고: 963일차

## 감사일기

1. ???

## todo

- [ ] 블로그 다시 만들기 전 실험
  - [ ] 검색 만들기
    - [ ] 검색 목록이 search popup에서 보이게 하기
      - [x] ul, li로 단순하게 보여주기
      - [ ] 선택 상태 표현
    - [ ] tag 보여주기
    - [ ] url에 상태 추가
      - [x] root route가 아니면 blog 목록 가리기
  - [ ] ToC
    - [ ] `data.json`에 h1 ~ h6에 해당하는 데이터 추가
    - [ ] ???
  - [ ] tag
   - [ ] 클릭 가능하게 상태 관리하기
- [ ] 데이터 시각화 옵시디언으로 마이그레이션
  - [ ] 위치
    - [x] 돌링 카토그램(Dorling Cartogram, Dorling map)
    - [ ] 타일 격자 지도(Tile Grid map, Grid map, Equal-area cartogram)

---

## 상태 관리

- 시그널을 넣어서 상태 관리하는 것이 이 극도로 단순한 어플리케이션에 필요한 로직인가?
- 코드의 캡슐화, 관심사를 생각하면 이벤트를 처리하는 함수 내에 DOM 갱신을 처리하는 것이 적절한지 의문이 들었습니다.
  - 굳이 따지면 그냥 DOM을 잘 찾아서 랜더링 처리할 수 있으면 됩니다.
  - 별도의 시그널 로직을 만들어서 해결하는 것이 더 단순할 것이라는 생각은 너무 프레임워크 중심사고라고 보입니다.

```ts 
const handleUpdateSearchInput = (e: Event) => {
    const input = e.target as HTMLInputElement;
    console.log(input.value);
};
```

- 여기서는 값을 쓰기만 하고 실제 DOM 갱신을 하면 안 될 것 같다는 생각이 들었습니다.
- 이벤트에 의존하고 이 이벤트를 처리하면서 새로운 사이드이펙트를 만든다는 점에서는 피해야 하는 행위라고 생각이 들기는 합니다.

## 궁금해서 LLM보고 만들라고 시킨 Signal

```ts 
type EffectFn = () => void;

function createSignal<T>(initialValue: T) {
  let value = initialValue;
  const subscribers = new Set<EffectFn>();

  function get() {
    if (currentEffect) {
      subscribers.add(currentEffect);
    }
    return value;
  }

  function set(newValue: T) {
    if (newValue !== value) {
      value = newValue;
      for (const sub of subscribers) {
        sub();
      }
    }
  }

  return { get, set };
}

let currentEffect: EffectFn | null = null;

function effect(fn: EffectFn) {
  currentEffect = fn;
  fn();
  currentEffect = null;
}

function computed<T>(computeFn: () => T) {
  const result = createSignal<T>(undefined as unknown as T);

  effect(() => {
    result.set(computeFn());
  });

  return {
    get: result.get
  };
}
```

- `createSignal`, `effect`, `computed`모두 생각보다 극도로 단순했습니다.
- 하지만 개발자 블로그를 만들 때는 가능하면 사용하지 않을 것입니다.
- 순수하게 상태를 표현하는 것은 극도로 단순해 보입니다.

## 단 200줄의 스파게티

```ts 
import type { MetaObject } from "../types/types";

let saveMetaObject: null | MetaObject[] = null;

const renderMap = new Map<string, boolean>();

const tagElem = (tag: string, fileName: string) => {
  const tagItem = document.createElement("li");
  const p = document.createElement("span");

  tagItem.addEventListener("click", () => {
    /**
     * 내부 스코프에서 새로 생성해야 가장 최신의 url 상태를 접근할 수 있음
     * 클릭이 있으면 결국에는 모두 확인해보고 리랜더링을 해야 함.
     */
    const url = new URL(window.location.href);
    const values = url.searchParams.getAll("tags");

    if (saveMetaObject) {
      if (values.length === 0) {
        saveMetaObject.forEach((elem) => {
          renderMap.set(elem.fileName, true);
        });
      } else {
        saveMetaObject.forEach((elem) => {
          renderMap.set(elem.fileName, false);
        });
      }
    }

    if (values.includes(tag)) {
      tagItem.classList.remove("selected-tag-item");
      url.searchParams.delete("tags", tag);

      window.history.pushState({}, "", url.toString());
    } else {
      tagItem.classList.add("selected-tag-item");
      url.searchParams.append("tags", tag);
      renderMap.set(fileName, true);

      window.history.pushState({}, "", url.toString());
    }
    console.log(renderMap);

    rerenderBlogList();
  });

  /**
   * 새로고침했을 때 tag 확인하고 반영
   * @todo tags가 있으면
   */
  const url = new URL(window.location.href);

  const values = url.searchParams.getAll("tags");

  if (values.includes(tag)) {
    tagItem.classList.add("selected-tag-item");
    renderMap.set(fileName, true);
  }

  tagItem.classList.add("tag-item");
  p.classList.add("tag-text");
  p.innerText = `#${tag}`;
  tagItem.appendChild(p);

  return tagItem;
};

const rerenderBlogList = () => {
  console.log(renderMap);
  const blogList = document.querySelector<HTMLDivElement>(`#blog-list`);
  if (!blogList) return;
  blogList.replaceChildren();
  if (!saveMetaObject) return;

  for (const metaObject of saveMetaObject) {
    // if (values.length === 0) {
    //   renderMap.set(metaObject.fileName, true);
    // } else {
    //   renderMap.set(metaObject.fileName, false);
    // }

    const blogItemElem = blogItem(metaObject);
    if (blogItemElem) blogList.appendChild(blogItemElem);
  }
};

const blogItem = (metaObject: MetaObject) => {
  const li = document.createElement("li");
  li.classList.add("blog-item");

  const constainer = document.createElement("div");

  const blogLink = document.createElement("a");
  blogLink.classList.add("blog-link");

  if (!metaObject.htmlPath) return;
  const newPath = metaObject.htmlPath;

  blogLink.innerText = metaObject.title;
  blogLink.href = newPath;

  constainer.appendChild(blogLink);

  const dateText = document.createElement("p");
  dateText.classList.add("blog-date");

  if (metaObject.date) {
    dateText.innerText = metaObject.date;
    constainer.appendChild(dateText);
  }

  const tagList = document.createElement("ul");
  tagList.classList.add("tag-list");

  if (metaObject.tags?.length) {
    metaObject.tags.forEach((tag) => {
      tagList.appendChild(tagElem(tag, metaObject.fileName));
    });
  }

  constainer.appendChild(tagList);

  const description = document.createElement("p");
  description.classList.add("blog-description");

  if (metaObject.description) {
    description.innerText = metaObject.description;
    constainer.appendChild(description);
  }

  const line = document.createElement("hr");
  line.classList.add("blog-divider");

  constainer.appendChild(line);
  li.appendChild(constainer);

  if (!renderMap.get(metaObject.fileName)) return;

  return li;
};

/**
 * 순수하게 ui를 만들기 위한 처리들만 함.
 */
const blogList = (metaObjects: MetaObject[]) => {
  const ul = document.createElement("ul");
  ul.id = "blog-list";
  saveMetaObject = metaObjects;

  const url = new URL(window.location.href);
  const values = url.searchParams.getAll("tags");

  for (const metaObject of metaObjects) {
    if (values.length === 0) {
      renderMap.set(metaObject.fileName, true);
    } else {
      renderMap.set(metaObject.fileName, false);
    }

    const blogItemElem = blogItem(metaObject);
    if (blogItemElem) ul.appendChild(blogItemElem);
  }

  return ul;
};

export default blogList;
```

- 부분 인라인과 롤백처리하는 것이 더 적절할 것 같습니다.
- 랙시컬 스코프를 이용하고 싶어서 함수를 별도로 분리하는 것도 없습니다.
- 설계상 올바른 부분은 `renderMap`으로 상태를 관리한다는 것 정도 될 것 같습니다.
- 이번에는 시그널을 넣어볼 것입니다.

