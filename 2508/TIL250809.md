# 블로그 다시 만들기 40일차

1일1커밋 무사고: 971일차

## 감사일기

1. ???

## todo

- [ ] 블로그 다시 만들기 전 실험
  - [ ] 검색 만들기
    - [ ] 검색 목록이 search popup에서 보이게 하기
      - [ ] 선택 상태 표현
    - [ ] tag 보여주기
    - [ ] url에 상태 추가
  - [ ] ToC
    - [ ] `data.json`에 h1 ~ h6에 해당하는 데이터 추가
    - [ ] ???
  - [ ] tag
    - [ ] 필터 상태관리
    - [ ] 활성화 태그 url에 보여주기
    - [ ] ????
  - [ ] 클릭 가능하게 상태 관리하기

---

## 새로운 취미

- 잠시 새로운 취미를 만들었습니다.
- 잠시 개발자 블로그를 다시 만드는 취미에 임하지 못했습니다.
  - 회사를 다니고 있으니 개인시간이 많이 부족합니다.
- 이제 주말이고 이전에 있던 취미를 잠시 잊고 하고 있던 작업을 다시 복기해보고자 합니다.

## 양방향 그래프를 만들기

- 처음생각에는 트리라고 생각을 했었습니다.
  - 다시 생각을 해보니까 루트가 없어서 그래프가 정확합니다.
- 그래프는 맞는데 제약이 걸려있는 그래프입니다.

  - 글제목으로 접근할 수 있는 것은 태그이고 태그로 접근할 수 있는 것은 제목입니다.
  - 행에 블로그 제목을 넣고 열에 태그 이름을 넣으면 될 것 같습니다.
  - 제목은 문자 정보이고 이것을 인덱스 정보로 어떻게 변환하는 것이 적절한지
  - 여기서 딜레마는 정말 해싱 비슷한 역할이 필요한가?
    - 문자의 자릿수와 코드포인트를 활용해서 모두 고유한 문자를 만들어낼 수 있을 것이라는 생각이 들기는 합니다.
    - 하지만 문자열로 서로 접근한다면 해시맵 2개로 해결할 수 있는 것이 아닌가?
    - 2개의 Map과 Set으로 허용해주면 됩니다.

- 처음 초기화하고 모듈 스코프에 계속 살아 있어야 할 것 같습니다.

```ts
/**
 * fileName이 무슨 tag를 갖고 있는지 알아낼 수 있음
 * tag가 무슨 fileName에 달려있는지 알아낼 수 있음
 */
class Lookup {
  fileNameMap: Map<string, boolean>;
  tagMap: Map<string, boolean>;
  constructor() {}
}

const lookup = new Lookup();
```

- 사용자의 이벤트에 따라 메모리 존제하는 이 데이터는 계속 갱신 되어야 합니다. 함수의 종료와 함계 해제되어서는 안 됩니다.
- 실제 생성자 함수를 호출하는 시점에 초기화를 하면 안 되고 블로그 목록을 생성하는 시점에 초기화가 이루어 져야 할 것입니다.

```ts
/**
 * fileName이 무슨 tag를 갖고 있는지 알아낼 수 있음
 * tag가 무슨 fileName에 달려있는지 알아낼 수 있음
 * 실제 Node의 추가 삭제는 이루어지지 않고 탐색 후 해당 Node의 visable 혹은 active 상태만 제어함
 */
class Lookup {
  isFiltered: boolean;
  showFileName: Set<string>;
  activeTags: Set<string>;

  /**
   * fileName을 저장하고 fileName으로 갖고 있는 tag를 알아 낼 수 있음
   */
  fileNameMap: Map<string, Set<string>>;

  /**
   * tag을 저장하고 현재 tag를 갖고 있는 fileName을 알아 낼 수 있음
   */
  tagMap: Map<string, Set<string>>;

  constructor() {
    this.isFiltered = false;
    this.fileNameMap = new Map();
    this.tagMap = new Map();
    this.showFileName = new Set();
    this.activeTags = new Set();
  }
  filterOn() {
    this.isFiltered = true;
  }
  filterOff() {
    this.isFiltered = false;
  }

  /**
   * 모든 fileName과 tag의 관계를 최초로 만들어내는 시점
   * @todo url에서 필터가 되어 있고 안 되어 있고 상태 반영하기
   */
  init(metaObjects: MetaObject[]) {
    metaObjects.forEach((metaObject) => {
      if (metaObject.tags?.length) {
        metaObject.tags.forEach((tag) => {
          this.addVertex(metaObject.fileName, tag);
        });
      } else {
        this.addVertex(metaObject.fileName);
      }
    });
  }
  /**
   * 양방향 노드
   */
  addVertex(fileNameNode: string, tagNode?: string) {
    if (!tagNode) {
      this.fileNameMap.set(fileNameNode, new Set());
      return;
    }

    const tagSet = this.fileNameMap.get(fileNameNode);
    if (tagSet) {
      tagSet.add(tagNode);
    } else {
      this.fileNameMap.set(fileNameNode, new Set([tagNode]));
    }

    const fileNameSet = this.tagMap.get(tagNode);
    if (fileNameSet) {
      fileNameSet.add(fileNameNode);
    } else {
      this.tagMap.set(tagNode, new Set<string>([fileNameNode]));
    }
  }
}
```

- 성능은 모르겠습니다. 하지만 캡슐화는 하려고 합니다.
- 꽤 복잡한 상태가 될 것을 예상해서 브라우저의 구현 디테일을 최대한 숨기는 방향으로 만들어야 할 것 같습니다.
  - 원래 생각은 브라우저 url 값을 접근할 생각을 했지만 있으면 안 될 것 같습니다.
  - 최대한 순수한 상태관리만 이루어져야 할 것 같습니다.

```ts
/**
 * fileName이 무슨 tag를 갖고 있는지 알아낼 수 있음
 * tag가 무슨 fileName에 달려있는지 알아낼 수 있음
 * 실제 Node의 추가 삭제는 이루어지지 않고 탐색 후 해당 Node의 visable 혹은 active 상태만 제어함
 */
class Lookup {
  isFiltered: boolean;
  /**
   * 목록에 있으면 랜더링 처리
   */
  showFileName: Set<string>;

  /**
   * 활성화 된 태그
   */
  activeTags: Set<string>;

  /**
   * fileName을 저장하고 fileName으로 갖고 있는 tag를 알아 낼 수 있음
   */
  fileNameMap: Map<string, Set<string>>;

  /**
   * tag을 저장하고 현재 tag를 갖고 있는 fileName을 알아 낼 수 있음
   */
  tagMap: Map<string, Set<string>>;

  constructor() {
    this.isFiltered = false;
    this.fileNameMap = new Map();
    this.tagMap = new Map();
    this.showFileName = new Set();
    this.activeTags = new Set();
  }

  filterOn() {
    this.isFiltered = true;
    this.showFileName.clear();
  }

  filterOff() {
    this.isFiltered = false;
    // 필터가 해제 되면 모든 것이 보여야 함.
    this.fileNameMap.forEach((_, key) => {
      this.showFileName.add(key);
    });
  }

  toggleTag(tag: string) {
    if (this.activeTags.has(tag)) {
      this.removeActiveTag(tag);
    } else {
      this.addActiveTag(tag);
    }
  }

  addActiveTag(tag: string) {
    if (!this.activeTags.size) {
      this.filterOn();
    }
    this.activeTags.add(tag);
    this.activeTags.forEach((activeTag) => {
      const fileNameSet = this.tagMap.get(activeTag);
      if (!fileNameSet) return;
      fileNameSet.forEach((fileName) => {
        this.showFileName.add(fileName);
      });
    });
  }

  removeActiveTag(tag: string) {
    this.activeTags.delete(tag);
    this.activeTags.forEach((activeTag) => {
      const fileNameSet = this.tagMap.get(activeTag);
      if (!fileNameSet) return;
      fileNameSet.forEach((fileName) => {
        this.showFileName.delete(fileName);
      });
    });
    if (!this.activeTags.size) {
      this.filterOff();
    }
  }

  /**
   * 모든 fileName과 tag의 관계를 최초로 만들어내는 시점
   * @todo url에서 필터가 되어 있고 안 되어 있고 상태 반영하기
   */
  init(metaObjects: MetaObject[]) {
    metaObjects.forEach((metaObject) => {
      if (metaObject.tags?.length) {
        metaObject.tags.forEach((tag) => {
          this.addVertex(metaObject.fileName, tag);
        });
      } else {
        this.addVertex(metaObject.fileName);
      }
    });
    this.filterOff();
  }

  /**
   * 양방향 노드
   */
  addVertex(fileNameNode: string, tagNode?: string) {
    if (!tagNode) {
      this.fileNameMap.set(fileNameNode, new Set());
      return;
    }

    const tagSet = this.fileNameMap.get(fileNameNode);
    if (tagSet) {
      tagSet.add(tagNode);
    } else {
      this.fileNameMap.set(fileNameNode, new Set([tagNode]));
    }

    const fileNameSet = this.tagMap.get(tagNode);
    if (fileNameSet) {
      fileNameSet.add(fileNameNode);
    } else {
      this.tagMap.set(tagNode, new Set<string>([fileNameNode]));
    }
  }
}
```

- 원래는 데이터를 정확하게 표현하는 것이 중요하다고 생각 되었는데 그럴 필요는 없던 것 같습니다.
- 무엇을 보여줄지 무엇을 보여주지 말지 제어하는 것이 더 중요한 것입니다.
- 태그도 무엇이 활성화 된 것이고 무엇이 활성화 된 것이 아닌지 구분하는 것이 더 중요합니다.

### 버그 고치기

```ts 
/**
 * fileName이 무슨 tag를 갖고 있는지 알아낼 수 있음
 * tag가 무슨 fileName에 달려있는지 알아낼 수 있음
 * 실제 Node의 추가 삭제는 이루어지지 않고 탐색 후 해당 Node의 visable 혹은 active 상태만 제어함
 */
class Lookup {
  isFiltered: boolean;
  /**
   * 목록에 있으면 랜더링 처리
   */
  showFileName: Set<string>;

  /**
   * 활성화 된 태그
   */
  activeTags: Set<string>;

  /**
   * fileName을 저장하고 fileName으로 갖고 있는 tag를 알아 낼 수 있음
   */
  fileNameMap: Map<string, Set<string>>;

  /**
   * tag을 저장하고 현재 tag를 갖고 있는 fileName을 알아 낼 수 있음
   */
  tagMap: Map<string, Set<string>>;

  constructor() {
    this.isFiltered = false;
    this.fileNameMap = new Map();
    this.tagMap = new Map();
    this.showFileName = new Set();
    this.activeTags = new Set();
  }

  filterOn() {
    this.isFiltered = true;
    this.showFileName.clear();
  }

  filterOff() {
    this.isFiltered = false;
    // 필터가 해제 되면 모든 것이 보여야 함.
    this.fileNameMap.forEach((_, key) => {
      this.showFileName.add(key);
    });
  }

  toggleTag(tag: string) {
    if (this.activeTags.has(tag)) {
      this.removeActiveTag(tag);
    } else {
      this.addActiveTag(tag);
    }
  }

  addActiveTag(tag: string) {
    if (!this.activeTags.size) {
      this.filterOn();
    }
    this.activeTags.add(tag);
    this.activeTags.forEach((activeTag) => {
      const fileNameSet = this.tagMap.get(activeTag);
      if (!fileNameSet) return;
      fileNameSet.forEach((fileName) => {
        this.showFileName.add(fileName);
      });
    });
  }

  /**
   * @todo 갱신되어 삭제해야 할 특정 원소만 찾아 삭제하기
   */
  removeActiveTag(tag: string) {
    this.activeTags.delete(tag);

    this.showFileName.clear();
    this.activeTags.forEach((activeTag) => {
      const fileNameSet = this.tagMap.get(activeTag);
      if (!fileNameSet) return;
      fileNameSet.forEach((fileName) => {
        this.showFileName.add(fileName);
      });
    });

    if (!this.activeTags.size) {
      this.filterOff();
    }
  }

  /**
   * 모든 fileName과 tag의 관계를 최초로 만들어내는 시점
   * @todo url에서 필터가 되어 있고 안 되어 있고 상태 반영하기
   */
  init(metaObjects: MetaObject[]) {
    metaObjects.forEach((metaObject) => {
      if (metaObject.tags?.length) {
        metaObject.tags.forEach((tag) => {
          this.addVertex(metaObject.fileName, tag);
        });
      } else {
        this.addVertex(metaObject.fileName);
      }
    });
    this.filterOff();
  }

  /**
   * 양방향 노드
   */
  addVertex(fileNameNode: string, tagNode?: string) {
    if (!tagNode) {
      this.fileNameMap.set(fileNameNode, new Set());
      return;
    }

    const tagSet = this.fileNameMap.get(fileNameNode);
    if (tagSet) {
      tagSet.add(tagNode);
    } else {
      this.fileNameMap.set(fileNameNode, new Set([tagNode]));
    }

    const fileNameSet = this.tagMap.get(tagNode);
    if (fileNameSet) {
      fileNameSet.add(fileNameNode);
    } else {
      this.tagMap.set(tagNode, new Set<string>([fileNameNode]));
    }
  }
}
```

- 제일 단순하게 고치는 방법을 택했습니다. 그냥 모두 비우고 다시 값을 설정하도록 했습니다.
- 정확히 갱신되어야 할 특정부분만 갱신하도록 하려고 했는데 데이터량이 천문학적인 것도 아니고 일단 편안하고 단순한 구현을 하기로 했습니다.
