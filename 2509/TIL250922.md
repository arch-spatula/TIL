# 블로그 다시 만들기 84일차

1일1커밋 무사고: 1015일차

## 감사일기

1. ???

## todo

- [ ] 운동
  - [ ] 클라이밍
    - [ ] 09월 23일
    - [ ] 09월 28일
  - [ ] 헬스
  - [ ] 자전거
- [ ] Do it C++ 코딩 테스트
  - [ ] C++ nvim DAP에 표준입력이 가능하게 설정해보기
  - [ ] 2일차
    - 읽다가 사이드 퀘스트가 생겼습니다.
- [ ] 마이크로 튜토리얼
  - [ ] Chapter 4 - Request Lines
  - [ ] Chapter 5 - HTTP Headers
  - [ ] Chapter 6 - HTTP Body
  - [ ] Chapter 7 - HTTP Responses
  - [ ] Chapter 8 - Chunked Encoding
  - [ ] Chapter 9 - Binary Data
- [ ] 블로그 다시 만들기 전 실험
  - [ ] vite로 github pages가 정적 리소스 응답하는 방식 흉내내기
  - [ ] ToC
    - [ ] `data.json`에 h1 ~ h6에 해당하는 데이터 추가
    - [ ] DOM에 붙이기
  - [ ] 검색 팝업에서 tag 클랙해도 input 상태 보존하기

---

## Chapter 4 - Request Lines

```go
type chunkReader struct {
	data            string
	numBytesPerRead int
	pos             int
}

// Read reads up to len(p) or numBytesPerRead bytes from the string per call
// its useful for simulating reading a variable number of bytes per chunk from a network connection
func (cr *chunkReader) Read(p []byte) (n int, err error) {
	if cr.pos >= len(cr.data) {
		return 0, io.EOF
	}
	endIndex := cr.pos + cr.numBytesPerRead
	if endIndex > len(cr.data) {
		endIndex = len(cr.data)
	}
	n = copy(p, cr.data[cr.pos:endIndex])
	cr.pos += n

	return n, nil
}
```

- 위를 추가하고 테스트코드를 수정하고 다시 작성하는데 이부분은 한번 더 들어야 할 것 같습니다.
- 테스트코드를 한번데 통과시키 못하고 EOF 에러를 발생시켰습니다.
  - `cr.pos >= len(cr.data)`에서 조건문이 참이 되고 `EOF`을 반환시킨 로직이 실행된 것으로 보입니다.
  - 여기 시점부터 go 언어를 위한 디버거를 설치하는 것이 더 이펙티브할 것으로 생각 됩니다.
