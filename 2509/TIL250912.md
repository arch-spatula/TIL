# 블로그 다시 만들기 74일차

1일1커밋 무사고: 1005일차

## 감사일기

1. ???

## todo

- [ ] 운동
  - [ ] 금요일 혹은 일요일 자전거
    - [x] 금요일에 비오면 손톱 정리하기
  - [ ] 토요일 클라이밍
- [ ] Do it C++ 코딩 테스트
  - [x] 1일차
  - [ ] 2일차
- [ ] 블로그 다시 만들기 전 실험
  - [ ] ToC
    - [ ] `data.json`에 h1 ~ h6에 해당하는 데이터 추가
    - [ ] DOM에 붙이기
  - [ ] 검색 팝업에서 tag 클랙해도 input 상태 보존하기
- [ ] 취미로 읽는 통계 관련 자료들
  - [ ] 조사론 필기 옮기기
    - [ ] 6장
    - [ ] 7장
    - [ ] 8장
    - [ ] 9장
    - [ ] 복습

---

## 시간복잡도란

- 시간 복잡도라는 것은 이미 알고 있습니다.


$$ 
{O}(n),\qquad \Omega(n),\qquad \Theta(n)
$$

- 시간 복잡도라는 것은 위로 표현합니다. 보통 최악의 경우를 높이면 다른 모든 경우가 높아져서 최악의 경우만 생각합니다.
  - 하지만 오메가가 최선, 세타가 보통의 경우라는 것도 같이 기억해둡시다.
- 코딩테스트에서 테스트는 로직 테스트를 하고 거기에 성능테스트까지 포함해야 합니다.
  - 지원자가 너무 많다면 당연히 모두 풀어야 면접의 기회를 얻을 것입니다.
- 제한 시간은 2초이고 1억개의 데이터를 처리해야 한다고 하면 알고리즘의 시간복잡성을 결정해야 합니다.
  - 도시 괴담은 공간복잡성도 고려해야 하는 문제도 나온다고 합니다.
  - $n^2$의 시간복잡성을 선택할지 $n \cdot log n$을 선택할지 본인이 결정해야 합니다.
  - 1억개의 데이터가 들어오는데 $n^2$를 선택하고 1초당 1억개의 연산이 가능하다면 10초 정도 예상해볼 수 있습니다. 아마 시간초과로 실패 판정을 받을 것입니다.
  - 반대로 1억개의 데이터를 받아도 2초 제한 시간 내에 1.5초 예상되는 $n \cdot log n$ 알고리즘을 선택하면 통과를 받을 수 있을 것입니다.

## cpp srand(time(NULL))로 난수 생성할 때

```
cpp error: implicit conversion loses integer precision: 'time_t' (aka 'long') to 'unsigned int' [-Werror,-Wshorten-64-to-32]
```


```cpp 
#include <cstddef>
#include <cstdlib>
#include <ctime>
#include <iostream>

int main() {
  int findNumber;
  srand(time(NULL)); // 여기가 범인
  findNumber = rand() % 100;

  for (int i = 0; i < 100; i++) {
    if (i == findNumber) {
      std::cout << i;
      break;
    }
  }

  return 0;
}
```

- 책의 예제를 따라 작성하다가 발생한 에러입니다.
- LLM에게 질문하니까 정밀도 손실이 발생하면 에러로 승격하는 컴파일러 옵션 때문에 발생했다고 합니다.

```make
build:
	g++ -o ex01 ex01.cpp -Wall -Wextra -Werror -pedantic -O2 -std=c++17 -Wshadow -Wnon-virtual-dtor -Wold-style-cast -Wcast-align -Wunused -Woverloaded-virtual -Wpedantic -Wconversion -Wsign-conversion -Wmisleading-indentation
```

- `-Wconversion`, `-Werror` 2가지 옵션이 경고를 에러로 승격시켜줬다고 합니다.
- 정밀도는 `time(nullptr)`의 반환 타입이 `time_t`인데 `unsigned int`에 담으면 짤림 현상이 발생합니다.
  - `time_t`은 보통 `long`(64비트)입니다.
  - 64비트 정도 큰 데이터를 32비트에 담으면 앞의 32비트가 짤리는 문제가 생깁니다.

```cpp 
#include <cstddef>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <random>

int main() {
  std::mt19937 gen(std::random_device{}());
  std::uniform_int_distribution<int> dist(0, 99);

  int findNumber = dist(gen);

  for (int i = 0; i < 100; i++) {
    if (i == findNumber) {
      std::cout << i;
      break;
    }
  }

  return 0;
}
```

- 저는 위 방식을 더 선호하지만 책을 위해 아래 방식을 활용할 것입니다.

```cpp 
#include <cstddef>
#include <cstdlib>
#include <ctime>
#include <iostream>

int main() {
  int findNumber;
  srand(static_cast<unsigned int>(time(NULL))); // ✅ 명시적 캐스팅
  findNumber = rand() % 100;

  for (int i = 0; i < 100; i++) {
    if (i == findNumber) {
      std::cout << i;
      break;
    }
  }

  return 0;
}
```

- 위처럼 작성할 것입니다.
