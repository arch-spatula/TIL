# 블로그 다시 만들기 76일차

1일1커밋 무사고: 1007일차

## 감사일기

1. ???

## todo

- [ ] 운동
  - [ ] 헬스
  - [ ] 자전거
  - [ ] 클라이밍
- [ ] 마이크로 튜토리얼
  - [ ] Chapter 2 - TCP
  - [ ] Chapter 3 - Requests
  - [ ] Chapter 4 - Request Lines
  - [ ] Chapter 5 - HTTP Headers
  - [ ] Chapter 6 - HTTP Body
  - [ ] Chapter 7 - HTTP Responses
  - [ ] Chapter 8 - Chunked Encoding
  - [ ] Chapter 9 - Binary Data
- [ ] 블로그 다시 만들기 전 실험
  - [ ] vite로 github pages가 정적 리소스 응답하는 방식 흉내내기
  - [ ] ToC
    - [ ] `data.json`에 h1 ~ h6에 해당하는 데이터 추가
    - [ ] DOM에 붙이기
  - [ ] 검색 팝업에서 tag 클랙해도 input 상태 보존하기
- [ ] 취미로 읽는 통계 관련 자료들
  - [ ] 조사론 필기 옮기기
    - [ ] 6장
    - [ ] 7장
    - [ ] 8장
    - [ ] 9장
    - [ ] 복습

---

## From TCP to HTTP | Full Course by ThePrimeagen

- https://youtu.be/FknTw9bJsXM?t=250
- https://www.boot.dev/courses/learn-http-protocol-golang

```go
package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
)

func main() {
	f, err := os.Open("messages.txt")
	if err != nil {
		log.Fatal("error", err)
	}
	str := ""
	for {
		data := make([]byte, 8)
		n, err := f.Read(data)
		if err != nil {
			break
		}

		data = data[:n]
		if i := bytes.IndexByte(data, '\n'); i != -1 {
			str += string(data[:n])
			data = data[i+1:]
			fmt.Printf("read: %s\n", str)
			str = ""
		}
		str = string(data)

	}
	if len(str) == 0 {
		fmt.Printf("read: %s\n", str)
	}
}
```

- 파일을 8바이트 단위로 읽는 다는 것은 이해가 됩니다.
- 이해가 안 되는 부분은 인덱스 정보가 없는데 어떻게 data는 for 문을 돌면서 다음 인덱스의 바이트를 알 수 있는가?
- 일반적인 C 언어라면 인덱스를 높였을 것입니다.
- LLM에게 질문으로 얻은 답변은 커널에서 어디를 읽고 있는지 관리하고 있다고 합니다.
  - `f.Read(data)`에서 파일 포인터를 추상화하 한 것이라고 생각해야 합니다.
  - 변수 `f`에서 오프셋을 유지하고 있다고 생각해야 합니다.

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
)

func getLinesChannel(f io.ReadCloser) <-chan string {
	out := make(chan string, 1)
	go func() {
		defer f.Close()
		defer close(out)

		str := ""
		for {
			data := make([]byte, 8)
			n, err := f.Read(data)
			if err != nil {
				break
			}

			data = data[:n]
			if i := bytes.IndexByte(data, '\n'); i != -1 {
				str += string(data[:i])
				data = data[i+1:]
				out <- str
				str = ""
			}
			str += string(data)

		}
		if len(str) != 0 {
			out <- str
		}
	}()
	return out
}

func main() {
	f, err := os.Open("messages.txt")
	if err != nil {
		log.Fatal("error", err)
	}

	lines := getLinesChannel(f)

	for line := range lines {
		fmt.Printf("read: %s\n", line)
	}
}

```

- 튜토리얼을 보면서 따라한 코드의 결과는 위와 같습니다.
- 하지만 먼저 해야 할 것은 이해입니다.
- 이번 튜토리얼에서는 go 언어의 파일 입출력정도를 다룬 것입니다. 네트워크 지식을 다룬 것이 아닙니다.
  - https://youtu.be/FknTw9bJsXM?t=889
