1일1커밋 무사고: 141일차

04:45

# todo

- [ ] 유데미 강의 2강 이상 수강
- [ ] 지원 이력서 수정 후 재 업로드
- [ ] 1일 3제
- [x] 20:00 챌린지 특강 듣기
- [x] 이력서 피드백
- [x] 설명회 듣기
- [x] 면접 질문 2개 답변

# 기업지원

이력서는 100개 단위로 들어옵니다. 100개 중 임펙트 있는 몇개가 되어야 합니다. 임펙트가 없으면 재검토 없을 90개 됩니다.

기업이 성장가능성을 가장 주목한다고 합니다. 당연히 구라입니다.

중요한 것은 현재 기업에 어떤 가치를 당장 전달할 수 있는가? 이부분에 제일 많이 집중해야 합니다.

탈락이 스트레스가 되는 이유는 아무래도 이력서, 포트폴리오, 면접 준비에 노력을 많이 했는데 인정을 못받는 부분입니다.

당연히 어떻게 못합니다. 익숙해져야 합니다.

# 프론트엔드 프리온보딩 과정 설명회

프리온보딩은 기업합류 직전 교육과정이라 생각해주면 됩니다.

사전과제는 취업가능성이 제일 높은 사람들부터 선발하는 것입니다. 그래서 잘해야 합니다.

이번 지원을 놓치면 6월을 노려야 합니다. 하지만 6월에 무조건 할 것이라고 보장할 수 없습니다. 취소가능성도 있습니다.

팀은 6 ~ 8명이고 4주 고정입니다.

기업과제 난이도는 신입 수준도 있습니다. 하지만 과정 설계는 뽑고 싶은사람을 기준으로 했습니다.

혹시나 중간에 취업이 되었으면 팀원에게 잘 이야기하도록 합니다.

# Semantic HTML의 필요성을 예시를 들어 설명해주세요.

기업 차원에서는 SEO의 우위를 위해 필요합니다. SEO에 더 유리한 이유는 브라우저 정책상 시멘틱 태그를 잘 활용할 때 더 높은 점수를 부여합니다. 또 스크린 리더입장에서는 콘텐츠 유형과 의미를 유추하기 더 쉬워져 웹 접근성을 높일 수 있습니다. 또 프로그래머가 마크업을 읽고 제어할 때 그 의미와 역할 및 관계를 쉽게 유추할 수 있습니다.

```html
<header>
  <div class="logo">
    <img src="logo.png" alt="My Website" />
  </div>
  <nav>
    <ul>
      <li><a href="#">Home</a></li>
      <li><a href="#">About</a></li>
      <li><a href="#">Contact</a></li>
    </ul>
  </nav>
</header>
```

# Redux 상태관리의 주요 개념들과 연결 관계를 설명해주세요. 다른 상태관리 도구와 비교 설명 해주세요.

핵심용어: action(type, function), dispatcher, store, selector, slice, reducer, payload, state, subscribe, Builder, Middleware, Thunk

Redux의 상태관리 라이브러리로 2가지 패턴을 갖고 있습니다. ducks 패턴과 flux 패턴입니다.

ducks 패턴은 Redux가 하나의 통합된 Store에서 State를 관리하는 패턴을 의미합니다. ~~개인적으로는 패턴보단 독선이라고 생각합니다.~~ 각설하고 중요한 점은 단일 모듈 즉 모든 길이 로마로 향하듯이 모든 State는 Store에 담습니다. Store 모듈 하나 안에 모두 담으면 생기는 장점은 다른 모듈과 충돌이 없어진다는 점입니다. 또 유지보수하고 확장하기 유리합니다. RTK와 Zustand를 기준으로 이제는 slice만 추가하는 확장을 해주면 됩니다. 특이한 점은 RTK-Query도 Store에 담습니다. ducks 패턴은 프로그램을 구성하는 방식에 대한 패턴입니다.

flux 패턴은 State가 단방향으로 흐르도록 하는 패턴입니다. 리덕스에는 Redux의 모듈(module)과 RTK의 슬라이스(slice)가 있습니다. 모두 논하겠습니다.

Redux의 모듈(module)의 경우 경우 Store 모듈에 모든 reducer를 결합시킵니다. Store에는 rootReducer를 위치시키고 combineReducers로 하나로 통합한 뒤에 createStore로 보관합니다. 그리고 전역상태로 관리할 reducer와 initial state를 만들고 state 갱신을 제어할 action을 만듭니다. action은 action value인 상수와 action creator 함수를 만듭니다. 또 action creator는 렉시컬 환경에 있는 action value를 참조하고 반환합니다. 만약에 dispatch할 컴포넌트에서 payload를 store로 전달해야 할 상황에는 객체를 반환하도록 합니다. 또 이 객체는 type을 키로 action value를 값으로 하고 payload를 객체 키의 식별자와 매개변수 식별자가 같아 단축구문으로 표기합니다. 또 selector 함수도 만들어 구독을 쉽게 해줄 수 있게 해줍니다. store에 있는 값을 읽기만 하는 행위를 보고 구독(subscribe)이라고 합니다. 반대로 값을 갱신할 때는 action creator와 dispatcher를 호출해야 합니다. dispatcher는 action creator를 담을 Middleware 함수입니다. dispatcher로 action creator를 전달하고 action creator로 action value로 실행시키려는 reducer의 type을 고르고 실행합니다. reducer의 action type에 해당하느 state가 갱신되고 그 state를 store에서 구독하던 모든 컴포넌트는 해당 갱신을 화면에 반영합니다.

RTK의 슬라이스(slice)의 경우 모듈이 슬라이스로 바뀐 것입니다. 더 간소해지고 서버통신을 위해 thunk도 지원했었고 현재는 RTK-Query를 지원하고 있습니다. 제일먼저 하는 것은 store를 만드는 것입니다. store는 configureStore에 reducer를 보관할 객체를 대입하면 됩니다. reducer를 키로하고 객체를 값으로 합니다. 객체를 값으로할 때 거기에 슬라이스에 해당하는 reducer를 넣으면 됩니다. 슬라이스를 만들 때는 initial state를 만들고 슬라이스를 만듭니다. createSlice 안에 객체를 대입하면 됩니다. action creator, action value는 name의 값으로 대체됩니다. initialState는 단축표기로 대입합니다. reducers에는 실행시킬 메서드를 담은 객체를 대입합니다. 객체의 메서드 이름은 createSlice의 action 프로퍼티를 객체 구조분해 할당으로 유출시킬 수 있습니다. 이 메서드 이름을 dispatcher에 대입해서 사용합니다. 또 통신과 관련될 경우 extraReducers 프로퍼티를 슬라이스 객체에 추가합니다. extraReducers는 빌더 표기법으로 thunk 함수를 작성합니다. thunk 함수는 고유한 키를 갖은 문자열을 대입하고 비동기 통신함수를 대입합니다. 비동기 통신함수는 payload와 thunkAPI를 매개변수로 갖는 함수입니다. 그리고 반환값은 thunkAPI의 프로퍼티별로 통신 상태에 따라 대입하면 됩니다. 또 구독을 위해 selector 함수도 만드는 것도 동일합니다. 또 dispatch할 때는 비동기는 thunk 함수를 동기는 슬라이스의 액션함수를 대입합니다.

다른 상태관리 도구는 도구별로 접근방법이 다 다릅니다. recoil, jotai의 경우 atom을 만들고 읽고 쓰기로 원자화된 상태관리를 합니다. 또 다른 아키텍쳐를 구성하는 전략으로 server state로 React-Query, SWR, apollo client와 간소한 client state(local state & globe state)로 context API, Jotai, Zustand와 조합해 사용하는 경우도 있습니다.

# 원티드

오늘은 다양한 상태관리와 hook들을 다루겠습니다.

useState는 간단한 상태에 주로 활용하거 서로 변수가 관련이 없을 때 활용합니다.

useReducer는 상태과 서로 관련이 될 수 있거나 참조가 필요할 때 활용합니다. 또 Context랑 많이 사용하기도 합니다.

컴포넌트 내에서 상태를 관리할 때 useState를 사용합니다.

useReducer는 상태가 복잡할 때 많이 활용합니다.

리액트에서 권장하는 것들이 있습니다. state 사용할 때 주의사항이 있습니다. 리액트는 state도 스냅샷을 찍습니다. 또 함수형 프로그래밍 원칙도 준수해야 합니다.

기본적인 내용 배칭입니다.

참고로 work를 찍는 작업은 은근히 손이 많이 갑니다.

state에 스냅샷이 있다고 했습니다. 이것은 배칭과 연결됩니다. state의 setter를 호출하면 업데이트 큐에 넣습니다. state는 렌더 페이지와 커밋 페이즈도 있는데 오토메틱 배칭으로 한번에 들어갑니다.

오토매틱 배칭에 들어가지만 큐를 한번에 반영합니다. 하지만 콜백함수로 대입하면 함수를 배칭하고 과거 것을 참조하고 반영합니다.

값이 변경되는 시점이 중요합니다. setter 함수 이후에 렌더를 트리거합니다. setter 함수 호출이 아니라 한번에 변경됩니다. 또 근본적으로 원시형 값을 그대로 넣는 행위 자체가 좋지 않은 습관입니다.

workLoopSync를 보면 확인할 수 있습니다.

setter 함수에 함수형 프로그래밍 원칙에 인풋과 아웃풋이 같아야 합니다.

외부의 값이 변할 때마다 다른 값을 반환할 것입니다.

미리 선언한 것에 이벤트가 추가되는 경우도 있습니다.

useEffect의 의존성 배열로 useState를 대입하면 잘못하면 무한 루프 발생 가능성이 있습니다.

업데이트 큐에 들어갈 때 값으로 들어갈지 함수로 들어갈지마다 처리가 달라집니다.

useReducer는 이커머스에서 사용자 관련정보가 복잡하기 때문에 그렇습니다.

useReducer를 활용하기 효율적인 경우는 관리할 상태가 많을 때 서로 관련이 있을 때 비즈니스 로직을 분리해야 할 때 불변성을 보전해야 할 때입니다.

useMemo는 함수의 값을 캐싱합니다. 리액트는 1ms이상 걸리면 활용을 권장합니다. 초기 렌더링할 때는 오래걸리지만 리렌더링할 때는 효율적입니다. 공식문서를 참조하도록 합니다. 시간복잡도가 선형시간복잡성이고 n이 5000을 초과하면 꽤 유리합니다. 렌더링 성능측정은 다음 시간에 다룹니다.

useCallback은 함수를 캐싱합니다. 주로 자식 컴포넌트에게 props로 대입할 때 많이 활용합니다. 자바스크립트 언어 특성 때문에 새롭게 함수가 정의되기 때문에 그렇습니다.

부모컴포넌트에 있는 값을 자식컴포넌트에서 변경하는 행위를 자제하는 것이 좋습니다.

자식에서 setState 함수를 호출하는 행위가 일단 안 좋은 행위입니다. 부모 컴포넌트가 다시 실행되면서 자식컴포넌트 동일한데 리렌더링됩니다.

modal도 전략이 다양합니다. 부모컴포넌트 개념을 제거하는 것도 전략입니다.

물론 컴포넌트를 useMemo에 담는 것도 전략입니다.

useMemo는 자주 사용할 필요가 없는 이유가 리렌더링이 많고 계산비용이 큰 것 위주로 사용해주면 됩니다.

useInsertionEffect도 라이브러리를 위한 hook이지만 면접질문에 질문합니다.

ES2023도 면접질문으로 나옵니다.

useTransition과 useDeferredValue는 사용할 일이 거의 없을 것 같습니다.

호출될 때마다 새로운 값을 반환합니다. uuid처럼 활용도 가능은 한데 레이블로 활용할 수 있습니다. 물론 오타 방지는 가능합니다.

프로그램을 잘 작성하면 내부 구현디테일을 잘 몰라도 활용하기 쉽다는 것입니다.

useDeferredValue는 블러킹 현상과 무관하게 독립적으로 동작하게 만들 수 있습니다. 디바운싱에 응용 가능성이 있습니다. 내부적으로 Fiber의 동시성하고 연결될 것이라 추측이 됩니다.

useSyncStore도 면접 질문에 나올 수 있습니다.

useEffect는 거의 필요없다는 블로그가 있습니다.

useLayoutEffect는 화면에 변경될 때마다 실행됩니다.

useEffect는 의존성배열을 최대한 덜 넣는 것이 좋습니다. 또 위에서 아래로 순서대로 실행됩니다.

useRef는 화면에 영향이 없을 때 활용합니다. 캔버스를 ref를 담을 때도 활용합니다. ref는 렌더링과 무관할 때 활용합니다.

전역으로 상태를 관리할 때 본인의 기준이 있어야 합니다. 2단계 이상 넘기면 전역으로 넘기는 것도 원칙이 될 수 잇습니다.

Next.js에서 window 객체로 서버인지 아닌지 판단합니다.

전역 상태 관리입니다.

제일 간단한 것은 ContextAPI입니다. ContextAPI가 커지면 다른 라이브러리를 활용합니다.

리액트 쿼리 탄생 비화를 알아야 합니다. 무엇이 불편헀는지 알고 사용하려고 해야 합니다.

리덕스도 provider를 사용해야 합니다. Context도 동일합니다.

contextAPI의 제일 큰 문제는 useContext가 있다는 이유만으로 불편해집니다.

리덕스는 모든 상태는 Store에 모든 값을 저장합니다. 리덕스의 장점은 개발자 도구과 디버깅을 수월하게 해줍니다. saga, thunk, persistent도 지원합니다. 구조가 복잡하고 사이즈가 작을 경우 불필요한 오버해드가 큽니다.

스타트업은 취소되는 제품이 많습니다. 또 리덕스를 모르는 신입을 받으면 러닝커브도 있습니다. 모두 아랑야 사용할 수 있습니다.

리덕스는 실제 상태관리 라이브러리입니다.

recoil은 구독하지 않으면 리렌더링하지 않아 리렌더링 효율이 좋습니다. 은근히 리렌더 효율이 좋습니다. 단점은 비동기처리가 않 좋습니다.

리코일은 같은 회사가 만들어 성능도 좋고 쉽습니다.

Mobx는 리덕스보다 더 배우기 쉽고 옵저버 패턴을 활용합니다.

4회차에는 이력서를 커스터마이징하는 전략을 다룰 것입니다.

요약입니다.

전역상태 관리 도구는 상황에 맞는 거 사용합니다.

사수가 없는 환경에서 성장하는 방법들입니다. 면접은 지금도 자주 봅닙니다. 신입부터 사수가 없었습니다.

글쓰는 커뮤니티를 글또로 얻은 것이 많았습니다. 연차 많은 사람들에게 보고 배웠습니다.

커리어리의 질의 응답을 잘 활용하는 것이 좋습니다. 실명제라 답변을 잘 해줍니다.

스터디를 하는 것도 좋은 전략입니다. 스터디를 구하고 관심있는 주제를 같이 탐구합니다.

사이드프로젝트는 사람마다 다르지만 혼자 하는게 편할 때가 있습니다.

DND, 매쉬업, 디프만, Yapp

사이드 프로젝트 신청받는 곳도 있습니다.

CI/CD는 중요한데 간단합니다. 회사가 크면 데브옵스가 대신해줍니다.

클라우드로 알아서 배포해주게 하면 되고 깃헙액션 활용하고 에저를 열심히 활용하도록 합니다.

이직할 때 애매하게 서로 알고 있는 사람이 서로 이직기회를 많이 줍니다.

링크드인으로 커피챗 연락도 은근히 옵니다.

네트워킹을 하려면 본인을 세상에 알려야 합니다.

제일 중요한 것은 좋은 코드를 보는 습관입니다. 샌드버드 리포를 잘 참조하도록 합니다.

몰로코 두나무 샌드버드 3가지 회사를 잘 참고하도록 합니다.

모달은 라우터 밖에 배치하는 방법으로 해결했습니다.

아키텍쳐는 중요한데 개념을 아는 것입니다. 그리고 회사 컨벤션을 잘 이해하는 것이 더 중요합니다.

디자인이 잘되어 있으면 아토믹 디자인은 괜찮습니다. 하지만 기능이 바뀌면 엎어지는 경우도 있습니다.

프론트엔드 엔지니어는 디자이너 잘 만나는 것이 중요합니다.

---

react-dom.development에 콘솔을 추가하면 확인할 수 있습니다.

Next.js보다 타입스크립트가 더 가치가 잇습니다. Next.js는 왜 사용하는지 알고 설명하는 부분이 좋을 수 있습니다.

사내 프레임워크를 개발하는 기업이면 이직에 불리할 것은 아닙니다.

기간이 있으면 성과를 내기는 좋지만 크개 상관없습니다.

회사에서 상용하는 코드를 작성하는 것이 더 공부하는 것보다 취업 빨리하는 것이 좋습니다.

꼭하고 싶은 말...

첫째 꾸준합니다. 둘째는 회사에서 잘할 수 있는 것에 집중하도록 합니다.

공부는 회사일을 잘하기 위해 공부하도록 합니다.

CS지식은 인터넷에 공개된 강의를 활용하는 것도 전략입니다.

아무리 별로라도 회사 경험이 더 좋습니다.

CS지식은 Next.js를 왜 사용하는지 집중하십시오.

타입스크립트는 공식문서로 공부합니다.

CS지식은 현업자보단 대학강의가 더 효율적입니다. 강사가 강의만 전담합니다.

신입은 좋은 사수를 못알아볼 가능성이 있습니다.

사수가 없으면 동료라도 있으면 좋습니다.

flux 패턴이 단방향이라는 것에 집중해서 답하도록 합니다.

최대한 간결하게 답해서 자신감이 있어 보일 수 있습니다. 길게 말하면 침투 기회를 주는 것입니다.

좋은 리액트도서는 최근 공식문서를 보는 것이 좋습니다.

CS는 책도 좋습니다. 네트워크는 요즘 IT를 잘 참고합니다.

setState는 Input에는 디바운싱하는 것도 전략입니다.

주니어 취업 준비를 하기 위해서는 프론트는 SQL은 굳이 필요없습니다. 회사에서 리액트를 사용할 때 리액트를 아주 잘 사용하는 신입이 더 좋습니다.

본인을 희생하는 동료가 편합니다. 본인이 안해도 괜찮은데 해주는 동료가 좋습니다. 하지만 불만은 있지만 해결책을 제시하지 않는 동료, 고집이 너무 쎈 개발자도 생대하기 힘듭니다.

Mobx는 가볍지만 제일 가벼우면 리코일이 제일 가볍습니다.

구독은 값의 변화를 계속 참조한다는 의미입니다.

회사를 가면 먼저 오픈마인드로 가는 것이 좋습니다.

프론트엔드 <실전에서 바로쓰는 Next.js>를 잘 참조합니다.

꿀팁은 프로젝트는 최대한 잘하려고 하고 고민을 많이하고 어느정도 고민하고 질문도 합니다.

contextAPI는 쪼개는 것말고 방법이 없습니다.

이재성 선생님 리액트를 추천합니다.

웹팩은 웹팩공부할 시간에 자바스크립트를 더 공부하는 것이 좋습니다.

연봉협상 노하우는 회사에 중요한 사람이라는 것을 알려야 합니다. 그리고 다른 곳에 면접 보는 것이 전략입니다. 하지만 카운터 오퍼는 잘해야 합니다. 또 연봉협상을 잘하려면 정리도 잘해야 합니다. 분기별로 이력서를 잘 준비합니다.

브라우저에서 store로 개인 정보를 저장하면 안됩니다.

첫취업까지 2달 걸렸습니다. 부트캠프에서 3개월차에 연계를 시키기고 뽑힌 경우입니다. 그 당시는 2019년도에 시장이 좋았습니다.

개발을 시작할 때 hook이 나오기 시작한 경우였습니다.

신입이 뭘알아야 하는지는 다음주 월요일에 다룹니다.

초봉은 전공 비전공 상관없습니다.

신입 포폴은 개발자 관점에 최대한 집중하도록 합니다.

의외로 초봉은 운입니다. 전공 더 처주고 그런거 없습니다.

s3는 편합니다. 퍼블릭 IP를 활용하기 쉽습니다. aws 배포는 저의 블로그 잘 참고하도록 합니다.

동물책이 좋습니다. 모자딥은 고전입니다.

vite은 신기술 관심 많을 때 어필할 때 활용합니다.

최근에는 아토믹을 많이 활용합니다. MVC 패턴도 많이 활용했었습니다.

유튜브도 합니다.

주말출근보단 평일야근을 합니다.

회사일을 잘하는 개발자 더 좋습니다.

포트폴리오 업데이트는 하는 것이 좋습니다. 아니면 리팩토링하는 것을 블로그로 정리하는 것이 더 좋습니다.

CSS보단 리액트, 자바사크립트에 집중하는 것이 더 좋습니다.

기록은 2주에 1번은 작성합니다. 챌린저스 붙으면 돈을 걸고 진행하게 됩니다.

사수 없었을 때 힘들었던 것은 디버깅 아니면 별거 아니었을 때입니다.

기억남는 신입은 모르는 질문을 하던 신입이었습니다.

디자이너랑 논의할 것이면 본인이 만든 컴포넌트를 모았는지 물어보도록 합니다.

섯부른 퇴사는 항상 위험합니다. 혼자면 하고 싶은 것 할수 있다는 점을 활용하도록 합니다.

Flutter는 노마드 코더 강의가 의외로 좋습니다.

스토리북은 초기면 급하게 만드는 것이 많아서 조심할 필요가 있습니다.

경력 이직은 경험위주로 많이 물어보지만 CS 지식은 거기서 역입니다.

부트캠프는 작성하는 것은 크게 도움 안됩니다.

포기는 수료기준 1년 잡지만 사람마다 다릅니다. 한가지 파악할 것은 대기업, 공무원 5년 준비하는 사람들도 많습니다.

문서작성은 좋은 경험입니다.

리액트 라이브러리 코드 까보는 것을 많이 안 합니다. 공부용으로 하는 것 뿐입니다.

리액트에서 0번째 인덱스값을 추가하지 않는 것이 좋습니다. 첫번째 자식은 특수합니다.

신입은 최적화 잘 알아야 합니다. 원리까지 잘 파악해야 합니다. 물론 기대도 안 하는 회사도 있습니다.

프로젝트는 퀄리티보단 기간을 맞추는 것이 더 중요합니다.

자바스크립트 기본은 모던 자바스크립트 딥다이브로 해결합니다.

이력서에는 경력기술서를 작성합니다.

이력서는 가능하면 채용공고에 맞게 작성합니다.

자바스크립트를 타입스크립트로 전환하는 과정이 어렵습니다.

useDifferedValue는 디바운스를 완전히 대체할 것 같지 않습니다.

CI/CD 이론은 나중에 알려줍니다.

플레이 태그

빠르게 짜고 빠르게 수정하는 전략입니다. 지금 최선의 코드를 작성하고 리팩토링을 자주 합니다.

애니메이션은 framer motion보단 chatGPT로 편하게 만들 수 있습니다.

라이브러리 사용하는 것은 실력이 아닙니다. 문서 잘 읽는 실력은 실력이 아닙니다.

위코드이고 말고 상관없습니다. 항해 99도 잘 배운 사람도 있었습니다. 싼값이 좋습니다.

블로그는 꾸준함과 성장이 중요합니다.

디자이너랑은 래퍼런스랑 커뮤니케이션합니다.

아이콘은 안 정하면 개발자가 정합니다.

코드 퀄리티가 안 좋은 것은 상관없고 점점 좋아져야 합니다.

리팩토링을 하는 것이 좋습니다.

체력관리를 위해 조깅을 자주 했습니다.

자바스크립트의 언어적인 특성을 아주 잘 이해하는 것이 특이한 메서드보다 가치가 더 큽니다.

경력은 경험위주로 질문합니다. 신입은 산업 도메인과 열정 위주 작성합니다.

PR보단 블로그를 더 열심히 작성하는 것이 좋습니다.

라이브러리를 최대한 안 의존하는 방법 중 하나는 fork를 하고 import를 잘 따라가변 됩니다. 거시거 필요없는 거 정당히 삭제합니다.

마이크로 프론트엔드는 다음주 금요일에 다룹니다.

주석은 복잡할 수 밖에 없는 함수에 작성합니다.

코딩테스트는 그때그때합니다. 서류 통과하면 그때 합니다.

플레이 태그 채용 진행 중입니다.

리액트 네이티브는 새로고침이 잘 안되고 이런 처리를 잘 해야 합니다. 또 렌더링 처리도 잘해야 합니다.

타입스크립트는 기존에 있는 것을 바꾸는 것이 어렵습니다.

프로젝트는 비공개로 하지 않습니다. 공개하고 github을 잘 관리하도록 합니다.

글을 잘 쓰는 방법은 계속 써보고 감을 잡습니다.

객체지향은 원칙을 잘 이해하는 것입니다. 클래스를 쓰는 것이 아닙니다.

이력서 포폴은 회사마다 커스텀합니다.

경력당 실력은 면접으로 파악합니다.

모바일은 리액트 네이티브를 할 때 가끔은 네이티브 언어를 작성해야 할 때가 있습니다. 하지만 공식문서 패턴을 잘 참조할 정도로 하면 됩니다.

연봉이 적어도 성장기회가 많으면 바로 선택하도록 합니다. 물론 연봉이 심각하면 다시 고민하도록 합니다.
